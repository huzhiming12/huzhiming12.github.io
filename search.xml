<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面经总结]]></title>
    <url>%2F2017%2F07%2F05%2F%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[[TOC] Java基础Java容器HashMap底层实现hashMap底层存储是用一个Entry数组，数据中每个Entry都是一个链表，当新元素添加时，直接添加到链表头即可。 hashMap可以设定初始容量，不设定的话初始容量为16，默认加载因子是loadFactor=0.75，当map中的元素个数n&gt;=table.length*0.75时，Map会发生扩容，扩容机制是原来数组长度的两倍：resize(2 * table.length)。 hashMap 解决冲突的办法是将数组元素设计成一个链表，当同一个有多个元素映射到同一个数组元素中，直接将其添加到链表头，更好的解决冲突的办法是将链表设计成一颗红黑树。 map详细介绍参照： https://huzhiming12.github.io/2017/05/10/java/Java%E9%9B%86%E5%90%88-Map%E4%BB%8B%E7%BB%8D/ 数据库数据库事务的理解事务：用户定义的一个数据库操作序列，要么全都做，要么全都不做，是一个不可分割的工作单位。 事务的四个特性：原子性、一致性、隔离性、持续性。 原子性：事务中的操作要么全都做，要么全都不做。 一致性：事务的执行结果必须是从一个状态变到另一个状态。当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。 隔离性：一个事务的执行不能被其他事务干扰。 持续性：一个事务一旦提交，他对数据库中数据的改变就应该是永久的。 数据库的隔离级别Read Uncommited 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 ReadCommited 写事务的时候不允许其他事务，读事务的时候可以其他事务 RepeatableRead 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 serializable(序列化) 它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行 脏读 不可重复读 幻读 read Uncommited yes yes yes read Commited no yes yes repeatableRead no no yes serializable no no no Spring 框架SpringMVCSpring MVC运行原理 1.http请求：客户端请求提交到DispathcherServlet. 2.寻找处理器：DispatcherServlet控制器查询一个或多个HandlerMaping，找到处理请求的Controller(我们俗称Controller，实际是Handler)。 3.调用处理器：DispatcherServlet将请求提交到Controller中。 4.5.调用处理业务和返回结果：Controller调用业务逻辑处理后，返回ModelAndView 6.7处理视图映射并返回模型：DispathcerServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图 8.Http响应：视图复制将结果显示到客户端 数据结构]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[负载均衡几种方式]]></title>
    <url>%2F2017%2F06%2F29%2F%E6%9E%B6%E6%9E%84%2F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[负载均衡的几种方式​ 负载均衡是网站架构必不可少的基础手段，不但可以实现网站的伸缩性，同时还可以改善网站的可用性。负载均衡的方式有以下几种： Http重定向负载均衡 DNS域名解析负载均衡 反向代理负载均衡 IP负载均衡 数据链路层负载均衡 Http重定向负载均衡 Http重定向服务器唯一功能就是根据用户的http请求计算一台真实的web服务器地址，并将该web服务器地址写入http重定向相应中返回给用户浏览器。 这种方案的有点事比较简单，缺点是浏览器每次请求都需要两次请求服务器才能完成，性能较差。重定向服务器自身处理能力可能成为瓶颈。 DNS域名解析负载均衡 DNS服务器中配置了多个A 记录： www.mysite.com IN A 114.100.80.1; www.mysite.com IN A 114.100.80.2; www.mysite.com IN A 114.100.80.3; 每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置的多个服务器就构成一个集群，并实现负载均衡。 优点：将负载均衡的工作转交给DNS，省掉了网络管理维护负载均衡服务器的麻烦，同时许多DNS还支持基于地理位置的域名解析，即会将域名解析成距离用户地理位置最近的服务器地址，这样可加快用户访问速度，改善性能。 缺点：目前DNS是多级解析，每一级DNS都可能缓存A记录，当下线某台服务器后，即使修改了DNS的A记录，要使其生效也需要较长的时间，这段时间DNS依然会将域名解析到已经下载的服务器，导致访问失败。而且DNS负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。 一般大型网站总是部分使用DNS域名解析，利用域名解析作为第一级负载均衡，即域名解析得到的一组服务器实际上同样是负载均衡服务器，这组内部的负载均衡服务器在进行负载均衡，将请求分发到真是的web服务器上。 反向代理负载均衡 IP负载均衡 用户请求数据包到达负载均衡服务器114.100.80.10后，负载均衡服务器在操作系统内核进程获取网络数据报，根据负载均衡算法计算得到一台真实web服务器10.0.0.1，然后将数据目的IP地址修改为10.0.0.1，不需要通过用户进程处理。处理完成之后，响应数据报回到负载均衡服务器，负载均衡服务器再将数据报源地址修改为自身的IP地址发送给用户浏览器。 真实web服务器如何将响应数据包返回给负载均衡服务器，方案是：在负载均衡服务器修改目的IP地址的同时修改源地址，将数据报原地址设为自身IP，这样web服务器的响应会再回到负载均衡服务器。 缺点：所有请求响应都必须经过负载均衡服务器，对于下载或者视频等服务，负载均衡服务器会成为瓶颈。 数据链路层负载均衡 负载均衡算法 轮询 所有请求被依次分发到每台应用服务器上。 加权轮询 在轮询的基础上，按照配置的权重将请求分发到每个服务器上，高性能的服务器能分配到更多的请求 随机 请求被随机分配到各个应用服务器上 最少连接 记录每个应用服务器正在处理的连接请求数，将新的请求分发到最少连接的服务器上。 源地址散列 根据请求来源的IP地址进行Hash计算，得到应用服务器，这样来自同一个IP地址的请求总在一个服务器上处理。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统命令]]></title>
    <url>%2F2017%2F06%2F20%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FLinux-%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一 、文件安全与权限 文件1234ls - ltotal 145456-rwxr-xr-x 1 root root 9338896 Dec 22 21:24 apache-tomcat-7.0.53.zip-rwxr-xr-x 1 root root 139444114 Dec 22 21:26 jdk-7u51-linux-i586.tar.gz total 145456：表示这个目录中所有文件占用的大小 -rwxr-xr-x： -：这个位表示文件类型 其余9个字符分别对应9个权限位，r：可读 w:可写 x:可执行 -：禁止该项操作 rwx：文件属主的权限 前三位 r-x：同组用户权限 中间三位 r-x：其他用户权限 最后三位 1：该文件的硬链接的数目 root：文件的属主 root：文件数组所在的缺省组 9338896：表示文件长度，单位是字节 Dec 22 21:24：文件最后更新时间 apache-tomcat-7.0.53.zip：文件名 文件类型d：目录 l：符号链接 s：套接字文件 b:块设备文件 c:字符设备文件 p:命名管道文件 -：普通文件 改变文件权限符号模式1chmod [who] operator [permission] filename who的含义： u：文件属主的权限 g：同组用户权限 o：其他用户权限 a：所有用户权限 operator的含义： +：增加 -：取消权限 =：设定权限 permission的含义： r：读 w:写 x:执行 绝对模式1chmod [mode] file mode含义：Mode中包含3个数， 741 第一个数代表文件属主的权限 第二个数代表文件属主同组用户权限 第三个数代表其他用户权限 每个数转换成3位的二进制，如7 转换成111， 第一位：表示读的权限，0：不可读 1：表示可读 第二位：表示写的权限 0：不可写 1：可写 第三位：表示执行权限 0：不可执行 1：可执行 12345chmod 741 code#执行之后权限 7-&gt;111:可读 可写 可执行# 4-&gt;100:可读 不可写 不可执行# 1-&gt;001:不可读 不可写 可执行-rwxr----x 1 root root 0 Jun 20 10:40 code 可同过 -R选项连同子目录下的文件一起设置权限 1chmod -R 741 /root/test/* ​ 更改文件所属用户chown,更改用户所属组chgrp1chown user filename 1chgrp group filename 符号链接 有两种不同的链接，软连接和硬链接。我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。 硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。 123456789101112#创建硬链接 source_path:真实的文件 target:创建的硬链接ln source_path target#创建软链接ln -s source_path target#查看文件属性,包括inodels -litotal 8303106 -rwxr----x 2 root root 55 Jun 21 10:23 code303106 -rwxr----x 2 root root 55 Jun 21 10:23 hard.link303108 lrwxrwxrwx 1 root root 22 Jun 21 10:31 soft -&gt; /root/apache-tomcat-7/303107 lrwxrwxrwx 1 root root 4 Jun 21 10:22 soft.link -&gt; code 303106:文件的inode，真实文件code 和硬链接hard.link的iNode是相同的 软链接文件soft.link的inode与code是不相同的，它指向了code文件 二、使用find和xargsfind命令选项1find pathname -option [-print -exec -ok] pathname:表示要查找的目录路径 name选项 12# 查找自己根目录下以 .txt结尾的文件find ~ -name "*.txt" -print 12# 查找etc目录下以Host 开头的文件find /etc -name "host*" -print 使用perm选项 12#查找当前目录下 权限是755的文件find . -perm 755 -print 忽略某个目录 prune 12#在当前目录下找含有 . 的文件，其中忽略 ./app这个文件夹find ./ -path ./app -prune -o -name "*.*" -print 使用user和nouser选项 12#在自己的根目录下找所属用户是Ubuntu的所有文件find ~ -user ubuntu -print 12#在自己的根目录下查找 属主账户被删除的所有文件find ~ -nouser -print 使用group和nogroup选项 12#在当前目录下查找 所属组是root的所有文件find ./ -group root -print 12#在当前目录下查找 所属组被删除的所哟文件find ./ -nogroup -print 按照更改时间查找文件 12#在当前目录下查找最后更改时间在5日以内的文件find ./ -mtime -5 -print 12#在当前目录下查找最后更改时间在3日之前的文件find ./ -mtime +3 -print 使用type选项 12#在当前目录下查找所有目录find ./ -type d -print 12#在当前目录下查找所有除目录以外的文件find ./ ! -type d -print 使用size选项 文件长度可以有两种衡量方式，一种是一块为单位（一块=512字节），另一种是以字节为单位，表达方式 N c(如1000c，表示1000字节)。 12#在当前目录下查找长度大于1000字节的所有文件find ./ -size +1000c 12# 在当前目录下查找长达小于1000字节的所有文件find ./ -size -1000c 12# 在当前目录下查找文件长度等于1000块的文件(1块=512字节)find ./ -size 1000 depth命令，在目录中查找，首先匹配文件，然后再在子目录中查找。 1find ./ -name "*.txt" -depth -print mount，查找是不进入其他文件系统，只在当前文件系统中查找 1find ./ -name "*.txt" -mount -print]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>shell命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——适配器模式]]></title>
    <url>%2F2017%2F06%2F19%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式：将一个类的接口转换成客户希望的另一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 被适配的对象，即含有特殊功能的类，客户端需要调用这个类中的特殊功能，但是因为接口不匹配，所以不能调用， 12345678910/** * 被适配的对象,含有特殊的功能 */class Adaptee&#123; public void spacialRequest() &#123; System.out.println("被适配的对象,具有的特殊功能"); &#125;&#125; 适配器， 12345678910/** * 适配器对象 */class Adapter extends Adaptee implements Target&#123; public void request() &#123; super.spacialRequest(); &#125;&#125; 抽象的目标类 1234567/** * 目标对象接口 */interface Target&#123; void request();&#125; 抽象目标类的具体实现，只含有普通的功能 12345678910/** * 目标对象的实现,含有的是普通的功能 */class ConcreateTarget implements Target&#123; public void request() &#123; System.out.println("普通的需求"); &#125;&#125; 测试类 12345678910public class AdapterDemo&#123; public static void main(String[] args) &#123; Target commonTarget = new ConcreateTarget(); commonTarget.request(); Target adapter = new Adapter(); adapter.request(); &#125;&#125; 12普通的需求被适配的对象,具有的特殊功能]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——观察者模式]]></title>
    <url>%2F2017%2F06%2F19%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式：观察者模式有佳作发布-订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。 Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。 ConcrereObserver：具体观察者，是实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 下面是一个微信工作号发布-订阅的一个例子： 抽象的观察者 1234abstract class Observer&#123; public abstract void update(String message);&#125; 具体的观察者对象：微信用户 1234567891011121314class WechatUser extends Observer&#123; private String userName; public WechatUser(String userName) &#123; this.userName = userName; &#125; public void update(String message) &#123; System.out.println(this.userName + " " + message); &#125;&#125; 抽象的主题类： 12345678abstract class Subject&#123; public abstract void attach(Observer observer); public abstract void detach(Observer observer); public abstract void notify(String message);&#125; 具体的一个主题，主题可以有多个，这里列举了一个 12345678910111213141516171819202122232425262728class WechatSubject extends Subject&#123; private ArrayList&lt;Observer&gt; users = new ArrayList&lt;Observer&gt;(); private String name; public WechatSubject(String name) &#123; this.name = name; &#125; public void attach(Observer observer) &#123; users.add(observer); &#125; public void detach(Observer observer) &#123; users.remove(observer); &#125; public void notify(String message) &#123; for (Observer user : users) &#123; user.update(name + message); &#125; &#125;&#125; 测试类： 1234567891011121314151617public class ObserverDemo&#123; public static void main(String[] args) &#123; Observer user1 = new WechatUser("张三"); Observer user2 = new WechatUser("李四"); Observer user3 = new WechatUser("王五"); Subject subject = new WechatSubject("科技前沿"); subject.attach(user1); subject.attach(user2); subject.attach(user3); subject.notify("添加了一篇文章&lt;&lt;云计算&gt;&gt;"); System.out.println(); subject.notify("添加了一篇文章&lt;&lt;大数据时代&gt;&gt;"); &#125;&#125; 测试输出： 1234567张三 科技前沿添加了一篇文章&lt;&lt;云计算&gt;&gt;李四 科技前沿添加了一篇文章&lt;&lt;云计算&gt;&gt;王五 科技前沿添加了一篇文章&lt;&lt;云计算&gt;&gt;张三 科技前沿添加了一篇文章&lt;&lt;大数据时代&gt;&gt;李四 科技前沿添加了一篇文章&lt;&lt;大数据时代&gt;&gt;王五 科技前沿添加了一篇文章&lt;&lt;大数据时代&gt;&gt;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——建造者模式]]></title>
    <url>%2F2017%2F06%2F19%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造者模式：将一个复杂对象的建造与它的表示分离，是得同样的构建过程可以创建不同的表示。 House：产品类，需要建造的产品 123456789101112131415class House&#123; private ArrayList&lt;String&gt; parts = new ArrayList&lt;String&gt;(); public void addPart(String part) &#123; parts.add(part); &#125; public void showHous() &#123; for (String part : parts) System.out.println(part); &#125;&#125; Builder：建造House的抽象类，定义了建造各部分的接口 12345678910abstract class AbstractHouseBuilder&#123; public abstract void buildWindow(); public abstract void buildDoor(); public abstract void buildWall(); public abstract House getHouse();&#125; Builder：建造的具体实现了，有不同的实现方式，对每个部件提供具体的建造方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class HouseBuilder1 extends AbstractHouseBuilder&#123; private House house = new House(); public void buildWindow() &#123; house.addPart("铝合金窗户"); &#125; public void buildDoor() &#123; house.addPart("铝合金门"); &#125; public void buildWall() &#123; house.addPart("白色墙"); &#125; public House getHouse() &#123; return house; &#125;&#125;class HouseBuilder2 extends AbstractHouseBuilder&#123; private House house = new House(); public void buildWindow() &#123; house.addPart("木质窗户"); &#125; public void buildDoor() &#123; house.addPart("木质门"); &#125; public void buildWall() &#123; house.addPart("木质纹理墙"); &#125; public House getHouse() &#123; return house; &#125;&#125; Director：指挥者，负责建造的过程的流程控制，每个步骤需要做什么 123456789class Director&#123; public void CreateHouse(AbstractHouseBuilder builder) &#123; builder.buildWall(); builder.buildWindow(); builder.buildDoor(); &#125;&#125; 测试类 12345678910111213141516171819public class BuilderDemo&#123; public static void main(String[] args) &#123; Director director = new Director(); AbstractHouseBuilder builder1 = new HouseBuilder1(); AbstractHouseBuilder builder2 = new HouseBuilder2(); System.out.println("房屋一:"); director.CreateHouse(builder1); House house1 = builder1.getHouse(); house1.showHous(); System.out.println("\n房屋二:"); director.CreateHouse(builder2); House house2 = builder2.getHouse(); house2.showHous(); &#125;&#125; 输出结果： 123456789房屋一:白色墙铝合金窗户铝合金门房屋二:木质纹理墙木质窗户木质门]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>建造模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——外观模式]]></title>
    <url>%2F2017%2F06%2F19%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观类： 123456789101112131415161718192021222324class Fund&#123; private Sokect1 sokect1 = new Sokect1(); private Sokect2 sokect2 = new Sokect2(); private Sokect3 sokect3 = new Sokect3(); public void buyFund() &#123; System.out.println("买入基金,包括以下操作:"); sokect1.buySokect(); sokect2.buySokect(); sokect3.buySokect(); System.out.println(); &#125; public void sellFund() &#123; System.out.println("卖出基金,包括以下操作"); sokect1.sellSokect(); sokect1.sellSokect(); sokect1.sellSokect(); System.out.println(); &#125;&#125; 子类： 1234567891011121314151617181920212223242526272829303132333435363738class Sokect1&#123; public void buySokect() &#123; System.out.println("购买股票一!"); &#125; public void sellSokect() &#123; System.out.println("卖出股票一"); &#125;&#125;class Sokect2&#123; public void buySokect() &#123; System.out.println("购买股票二!"); &#125; public void sellSokect() &#123; System.out.println("卖出股票二"); &#125;&#125;class Sokect3&#123; public void buySokect() &#123; System.out.println("购买股票三!"); &#125; public void sellSokect() &#123; System.out.println("卖出股票三"); &#125;&#125; 测试类： 123456789public class FacadeDemo&#123; public static void main(String[] args) &#123; Fund fund = new Fund(); fund.buyFund(); fund.sellFund(); &#125;&#125; 输出： 123456789买入基金,包括以下操作:购买股票一!购买股票二!购买股票三!卖出基金,包括以下操作卖出股票一卖出股票二卖出股票三]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——模板方法模式]]></title>
    <url>%2F2017%2F06%2F15%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式，定义一个操作中的算法骨架，而将一些不走延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式是通过把不变行为版移到超类中，去除子类中的重复代码，提供了一个很好的代码复用平台。 抽象的模板类：把所有重复的代码集成到模板方法中 12345678910111213abstract class AbstractClass&#123; public abstract void primitiveOperation1(); public abstract void primitiveOperation2(); public void templateMethod() &#123; primitiveOperation1(); primitiveOperation2(); System.out.println("模板方法"); &#125;&#125; 具体实现类一： 1234567891011class ConCreateClassA extends AbstractClass&#123; public void primitiveOperation1() &#123; System.out.println(this.getClass().getName() + " 操作一"); &#125; public void primitiveOperation2() &#123; System.out.println(this.getClass().getName() + " 操作二"); &#125;&#125; 具体实现二： 123456789101112class ConCreateClassB extends AbstractClass&#123; public void primitiveOperation1() &#123; System.out.println(this.getClass().getName() + " 操作一"); &#125; public void primitiveOperation2() &#123; System.out.println(this.getClass().getName() + " 操作二"); &#125;&#125; 测试类： 12345678910public class TemplateDemo&#123; public static void main(String[] args) &#123; AbstractClass a = new ConCreateClassA(); AbstractClass b = new ConCreateClassB(); a.templateMethod(); b.templateMethod(); &#125;&#125; 模版方法模式的结构 模版方法模式由一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种： 抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。 模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。 钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。 抽象类的任务是搭建逻辑的框架，通常由经验丰富的人员编写，因为抽象类的好坏直接决定了程序是否稳定性。 下面用一个排序算法的例子说明： 抽象的排序算法类：定义了一个抽象排序算法方法，和一个显示排序结果的模板方法类。 1234567891011121314abstract class AbstractSort&#123; public abstract void sort(int[] arr); public void showSortResult(int[] arr) &#123; sort(arr); System.out.println("排序后结果:"); for (int i = 0; i &lt; arr.length; i++) System.out.print(arr[i] + " "); System.out.println(); &#125;&#125; 冒泡排序算法的实现类： 1234567891011121314151617181920class BubleSort extends AbstractSort&#123; public void sort(int[] arr) &#123; int len = arr.length; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 选择排序的实现类： 123456789101112131415161718class InsertSort extends AbstractSort&#123; public void sort(int[] arr) &#123; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; int temp = arr[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; arr[j + 1] = arr[j]; j--; &#125; arr[++j] = temp; &#125; &#125;&#125; 测试类： 12345678910public class TemplateDemo&#123; public static void main(String[] args) &#123; AbstractSort bubleSort = new BubleSort(); bubleSort.showSortResult(new int[]&#123;4, 6, 1, 6, 3, 6, 9, 2, 0&#125;); AbstractSort insertSort = new InsertSort(); insertSort.showSortResult(new int[]&#123;6, 3, 5, 1, 4, 7, 9, 4, 2, 0&#125;); &#125;&#125; 结果： 1234排序后结果:0 1 2 3 4 6 6 6 9 排序后结果:0 1 2 3 4 4 5 6 7 9 参考：http://www.importnew.com/15546.html]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——原型模式]]></title>
    <url>%2F2017%2F06%2F15%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 原型模式原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何的创建细节。下面我们通过一个例子来说明，对用户信息的复制。 原型类：实现Cloneable接口，表明这个类是可以复制的，复制方法直接用调用本地的Native方法复制。 123456789101112131415abstract class Prototype implements Cloneable&#123; @Override public Object clone() &#123; try &#123; return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 用户信息类：UserInfo 继承了Prototype，clone方法直接调用Prototype的克隆方法 1234567891011121314151617181920212223242526272829class UserInfo extends Prototype&#123; String name; String birthDate; String address; University university; public UserInfo(String birthDate, String address, String name, University university) &#123; this.birthDate = birthDate; this.address = address; this.name = name; this.university = university; &#125; @Override public String toString() &#123; return "UserInfo&#123;" + "name='" + name + '\'' + ", birthDate='" + birthDate + '\'' + ", address='" + address + '\'' + ", university=" + university + '&#125;'; &#125; @Override public Object clone() &#123; return super.clone(); &#125;&#125; University类： 123456789101112131415class University&#123; String uName; public University(String uName) &#123; this.uName = uName; &#125; @Override public String toString() &#123; return "&#123;" + "uName='" + uName + '\'' + '&#125;'; &#125;&#125; 测试类： 12345678910public class PrototypeDemo&#123; public static void main(String[] args) throws CloneNotSupportedException &#123; UserInfo info = new UserInfo("张三", "1990-03-23", "山东青岛"); UserInfo infoCopy = (UserInfo) info.clone(); System.out.println(info); System.out.println(infoCopy); &#125;&#125; 输出结果： 12UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;青岛大学&apos;&#125;&#125;UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;青岛大学&apos;&#125;&#125; 原型模式的优点及适用场景 使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。 ​ 因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。 浅拷贝与深拷贝浅拷贝Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如上面的例子中，用户信息中有一个对象是所在的大学，对university字段进行如下修改： 12345UserInfo info = new UserInfo("张三", "1990-03-23", "山东青岛",new University("青岛大学"));UserInfo infoCopy = (UserInfo) info.clone();infoCopy.university.uName="中国海洋大学";System.out.println(info);System.out.println(infoCopy); 输出结果是： 12UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;中国海洋大学&apos;&#125;&#125;UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;中国海洋大学&apos;&#125;&#125; infoCopy是info的一份拷贝，对infoCopy的修改原则上info中的信息是不会变得，但是Object中的clone方法只是一个浅拷贝，浅拷贝只会拷贝8种基本数据类型和String，对于数组、容器、引用对象只是拷贝对其的引用。 深拷贝深拷贝就是对对象中的所有数据进行拷贝，包括基本数据类型和引用对象。具体实现就是必须将原型模式中数组对象、引用对象、容器对象等进行单独的拷贝。 UserInfo对象中clone方法修改： 1234567891011121314151617class UserInfo extends Prototype&#123; …… @Override public Object clone() &#123; UserInfo info = (UserInfo) super.clone(); try &#123; info.university = (University) this.university.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return info; &#125;&#125; University类中添加clone方法： 123456789class University implements Cloneable&#123; …… @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 输出结果： 12UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;青岛大学&apos;&#125;&#125;UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;中国海洋大学&apos;&#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——代理模式模式]]></title>
    <url>%2F2017%2F06%2F14%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理（proxy）提供对目标对象的另外一种访问方式，即通过代理对象访问目标对象。这样做的好处就是：可以在目标对象的基础之上增强额外的功能操作，即扩展目标对象的功能。 编程思想：不要随便修改别人已经写好的功能方法，如果要修改可以通过代理的方式来扩展该方法。 静态代理静态代理代理对象和被代理对象一起实现相同的接口，或者是继承相同的父类。 接口父类： 123public interface IUserDAO&#123; void save();&#125; 目标对象： 12345public class UserDAO implement IUserDAO&#123; public void save()&#123; System.out.println("数据正在保存！"); &#125;&#125; 代理对象： 1234567891011public class UserDAOProxy implement IUserDAO&#123; private IUserDAO target； public UserDAOProxy(IUserDAO target)&#123; this.target=target; &#125; public void save()&#123; System.out.println("数据校验完毕，开始保存数据！"); target.save(); //执行目标方法 System.out.println("数据保存完毕！"); &#125;&#125; 测试类： 123456789public class Main&#123; public static void main(String[]args)&#123; //创建目标对象 IUserDAO target = new UserDAO(); //代理对象，把目标对象传给代理对象，建立代理关系 UserDAOProxy proxy = new UserDAOProxy(target); proxy.save(); &#125;&#125; 静态代理可以在不修改目标对象的前提下实现对目标对象的扩展， 缺点：但是静态代理必须要实现与目标对象一样的接口，这样就会产生很多代理类，类很多。一旦接口方法增加，目标对象和代理对象都要进行维护修改。 动态代理动态代理主要有两种方法，一种是JDK动态代理，一种是第三方库 cglib动态代理。 JDK动态代理jdk动态代理是基于Java反射机制实现的。 Proxy代理类，通过newInstance()方法，创建代理类。 1234public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException ClassLoader loader：被代理对象的类加载器 Class&lt;?&gt;[] interfaces:被代理对象中实现的接口类型 InvocationHandler h：事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入 下面是测试样例 父类接口： 12345interface IUserDAO&#123; void save(); void delete();&#125; 目标对象，实现父类接口 123456789101112131415class UserDAO implements IUserDAO&#123; @Override public void save() &#123; System.out.println("user info saving..."); &#125; @Override public void delete() &#123; System.out.println("user is delete!"); &#125;&#125; InvocationHandler类，每个代理 的实例都关联了一个handler，每个代理对象调用方法时候，都会转变为有InvocationHandler调用invoke()方法。 123456789101112131415161718class ProxyHandler implements InvocationHandler&#123; private Object target; public ProxyHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("代理方法 " + method.getName() + " 开始"); Object res = method.invoke(target, args); System.out.println("代理方法 " + method.getName() + " 结束"); return res; &#125;&#125; 测试类 1234567891011121314151617public class JDKProxy&#123; public static void main(String[] args) &#123; //目标对象，即被代理对象 IUserDAO target = new UserDAO(); //我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 ProxyHandler proxyHandler = new ProxyHandler(target); IUserDAO userDAO = (IUserDAO）Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), target.getClass().getInterfaces(), proxyHandler); userDAO.save(); userDAO.delete(); &#125;&#125; 代理方法 save 开始 user info saving… 代理方法 save 结束 代理方法 delete 开始 user is delete! 代理方法 delete 结束 jdk动态代理生成代理对象速度快，但是有一个局限就是被代理对象必须实现接口，若被代理对象没有实现接口，将不能进行jdk动态代理。 第三方库CGLib动态代理CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。 被代理对象： 1234567class UserDaoImpl&#123; void save() &#123; System.out.println("info saved!"); &#125;&#125; 123456789101112131415161718192021222324252627class CglibProxy implements MethodInterceptor&#123; private Object target; public CglibProxy() &#123; &#125; public CglibProxy(Object target) &#123; this.target = target; &#125; @Override public Object intercept(Object arg0, Method method, Object[] arg2, MethodProxy proxy) throws Throwable &#123; System.out.println("before proxy!"); // 两种方式调用都行 // 第一种 JDK反射机制 method.invoke(target, arg2); // 第二种 这种方法速度更快 Object object = proxy.invokeSuper(arg0, arg2); System.out.println("end proxy!"); return object; &#125;&#125; 123456789101112public static void main(String[] args) &#123; Enhancer enhancer = new Enhancer(); CglibProxy proxy = new CglibProxy(new UserDaoImpl()); enhancer.setCallback(proxy); enhancer.setSuperclass(UserDaoImpl.class); UserDaoImpl userDaoImpl = (UserDaoImpl) enhancer.create(); userDaoImpl.save(); &#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——装饰器模式]]></title>
    <url>%2F2017%2F06%2F13%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰器模式：在不必改变原有类文件和使用继承的情况下，动态的扩展一个对象的功能。他是通过创建一个包装对象也就是装饰来包裹真实的对象。 装饰器模式：在不改变接口的前提下，动态的扩展对象的功能。 代理模式：在不改变接口的前提下，控制对象的访问 下面是装饰器的结构图： 下面通过一个例子来说明装饰器模式的用法： 抽象的person类 1234abstract class Person&#123; //显示人的信息 public abstract void show();&#125; 具体的Man类，继承自person 12345678910111213class Man extends Person&#123; //人的姓名 private String name; public Man(String name) &#123; this.name = name; &#125; @Override public void show() &#123; System.out.println(name + "的装扮"); &#125;&#125; 抽象装饰类 123456789101112131415abstract class Decorator extends Person&#123; //这是装饰器模式的核心 private Person person; public void setPerson(Person person) &#123; this.person = person; &#125; @Override public void show() &#123; this.person.show(); &#125;&#125; 具体的装饰类： 123456789101112131415161718192021222324252627282930//T恤装饰类class TshirtsDecorator extends Decorator&#123; @Override public void show() &#123; super.show(); System.out.println("装扮了T恤!"); &#125;&#125;//鞋子装饰类class ShoesDecorator extends Decorator&#123; @Override public void show() &#123; super.show(); System.out.println("装扮了鞋子!"); &#125;&#125;//裤子装饰类class TouserDecorator extends Decorator&#123; @Override public void show() &#123; super.show(); System.out.println("装扮了裤子!"); &#125;&#125; 测试类： 123456789101112131415161718public class DecoratorDemo&#123; public static void main(String[] args) &#123; Person man = new Man("张三"); //给man装饰上T恤 TshirtsDecorator tperson = new TshirtsDecorator(); tperson.setPerson(man); //给前面的装饰好的man 继续装饰裤子 TouserDecorator touserPerson = new TouserDecorator(); touserPerson.setPerson(tperson); //给前面的装饰好的man 继续装饰鞋子 ShoesDecorator sperson = new ShoesDecorator(); sperson.setPerson(touserPerson); //此时sperson装饰好了T恤、裤子、鞋子，显示全部的装扮 sperson.show(); &#125;&#125; 显示结果： 1234张三的装扮装扮了T恤!装扮了裤子!装扮了鞋子!]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>装饰器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——策略模式]]></title>
    <url>%2F2017%2F06%2F12%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式定义：它定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化不会影响到使用算法的客户 下图是策略模式的结构图： 使用场景： 某商场对不同会员实行不同的优惠策略： 初级会员，对于购买的所有商品全部98折 中级会员，对于购买的所有商品全部8折 高级会员，对于购买的所欲商品全部65折 抽象的折扣类： 1234interface MemberStrategy&#123; double calcPrice(double price);&#125; 初级、中级、高级会员的具体折扣类： 1234567891011121314151617181920212223242526class PrimaryMemberStrategy implements MemberStrategy&#123; public double calcPrice(double price) &#123; System.out.println("初级会员优惠:98折"); return price * 0.98; &#125;&#125;class IntermediateMemberStrategy implements MemberStrategy&#123; public double calcPrice(double price) &#123; System.out.println("中级会员优惠:8折"); return price * 0.8; &#125;&#125;class AdvanceMemberStrategy implements MemberStrategy&#123; public double calcPrice(double price) &#123; System.out.println("高级会员优惠:65折"); return price * 0.65; &#125;&#125; 价格环境类： 123456789101112131415class PriceContext&#123; //持有一个具体的策略对象 private MemberStrategy strategy; public PriceContext(MemberStrategy strategy) &#123; this.strategy = strategy; &#125; //计算对应策略后的价格 public double getMoney(double price) &#123; return strategy.calcPrice(price); &#125;&#125; 客户端测试类： 1234567891011public class StrategyDemo&#123; public static void main(String[] args) &#123; MemberStrategy strategy = new IntermediateMemberStrategy(); PriceContext context = new PriceContext(strategy); double money = 78.6; System.out.print("原价:" + money + " \n"); System.out.printf("会员折扣后优惠:%.2f", context.getMoney(money)); &#125;&#125; 策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。 策略模式的优点 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 策略模式的缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——单例模式]]></title>
    <url>%2F2017%2F06%2F11%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式是指在程序运行过程中，一个单例类只有有一个实例化对象，并且该类自己负责创建类的实例。 单例模式的实现方式有一下几种 饿汉式单例 它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 1234567891011class Singleton1&#123; private Singleton1() &#123; &#125; private static Singleton1 instance = new Singleton1(); public static Singleton1 getInstance() &#123; return instance; &#125;&#125; 非线程安全的 懒汉式单例 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 12345678910111213class Singleton2&#123; private Singleton2() &#123; &#125; private static Singleton2 instance; public static Singleton2 getInstance() &#123; if (instance == null) instance = new Singleton2(); return instance; &#125;&#125; 线程安全的懒汉式单例 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 12345678910111213class Singleton3&#123; private Singleton3() &#123; &#125; private static Singleton3 instance; public synchronized static Singleton3 getInstance() &#123; if (instance == null) instance = new Singleton3(); return instance; &#125;&#125; 双重检验线程安全的 懒汉式单例 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 12345678910111213141516171819class Singleton4&#123; private Singleton4() &#123; &#125; private static Singleton4 instance; public static Singleton4 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton4.class) &#123; if (instance == null) instance = new Singleton4(); &#125; &#125; return instance; &#125;&#125; 静态内部类 单例 1234567891011121314class Singleton5&#123; private static class SingletonHoder &#123; private static Singleton5 INSTANCE = new Singleton5(); &#125; private Singleton5() &#123; &#125; public static Singleton5 getInstance() &#123; return SingletonHoder.INSTANCE; &#125;&#125; 枚举类型单例 12345678enum Singleton6&#123; INSTANCE; public void method() &#123; System.out.println("test"); &#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——抽象工厂模式]]></title>
    <url>%2F2017%2F06%2F11%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[现实生活中一个工厂可能生产多个产品，而工厂方法模式中一个具体的工厂类只负责生产一种产品，随着产品的逐渐增多工厂类也会随之增多，这显然是不合理的。 抽象工厂模式是在工厂方法模式的基础之上增强了工厂类，一个工厂类可以生产多个产品。 抽象工厂模式组成： 抽象工厂：这是工厂方法模式的核心，是具体工厂必须实现的接口或继承的父类。 具体工厂：负责生产具体的产品实例，实现了抽象工厂接口。 抽象产品：具体产品的父类或必须实现的接口，定义了产品必须含有的方法或属性 具体产品类：这是具体工厂创建的实例。 产品类：Button 123456789101112131415161718interface Button&#123; void btnClick();&#125;class WinButton implements Button&#123; public void btnClick() &#123; System.out.println("Windos button clicked!"); &#125;&#125;class LinuxButton implements Button&#123; public void btnClick() &#123; System.out.println("Linux button clicked!"); &#125;&#125; 产品类：Text 123456789101112131415161718interface Text&#123; void textWrite();&#125;class WinText implements Text&#123; public void textWrite() &#123; System.out.println("windows text written!"); &#125;&#125;class LinuxText implements Text&#123; public void textWrite() &#123; System.out.println("Linux text written!"); &#125;&#125; 工厂类： 12345678910111213141516171819202122232425262728interface ComponentFactory&#123; Button createButton(); Text createText();&#125;//window组件制造工厂class WindowsFactory implements ComponentFactory&#123; public Button createButton() &#123; return new WinButton(); &#125; public Text createText() &#123; return new WinText(); &#125;&#125;//Linux组件制造工厂class LinuxFactory implements ComponentFactory&#123; public Button createButton() &#123; return new LinuxButton(); &#125; public Text createText() &#123; return new LinuxText(); &#125; 测试类： 12345678910111213141516public class AbstractFactoryDemo&#123; public static void main(String[] args) &#123; ComponentFactory linuxFactory = new LinuxFactory(); ComponentFactory windowsFactory = new WindowsFactory(); Button winButton = windowsFactory.createButton(); Button linuxButton = linuxFactory.createButton(); winButton.btnClick(); linuxButton.btnClick(); Text winText = windowsFactory.createText(); Text linuxText = linuxFactory.createText(); winText.textWrite(); linuxText.textWrite(); &#125;&#125; 工厂方法模式和抽象工厂模式对比 首先两者都有抽象的工厂类、具体的工厂类、抽象的产品类和具体的产品类 工厂方法模式只有一个产品类，而抽象工厂模式中有多个产品类 工厂方法模式中一个具体的工厂类只能生产一个具体产品类；而在抽象工厂模式中，一个共产类可以生产出多个具体的产品类。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>抽象工程模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——工厂方法模式]]></title>
    <url>%2F2017%2F06%2F11%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂方法模式将简单工厂模式中的工厂类抽取出来，用子工厂具体负责生产具体类产品。这样在产品生产的压力可以由工厂方法模式中的不同工厂子类来分担。 工厂方法模式组成： 抽象工厂：这是工厂方法模式的核心，是具体工厂必须实现的接口或继承的父类。 具体工厂：负责生产具体的产品实例，实现了抽象工厂接口。 抽象产品：具体产品的父类或必须实现的接口，定义了产品必须含有的方法或属性 具体产品类：这是具体工厂创建的实例。 产品类： 1234567891011121314151617181920//产品抽象接口interface Color&#123; void fill();&#125;//产品实例class Green implements Color&#123; //产品方法 public void fill() &#123; System.out.println("fill color Green!"); &#125;&#125;class Red implements Color&#123; public void fill() &#123; System.out.println("fill color Red!"); &#125;&#125; 工厂类： 123456789101112131415161718192021//工厂抽象接口interface ColorFactory&#123; Color createColor();&#125;// 子工厂类，负责生产具体的实例class GreenFactory implements ColorFactory&#123; public Color createColor() &#123; return new Green(); &#125;&#125;class RedFactory implements ColorFactory&#123; public Color createColor() &#123; return new Red(); &#125;&#125; 测试类： 123456789101112public class FactoryMethodDemo&#123; public static void main(String[] args) &#123; ColorFactory gFactory = new GreenFactory(); ColorFactory rFactory = new RedFactory(); Color green = gFactory.createColor(); Color red = rFactory.createColor(); green.fill(); red.fill(); &#125;&#125; 简单工厂模式 vs. 工厂方法模式 简单工厂模式：最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 工厂方法模式：客户端需要决定实例化哪个工厂来实现运算类，选择判断的问题还是存在的。工厂方法吧内部逻辑判断移到了客户端 代码进行，想要增加功能，原先是修改工厂类，现在是修改客户端。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——简单工厂模式]]></title>
    <url>%2F2017%2F06%2F10%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式是最常见的一种设计模式之一，这种类型的设计模式属于创建型模式，提供了一种创建对象的最佳方式 简单工厂模式又称静态工厂方法模式，构建一个创建对象实例的工厂方法，创建对象是不会向用户暴露创建逻辑，通过用户传入的具体参数创建不同的对象。 组成： 抽象产品类：它是具体产品类的父类或者实现接口 具体产品类：工厂类创建的对象就是这些具体的产品类 工厂类：负责具体产品的创建，是这个模式的核心。 具体实例： 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 Hibernate 换数据库只需换方言和驱动就可以。 产品类： 123456789101112131415161718192021//shape接口interface Shape&#123; void draw();&#125;//具体的shape实现类Rectangleclass Rectangle implements Shape&#123; public void draw() &#123; System.out.println(this.getClass().getName() + ": draw method!"); &#125;&#125;//具体的shape实现类Circleclass Circle implements Shape&#123; public void draw() &#123; System.out.println(this.getClass().getName() + ": draw method!"); &#125;&#125; 工厂类： 12345678910111213141516//工厂类class Factory&#123; //工厂类中负责创建shape的工厂方法 public Shape createShap(String tag) &#123; if (tag.equals("Rectangle")) &#123; return new Rectangle(); &#125; else if (tag.equals("Circle")) &#123; return new Circle(); &#125; return null; &#125;&#125; 测试类： 123456789101112public class FactoryDemo&#123; public static void main(String[] args) &#123; Factory factory = new Factory(); //通过工厂方法创建一个shape实例 Rectangle Shape rectangle = factory.createShap("Rectangle"); Shape circle = factory.createShap("Circle"); rectangle.draw(); circle.draw(); &#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm项目中问题]]></title>
    <url>%2F2017%2F06%2F04%2Fjava%2Fssm%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[mybatis 构造SQL语句参数传递mybatis参数传递通过paramType来限定参数类型，具体包括下面几种 基本数据类型 Java实体类、Map 通过注解方式传递多个参数 基本数据类型参数示例123&lt;select id="selectTeacher" parameterType="int" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#&#123;id&#125; &lt;/select&gt; 1List&lt;Teacher&gt; tList = teacherMapper.selectTeacher(2); Java实体类型参数示例123&lt;select id="selectTeacher" parameterType="com.myapp.domain.Teacher" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#&#123;id&#125; &lt;/select&gt; 123Teacher queryTeacher=new Teacher(); queryTeacher.setId(2); List&lt;Teacher&gt; tList = teacherMapper.selectTeacher(queryTeacher); Map参数示例123&lt;select id="selectTeacher" parameterType="map" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#&#123;id&#125; and sex=#&#123;sex&#125; &lt;/select&gt; 1234Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;(); map.put("id","2"); map.put("sex","男"); List&lt;Teacher&gt; tList = teacherMapper.selectTeacher(map); 通过注解方式传递多个参数接口方法 1public List&lt;Teacher&gt; selectTeacher(@Param(value="id") String id,@Param(value="sex") String sex); 123&lt;select id="selectTeacher" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#&#123;id&#125; and sex=#&#123;sex&#125; &lt;/select&gt; 1List&lt;Teacher&gt; tList = teacherMapper.selectTeacher("2","男"); springMVC中日期参数传递日期参数在springMVC中无法直接转换，需要添加额外的转换器。 首先controller中添加一个@initBiner方法 1234567891011public class GoodsAction extends BaseAction&#123; @InitBinder protected void initBinder(WebDataBinder binder) &#123; SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); dateFormat.setLenient(false); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false)); &#125; ……&#125; mybatis中日期插入1234567&lt;insert id="insertItem" parameterType="TimeLimitPurchase"&gt; insert into t_time_limit_purchase (goods_id,begin_time,end_time) values (#&#123;goods.goodsId,jdbcType=INTEGER&#125;, #&#123;beginTime,jdbcType=TIMESTAMP&#125;,#&#123;endTime,jdbcType=TIMESTAMP&#125;)&lt;/insert&gt;]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解Annotation]]></title>
    <url>%2F2017%2F05%2F21%2Fjava%2FJava-%E6%B3%A8%E8%A7%A3Annotation%2F</url>
    <content type="text"><![CDATA[从JDK5开始，Java增加了Annotation(注解)，Annotation是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。 注解作用 生成文档。这是最常见的，也是Java 最早提供的注解。常用的有@see @param @return 等 跟踪代码依赖性，实现代替配置文件的功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量。 在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。 注解Annotation定义定义新的注解类型时使用@interface，与接口定义很相似只是多了一个@符号 123public @interface FirstAnnotation&#123;&#125; 定义完Annotation之后就可以在程序中使用该Annotation。Annotation一般放在所有修饰符之前，并且单独一行 1234@FirstAnnotationpublic class Test&#123;&#125; Annotation成员变量​ Annotation只有成员变量，没有方法。Annotation的成员变量在Annotation定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 12345public @interface FirstAnnotation&#123; public String name(); public int age();&#125; ​ 一旦在Annotation中定义了成员变量之后，使用该Annotation时就应该为该Annotation的成员变量指定值。 1234@FirstAnnotation(name = "李四", age = 16)public class Test&#123;&#125; ​ Annotation定义成员变量时可以指定默认值，指定默认值之后。使用Annotation时，已经指定默认值得变量若没有指定值，则会直接使用默认值。 12345public @interface FirstAnnotation&#123; public String name() default "张三"; public int age();&#125; ​ 使用含有默认值的Annotation，如上面name指定了默认值，使用的时候就可以不再对其赋值；而age没有指定默认值，使用时必须对其赋值。 1234@FirstAnnotation(age = 16)public class Test&#123;&#125; 根据Annotation是否包含成员变量，可以把Annotation分为如下两类： 标记Annotation：没有成员变量的Annotation被称为标记。这种Annotation仅用自身的存在与否来为我们提供信息，例如@override等。 元数据Annotation：包含成员变量的Annotation。因为它们可以接受更多的元数据，因此被称为元数据Annotation。 元注解在定义Annotation时，也可以使用JDK提供的元注解来修饰Annotation定义。JDK提供了如下4个元注解（注解的注解，不是上述的”元数据Annotation“）： @Retention @Target @Documented @Inherited @Retention@Retention用于指定Annotation可以保留多长时间。 @Retention包含一个名为“value”的成员变量，该value成员变量是RetentionPolicy枚举类型。使用@Retention时，必须为其value指定值。 RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器编译时，直接丢弃这种Annotation。 RetentionPolicy.CLASS：编译器把Annotation记录在class文件中。当运行Java程序时，JVM中不再保留该Annotation。 RetentionPolicy.RUNTIME：编译器把Annotation记录在class文件中。当运行Java程序时，JVM会保留该Annotation，程序可以通过反射获取该Annotation的信息。 1234@Retention(RetentionPolicy.RUNTIME)public @interface FirstAnnotation&#123;&#125; @Target@Target指定Annotation用于修饰哪些程序元素。@Target也包含一个名为”value“的成员变量，该value成员变量类型为ElementType[ ]，ElementType为枚举类型，值有如下几个： ElementType.TYPE：能修饰类、接口或枚举类型 ElementType.FIELD：能修饰成员变量 ElementType.METHOD：能修饰方法 ElementType.PARAMETER：能修饰参数 ElementType.CONSTRUCTOR：能修饰构造器 ElementType.LOCAL_VARIABLE：能修饰局部变量 ElementType.ANNOTATION_TYPE：能修饰注解 ElementType.PACKAGE：能修饰包 @Documented如果定义注解A时，使用了@Documented修饰定义，则在用javadoc命令生成API文档后，所有使用注解A修饰的程序元素，将会包含注解A的说明。 @Inherited@Inherited指定Annotation具有继承性。 1234567891011121314package com.demo2;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface MyTag&#123;&#125; 123456package com.demo2;@MyTagpublic class Base &#123;&#125; 123456789package com.demo2;//SubClass只是继承了Base类//并未直接使用@MyTag注解修饰public class SubClass extends Base &#123; public static void main(String[] args) &#123; System.out.println(SubClass.class.isAnnotationPresent(MyTag.class)); &#125;&#125; 示例中Base使用@MyTag修饰，SubClass继承Base，而且没有直接使用@MyTag修饰，但是因为MyTag定义时，使用了@Inherited修饰，具有了继承性，所以运行结果为true。 如果MyTag注解没有被@Inherited修饰，则运行结果为：false。 基本AnnotationJDK默认提供了如下几个基本Annotation： @Override 限定重写父类方法。对于子类中被@Override 修饰的方法，如果存在对应的被重写的父类方法，则正确；如果不存在，则报错。@Override 只能作用于方法，不能作用于其他程序元素。 @Deprecated 用于表示某个程序元素（类、方法等）已过时。如果使用被@Deprecated修饰的类或方法等，编译器会发出警告。 @SuppressWarning 抑制编译器警告。指示被@SuppressWarning修饰的程序元素（以及该程序元素中的所有子元素，例如类以及该类中的方法…..）取消显示指定的编译器警告。例如，常见的@SuppressWarning（value=”unchecked”） @SafeVarargs @SafeVarargs是JDK 7 专门为抑制“堆污染”警告提供的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 强软弱虚引用]]></title>
    <url>%2F2017%2F05%2F21%2Fjava%2FJava-%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[强引用： 只要引用存在，垃圾回收器永远不会回收，JVM宁愿报OutOfMemoryError错误 12Object obj = new Object();//可直接通过obj取得对应的对象 如obj.equels(new Object()); 而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。 软引用： 非必须引用，内存溢出之前进行回收，可以通过以下代码实现 1234Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;sf.get();//有时候会返回null 这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。 弱引用： 弱引用生命周期是比软引用还更短的引用。只有弱引用的对象一旦被JVM垃圾回收器发现，便会被回收 12345Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;wf.get();//有时候会返回nullwf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾 在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。 虚引用： 垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现 12345Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj=null;pf.get();//永远返回nullpf.isEnQueued();//返回是否从内存中已经删除 “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。 参考地址：http://www.cnblogs.com/yw-ah/p/5830458.html]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的基本原则]]></title>
    <url>%2F2017%2F05%2F20%2Fjava%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[面向对象的六大基本原则 单一责任原则 其核心思想是：一个类最好只做一件事，专注于做一件事 开放封闭原则 其核心思想是：软件实体应该是可以扩展的而不可修改的，也就是对扩展开放，对修改封闭的 依赖倒置原则 其核心思想是：依赖于抽象，具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象； 抽象不依赖于具体，具体依赖于抽象 接口隔离原则 其核心思想是：使用多个小的专门的接口，而不要私用一个大的总接口 李氏替换原则 其核心思想是：子类必须能够替换其基类， 组合聚合复用原则 其核心思想是：优先使用组合或者聚合复用代码 ​]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock lock、unlock源码解读]]></title>
    <url>%2F2017%2F05%2F19%2Fjava%2FReentrantLock%20lock%E3%80%81unlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[ReentrantLock 对于公平锁和非公平锁的加锁过程不同。对于公平锁加锁，如果前面没有比当前线程等候更久的线程的话，则当前线程直接获得锁，否则直接将当前线程插入等候队列中；对于非公平锁的加锁和前面不一样，如果前一个线程刚好结束state=0，此时无论当前线程前面是否有线程等候，当前线程都能直接抢占锁。如果前一个线程还没执行完毕，则当前线程便插入等候队列中。 等候队列ReentrantLock实现是基于AbstractQueuedSynchronizer(AQS)，AQS实现是通过一个等候队列和CAS(Compare and swap)原子操作实现的。等候队列其实一个双向链表，链表中的每个元素都是一个Node结点。 Node中的每个变量都用volatile修饰保证内存的可见性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static final class Node &#123; /** Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null; /** waitStatus value to indicate thread has cancelled */ static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; //前一个结点 volatile Node prev; //下一个结点 volatile Node next; //结点中存放的线程 volatile Thread thread; Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; //获取当前结点的上一个结点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; 公平锁lock ReentrantLocak中的lock方法 123public void lock() &#123; sync.lock(); &#125; FairSync 中的lock 123final void lock() &#123; //尝试获取锁 acquire(1); &#125; AbstractQueuedSynchronizer中获取锁 12345678public final void acquire(int arg) &#123; //先判断能不能获取到锁，能获取到锁的话直接就结束了 if (!tryAcquire(arg) &amp;&amp; //如果上面不能获取到锁的话，就将当前线程插入等候队列中 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //阻塞当前线程 selfInterrupt(); &#125; FairSync 覆盖了AbstractQueuedSynchronizer中的tryAcquire方法 1234567891011121314151617181920212223242526protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //state==0 当前没有线程占用锁 if (c == 0) &#123; //如果队列中没有比当前线程等候时间更长的线程 if (!hasQueuedPredecessors() &amp;&amp; //修改锁的状态，表示锁被当前线程占用 compareAndSetState(0, acquires)) &#123; //设置当前线程是占用锁的线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果占用锁的线程就是当前线程 else if (current == getExclusiveOwnerThread()) &#123; //直接将state 加1 int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; //上面的情况都不满足，返回false，表示线程没有获取到锁 return false; &#125; 获取不到锁的话，直接插入等候队列的队尾 12345678910111213141516private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; //队尾元素不为空，插入队尾 node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //tail 为空，插入队列头 enq(node); return node; &#125; 未完……]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>lock</tag>
        <tag>unlock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal]]></title>
    <url>%2F2017%2F05%2F19%2Fjava%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal 为每个线程提供一个变量的独立副本，每个线程对ThreadLocal变量的修改不会相互影响。这并不是解决了线程安全问题，它只是给每个线程提供一个获取存放变量的一个key ThreadLocal类中定义了一个内部数据结构ThreadLoalMap，ThreadLocalMap是用来存放每个线程的ThreadLocal变量值Value。但是ThreadLocal中并没有定义ThreadLocalMap变量，ThreadLocalMap是在线程中定义的，用来存放每个线程中的多个ThreadLocal所对应的Value值。下面是Thread类中定义的ThreadLocalMap成员变量 1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocaMap是一个Entry数组，Entry中包含key和Value，其中key就是threadLocal，并且key是弱引用的。Entry结构定义如下 123456789static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125; &#125; ​ 如上图是其中一个Thread中的ThreadLocalMap数据结构的示意图，其中key是ThreadLocal，Value是ThreadLocal变量在其中一个线程的值。 ​ 因为每个线程中都有这么一个ThreadLocalMap，所以当线程对ThreadLocal变量进行修改时，其实就是对Thread本身的ThreadLocalMap进行修改 ThreadLocal中的方法 set() 1234567891011public void set(T value) &#123; //获取当前线程 Thread t = Thread.currentThread(); //获取当前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); //如果Map不存在则创建 if (map != null) map.set(this, value); else createMap(t, value); &#125; getMap(t)是获取Thread中的ThreadLocalMap变量 1234ThreadLocalMap getMap(Thread t) &#123; //返回线程中的ThreadLocalMap变量 return t.threadLocals; &#125; createMap是给Thread创建一个ThreadLocalMap，并将值放入Map中 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; get() 123456789101112public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; //通过key ThreadLocal找到Map中的对应的Entry ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) //返回Entry中的值 return (T)e.value; &#125; return setInitialValue(); &#125; getEntry()查找方法和HashMap中查找有点类似，都是通过HashCode 来定位。但是两者计算hash值得方法不同，而且如果并命中的话接下来的查找过程也不同。 123456789private Entry getEntry(ThreadLocal key) &#123; //通过threadLocalHashCode计算在其在数组中的位置 int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else //如果对应的位置上不是要找的值，则会进行下一步操作 return getEntryAfterMiss(key, i, e); &#125; 如果计算的index不命中的话，会往下一直查找 1234567891011121314151617private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else // i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; nextIndex()会让下标值加1，如果大于len则变成0 123private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; ThreadLocal使用 123456789101112131415161718192021222324252627282930public class Test&#123; public static void main(String[] args) &#123; ThreadLocal&lt;Integer&gt; num = new ThreadLocal&lt;&gt;(); num.set(1); new Thread(new MyRunnable(num, 5)).start(); new Thread(new MyRunnable(num, 8)).start(); System.out.println(Thread.currentThread().getName() + " " + num.get()); &#125;&#125;class MyRunnable implements Runnable&#123; ThreadLocal&lt;Integer&gt; num; private int value; public MyRunnable(ThreadLocal&lt;Integer&gt; num, int value) &#123; this.num = num; this.value = value; &#125; @Override public void run() &#123; num.set(value); System.out.println(Thread.currentThread().getName() + " " + num.get()); &#125;&#125; 输出： 123main 1Thread-1 8Thread-0 5]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>threadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock简介]]></title>
    <url>%2F2017%2F05%2F18%2Fjava%2FReentrantLock%2F</url>
    <content type="text"><![CDATA[ReentrantLock是一个可重入的互斥锁定 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。ReentrantLock 将由最近成功获得锁定，并且还没有释放该锁定的线程所拥有。当锁定没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁定并返回。如果当前线程已经拥有该锁定，此方法将立即返回。可以使用 isHeldByCurrentThread() 和 getHoldCount() 方法来检查此情况是否发生。 重入锁： 如果当前占有锁的线程是Thread1，则当Tread1再次到来的时候不要要排队，直接将state加1，即运行次数加1。 ReentrantLock实现了Lock接口，提供了完整的Lock功能。它的一个内部类Sync类继承了AbstractQueuedSynchronizer（AQS）实现锁的功能，但是Sync并不提供公平和非公平锁机制，因此在Sync的基础之上，ReentrantLock内部又提供了两个内部类NonfairSync非公平锁、和FairSync公平锁，这两个类都是继承自Sync。 公平锁和非公平锁的区别： 公平锁：线程按照他们发出信号的先后来获取锁，采用先来先服务的原则。新来的线程直接放入等候队列中。 非公平锁：支持抢占方式，新来的线程首先会检查锁是否占用，如果被占用直接插入等候队列中，如果上一个线程刚好结束state=0时，系统会直接调用这个新来的线程执行，而不会去等候队列中唤醒阻塞的线程。这样做的好处是可以提高系统的吞吐量，因为从阻塞队列总唤醒线程需要耗费时间。 SyncSync继承自AbstractQueuedSynchronizer， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; //加锁功能 abstract void lock(); //非公平锁尝试获取锁 final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //如果没有锁定，则直接加上锁 if (c == 0) &#123; //直接 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //如果拥有资源的线程 和当前线程相同则state加1 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; //否则返回false return false; &#125; //尝试释放锁 protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; protected final boolean isHeldExclusively() &#123; return getExclusiveOwnerThread() == Thread.currentThread(); &#125; final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; //返回正在占用资源的线程 final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; //资源是否已经被占用(已经在锁) final boolean isLocked() &#123; return getState() != 0; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; NonfairSync非公平锁123456789101112131415161718static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; //加锁 final void lock() &#123; //比较并更改锁的状态，如果当前state是0，则将state修改成1，并将获取锁的线程设置成当前线程 //如果上一个线程刚好结束state=0，这时线程过来就直接获取锁，而排队等待中的线程需要继续等待， //这样可以提高系统的效率，因为要从阻塞队列中唤醒线程需要耗费时间 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else // 如果state！=0，即已经被占用，则调用获取锁的方法，acquire是AQS的方法 acquire(1); &#125; //尝试获取锁 protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125; &#125; FairSync公平锁123456789101112131415161718192021222324252627282930static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; //公平锁加锁，直接放入等候队里中 final void lock() &#123; acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //hasQueuedPredecessors ：查询是否还有线程比当前线程等候的时间更长， //即前面队列中是否还有等候吧的线程,如果没有则当前线程获取锁 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; //设置当前线程为获取资源的线程 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; &#125; ReentrantLock构造方法ReentrantLock默认是创建非公平锁 123public ReentrantLock() &#123; sync = new NonfairSync(); &#125; 可以通过参数创建公平锁，参数为true时创建公平锁，参数false时创建非公平锁 123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; ReentrantLock方法 加锁，如果已被占用则加入等候队列中 123public void lock() &#123; sync.lock();&#125; 尝试获取锁，如果获取不到就直接返回 123public boolean tryLock() &#123; return sync.nonfairTryAcquire(1); &#125; 尝试去获取锁，如果在timeout这段时间内没有获取到就直接返回 1234public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; 释放锁 123public void unlock() &#123; sync.release(1); &#125; 返回当前线程占有的数量即state值 123public int getHoldCount() &#123; return sync.getHoldCount(); &#125; 判断占有锁的线程是否是当前线程 123public boolean isHeldByCurrentThread() &#123; return sync.isHeldExclusively(); &#125; 判断资源是否加锁 123public boolean isLocked() &#123; return sync.isLocked(); &#125; 判断是否是公平锁 123public final boolean isFair() &#123; return sync instanceof FairSync; &#125; 返回占有该锁的线程 123protected Thread getOwner() &#123; return sync.getOwner(); &#125; 判断等候队列中是否还有线程 123public final boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; 判断该线程是否在等候队列中 123public final boolean hasQueuedThread(Thread thread) &#123; return sync.isQueued(thread); &#125; 返回等候队列的长度 123public final int getQueueLength() &#123; return sync.getQueueLength(); &#125; 返回所有的等候线程 123protected Collection&lt;Thread&gt; getQueuedThreads() &#123; return sync.getQueuedThreads(); &#125; ReentrantLock使用 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.locks.ReentrantLock;public class Test&#123; private static int num = 0; static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) new Thread(new MyRunnable()).start(); &#125; public static void lockBlock() &#123; try &#123; lock.lock(); for (int i = 0; i &lt; 3; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;class MyRunnable implements Runnable&#123; @Override public void run() &#123; Test.lockBlock(); &#125;&#125;]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>lock</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized]]></title>
    <url>%2F2017%2F05%2F17%2Fjava%2FSynchronized%2F</url>
    <content type="text"><![CDATA[Synchronized 是Java中的一种锁，主要用来给方法和代码块加锁。当某个方法或者代码块使用synchronized关键字时，那么同一时刻最多只能有一个线程执行该代码段。当多个线程同时访问时，只有一个线程执行，其他线程处于阻塞状态，当线程执行完毕后其他线程才能执行。 synchronized 是Java虚拟机底层实现的锁机制，当synchronized方法或者代码块中发生异常时，会系统会自动释放锁定资源。 Synchronized主要有两种用法，一种是synchronized方法，另一种是synchronized代码块 Synchronized方法类的成员方法在类的成员方法声明中加上Synchronized关键字，其锁定的是类的实例对象 1public synchronized void getNum()&#123;&#125; synchronized加在类的成员方法中，本质上锁定是this对象，它和下面的写法是等价的： 12345public void getNum()&#123; synchronized(this)&#123; …… &#125;&#125; 代码访问的同步性 当多个线程同时访问同一个synchronized方法时，一次只能一个线程执行 当多个线程同时访问类中不同的Synchronized方法时，一次也只能一个线程执行，其他线程阻塞 123public synchronized void getNum()&#123;&#125;public synchronized void getNum1()&#123;&#125; 即当两个线程同时一个调用getNum，另一个调用getNum1()，同一时间只能一个线程运行 当两个线程一个调用Synchronized方法，另一个线程调用普通方法，则两个线程可以同时进行，不会相互影响 类的静态方法static在类的静态方法中加上Synchronized关键字，其锁定的是class类对象 1public static synchronized void getNum()&#123;&#125; 其效果等同于下面的写法 12345public static void getNum()&#123; //我们假设这个静态方法在Main这个类中声明 synchronized(Main.class)&#123; …… &#125;&#125; 代码访问的同步性1234567public class Main&#123; public void method()&#123;&#125;; public synchronized void method1()&#123;&#125;; //锁定的是this public synchronized void method2()&#123;&#125;; public synchronized static void method3()&#123;&#125;; //锁定的是class public synchronized static void method4()&#123;&#125;;&#125; method() 和 method1() 能同时访问 method()和method3()能同时访问 method1()和method2()不能同时访问 method3()和method4()不能同时访问 method1()和method3()可以同时访问 Synchronized代码块Synchronized代码块把需要同步的代码加上锁，将那些对线程安全没有影响的代码移出Synchronized代码块，具体写法如下 12345678public void getNum()&#123; …… synchronized(obj) &#123; …… 线程同步代码块 &#125;&#125; 代码块中添加Synchronized可以减小锁的粒度，提高程序并发的效率。 线程访问的同步性 若多个线程同时访问一个Synchronized代码块，则一次只能有一个线程能够访问 若多个代码Synchronized代码块锁定的对象是同一obj，则当多个线程同时访问这些代码块时，一次只能有一个线程能够访问这些代码块。 测试用例用例1：多个线程同时访问一个Synchronized代码块 1234567891011121314151617181920212223242526public class Test implements Runnable&#123; private static Integer num = 0; private Object obj = new Object(); @Override public void run() &#123; getNum(); &#125; public static void main(String[] args) &#123; Test test = new Test(); for (int i = 0; i &lt; 3; i++) new Thread(test, "Thread_1_" + i).start(); &#125; public void getNum() &#123; synchronized (obj) &#123; for (int i = 0; i &lt; 5; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); &#125; &#125;&#125; 测试结果：一次只能一个线程可以运行 12345678Thread_1_0 0Thread_1_0 1Thread_1_2 2Thread_1_2 3Thread_1_1 4Thread_1_1 5 测试用例2：多个线程同时访问多个Synchronized代码块，且这些代码块的锁定对象相同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Test implements Runnable&#123; private static Integer num = 0; private Object obj = new Object(); @Override public void run() &#123; getNum(); &#125; private class MyRunnable implements Runnable &#123; @Override public void run() &#123; getNum1(); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); for (int i = 0; i &lt; 3; i++) new Thread(test, "Thread_1_" + i).start(); Runnable myRunnable = test.new MyRunnable(); for (int i = 0; i &lt; 3; i++) &#123; new Thread(myRunnable, "Thread_2_" + i).start(); &#125; &#125; public void getNum() &#123; synchronized (obj) &#123; for (int i = 0; i &lt; 2; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); &#125; &#125; public void getNum1() &#123; synchronized (obj) &#123; for (int i = 0; i &lt; 2; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); &#125; &#125;&#125; 测试结果：每次只能有一个线程可以访问Synchronized代码块 1234567891011121314151617Thread_1_0 0Thread_1_0 1Thread_1_2 2Thread_1_2 3Thread_1_1 4Thread_1_1 5Thread_2_0 6Thread_2_0 7Thread_2_1 8Thread_2_1 9Thread_2_2 10Thread_2_2 11]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 线程池]]></title>
    <url>%2F2017%2F05%2F14%2Fjava%2FJava%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[当处理大并发请求时，由于创建线程比较耗时，故引入线程池。线程池是存放线程的容器，用户请求到来前可以提前创建好线程，请求到来时便可以直接执行任务。 线程池示意图： 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; corePoolSize：线程池中保留的线程数（包括空线程），注意线程池中的线程数并不是一创建达到corePoolSize，而是在请求到达时逐步创建，最后数目达到corePoolSize。请求任务执行完毕后，若线程数&lt;corePoolSize，则会保持当前数目。 maximumPoolSize：线程池中可以容纳的最大线程数 keepAliveTime：当线程数据超过corePoolSize时，且线程任务执行完毕后，过keepAliveTime后剩余的线程将会注销 TimeUnit：keepAliveTime的时间单位 workQueue：阻塞队列(缓冲队列)，线程池中线程数目达到达到corePoolSize后，新来的任务请求会放到缓冲队列中，采用的是FIFO模式 常用的是：java.util.concurrent.ArrayBlockingQueue LinkedBlockingQueue SynchronousQueue ThreadFactory：制造线程的工厂 handler：饱和策略，当线程池中线程达到maximumPoolSize，且缓冲队列也满了之后，对新来的请求采取的策略。 请求任务执行策略 当请求任务数小于corePoolSize时，直接在线程池创建线程，并将任务放入线程中执行 当请求任务数大于corePoolSize，并且剩余的请求数小于阻塞队列长度时，将任务放入阻塞队列 若maximumPoolSize大于corePoolsize，当阻塞队列满了后还有请求任务到来，则在线程池中创建新的线程执行。 若线程池中的线程数等于maximum，且阻塞队列也满了还有任务到来，则用线程饱和策略处理。 线程池饱和策略当线程池中的缓冲队列满了，同时线程池中线程数量也达到了maximum，这时候如何还有请求过来，就会采用RejectedExecutionHandler饱和策略来应对。具体饱和策略包括下面几种： AbortPolicy：终止策略，抛出RejectedExecutionException异常，同时处理完线程池和缓冲队列中的请求 DiscardPolicy：抛弃策略，抛弃新来的请求，其他一切照常 DiscardOldestPolicy:抛弃旧任务策略，将队列头元素删除，然后将新来的请求放入队尾 CallerRunsPolicy：调用者运行策略，既不抛弃任务也不抛出异常，直接运行任务的run方法，即将任务退回给调用线程池的线程直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。 创建线程池的其他方法通过Executors类中的静态方法创建ExecutorSevice Executors.newFixedThreadPool(); Executors.newSingleThreadExecutor(); Executors.newCachedThreadPool(); Executors.newScheduledThreadPool();]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合-Set介绍]]></title>
    <url>%2F2017%2F05%2F14%2Fjava%2Fjava%E9%9B%86%E5%90%88-Set%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前面介绍了一些关于List、Map的相关知识，下面我们继续来看下集合中的set。set作为容器主要存储不重复的元素。 HashSet HashSet底层实现是通过HashMap实现的，set中每个元素对应Map中的每个EntrySet结点。存储元素时只用Map的key值存储，value值统一设置为同一个new Object()。 HashSet底层存储数据的是map，所以Hashset允许null存在 HashSet存放的元素各不相同，当掉用add方法添加已存在的元素时会返回false. TreeSet TreeSet底层是通过TreeMap实现。存储元素只使用TreeMap中的key，Value同一设成相同的new Object(); TreeSet不允许插入null值 ​TreeSet元素是有序的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>HashSet</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识点]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[因特网组成（一）边缘部分 客户-服务器方式 对等连接方式（P2P）:两个主机通信时不区分哪个是服务请求方还是服务提供方。 （二）核心部分 路由器：实现分组交换的关键构建，其任务是转发收到的分组。 电路交换：建立连接（占用通信资源）——&gt;通话（占用通信资源）——&gt;释放链接（归还通信资源） 分组交换：采用存储转发方式，把数据报文划分成等长的数据，每组数据前加上必要的控制信息组成的包头构成一组报文。单个分组传送到相邻结点，存储下来后查找转发表。转发到下一个结点。 报文交换：整个报文先传到相邻的结点，全部信息存储下来后查找转发表，转发到下一个结点。 计算机网络的分类（一）按网络的作用范围划分 广域网 城域网 局域网 （二）按使用者划分 公用网 专用网 ###计算机网络体系结构 ​ 应用层 表示层 应用层 应用层 回话层 运输层 运输层 运输层 网络层 网际层IP 网络层 数据链路层 网络接口层 数据链路层 物理层 物理层 OSI七层协议 TCP/IP四层协议 五层协议 物理层信道与电路信道一般表示某一个方向传送信息的媒体，而一条通信线路往往包含一条发送信道和一条接收信道。 通信的三种基本方式 单线通信（单工通信）：只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）：双方都可以发送信息，但不能双方同时发送（也不能同时接收）。 双向同时通信（全双工通信）：双方可以同时发送和接收消息。 信道复用技术 频分复用：频分复用的所有用户在同样的时间占用不同的带宽资源 时分复用：时分复用的所用用户是在不同的时间占用同样的频带宽度 数据链路层三个基本问题 封装成帧：在一段数据的前后分别添加首部和尾部构成数据帧。首部加SOH尾部加EOT 透明传输：表示无论什么样的比特组合的数据都能通过这个数据链路层。如果数据中出现SOH和EOT就在前面加上转义字符“ESC”，如果数据中出现转义字符，就再前面再加一个转义字符。接收端看到有转义字符就将前面的转义字符删掉。 差错检测：传输过程中容易发生错误，需要对数据进行检验。数据链路层广泛使用循环冗余检验（CRC） 循环冗余检验（CRC cyclic redundancy check） 数据M*2^n,即在数据M后面加上n个0。列如11001101，假设n=3 —》 11001101000。 对做乘法后的数据M除以事先商量的除数。除数长度是n+1.除数p(X)叫做生成多项式。常用的生成多项式有如下： CRC8=X^8+X^5+X^4+X^0 CRC-CCITT=X^16+X^12+X^5+X^0 CRC16=X^16+X^15+X^2+X^0 CRC12=X^12+X^11+X^3+X^2+X^0 CRC32=X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0 如果数据M=10101001，多项式选用CRC8，则除数p=110001。除数选定之后长度是6位，所以n=6-1=5,即数据M后面加上5个0。 用数据M除以P，除的过程中采用模2运算。模2运算中的加减法都不考虑借位和进位列如：1111+1010=0101. 得到的余数R就作为冗余码拼接到数据M的后面发送出去。这种为了检错而添加的冗余码称为帧检验序列(FCS) 12345678910111213141516171819202122232425262728 10001110 ----------------------110001) 1100110100000 110001 ------------ 000100 000000 ------------ 001001 000000 ------------ 010010 000000 ------------ 100100 110001 ------------ 101010 110001 ------------ 110110 110001 -------------- 001110 000000 -------------- 01110 &lt;---R(余数)，作为FCS 循环冗余检验（CRC）和帧检验序列（FCS）的区别CRC是一种检错方法，FCS是添加在数据后面的冗余码 数据链路层如果仅采用循环冗余检验CRC差错检验技术的话，可以这么认为凡是接收端在数据链路层接收到的数据帧均无差错。 点对点协议（PPP）透明传输问题 异步传输 将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E) 若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D) 若信息字段中出现 ASCII 码的控制字符(0x0a，即数值小于 0x20 的字符)，则将其转变成为 2 字节序列(0x7D, 0x2a)，如0x03 变为 (0x7D, 0x23) 同步传输 发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除 使用广播信道的数据链路层CSMA/CD（载波监听多点接入/碰撞检测） 多点接入：表示许多计算机以多点接入的方式连接在一根总线上 载波监听：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 碰撞检测：计算机边发送数据边检测信道上的信号电压大小 争用期​ 以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。经过争用期还没检测到碰撞，才能肯定这次发送不会发生碰撞 二进制指数类型退避算法 基本退避时间，2τ 重传所需时延从{0，1，……，2^k^ -1}中选择。其中k=min{重传次数，10}，当重传次数大于10的时候，k=10; 当重传次数达到16次仍然不能成功时，应丢弃该帧。 例如重传次数=3，{0，1，2，3，4，5，6，7} 从这些数字中选择一个。 争用期长度 以太网取51.2 μs 为争用期的长度 对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节 以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突 最短有效帧长以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧 强化碰撞当发送数据的站一旦发生碰撞，立即停止发送数据，再继续发送若干比特的人为干扰信号，强化碰撞 网络层（网际层IP）地址解析协议（ARP）、网际控制报文协议（ICMP）、网际组管理协议（IGMP） IP地址的分类A类地址：以0开头，第一个字节范围：0~127；网络号8位，主机号24位 子网掩码255.0.0.0 B类地址：以10开头，第一个字节范围：128~191；网络号16位，主机号16位 子网掩码255.255.0.0 C类地址：以110开头，第一个字节范围：192~223；网络号24位，主机号8位 子网掩码255.255.255.0 D类地址：以1110开头，第一个字节范围为224~239；多播地址 无分类编址192.168.34.256/16:表示前16位是网络前缀，后面16位是主机号。/后面表示网络前缀占的位数 IP={《网络前缀》,《主机号》} 子网掩码1的个数与网络前缀的个数相同。 IP数据报的格式 一个IP数据报有首部和数据两部分组成 首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 版本号4位，指IP协议的版本，目前是4（ipv4） 首部长度4位，可表示的最大值是15，1个单位是4字节，因此首部最长可以是60字节 区分服务8位，一般不使用 总长度16位，值首部和数据的总长度，单位字节。最大长度是65535，但是不能超过最大传送单元MTU 标识16位，用来产生数据报的标识 标志3位，第一位没用；第二位DF，DF=0时才允许有分片；第三位MF，MF=1后面有分片，MF=0后面没有分片 片偏移12位，该片在原数据段中的位置，以8字节为单位。 生存时间8位，数据报在网络中可通过的路由器数 地址解析协议（ARP）已知一个机器的IP地址，需要寻找其相应的硬件地址(Mac地址)。 ARP高速缓存：每一个主机都设有一个ARP高速缓存，里面存放了本局域网上的各个主机和路由器的IP地址到硬件地址的映射表。 注意：ARP是解决同一个局域网上的主机或路由的IP地址和硬件地址的映射问题。 子网划分IP地址原先分为网络号和主机号 子网划分就是将主机号划分为子网号和主机号。 IP地址={《网络号》,《子网号》,《主机号》}； 子网掩码作用：把子网掩码和IP地址做与(AND)运算就得出该IP的网络地址。网络地址就是该设备所在网络中的唯一确定地址。 例题：已知IP地址是141.14.72.24，子网掩码是255.255.192.0，求网络地址 12345141.1 4.01001000.24255.255.11000000.0------------------- 与运算141.1 4.01000000.24 --&gt;141.14.64.0(网络地址)这个IP是B类地址，网络号16位、子网号2位、主机号14位。 无分类编址CIDRIP地址={&lt;网络前缀&gt;，&lt;主机号&gt;} CIDR还使用斜线记法，在IP地址后面加上“/”，同时后面接上网络前缀的所占位数。 128.14.12.0/20—— 表示的地址块有2^12^个地址，斜线后面的20表示网络前缀的位数。 因特网路由选择协议内部网关协议RIP内部网关协议OSPFOSPF（open shortest path first）:开放最短路径优先 运输层用户数据报协议UDPTCP传输控制协议建立连接： 释放连接： linux下侦测主机到目的主机之前所经过的路由的命令。 traceroute ：命令用来探测路由经过.. ping ：命令用来检测两部主机之间的传输信道是否畅通，或远程主机是否正常.. route：命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录来进行相应的添加、删除或修改等操作。 ifconfig：命令用来来检测和设置本机的网络接口。 TCP和UDP的区别和应用场景 TCP UDP 连接性 面向连接的 无连接的 可靠性 可靠的 不可靠 报文 面向字节流 面向报文（保留报文边界） 效率 低 高 双工性 全双工 一对一、一对多、多对一、多对多 流量控制 有（滑动窗口） 无 拥塞控制 有（慢开始、拥塞避免、快重传、快恢复） 无 传输速度 慢 快 应用场合 对效率要求相对低的，但对准确性要求相对高；或者是要有连接的场景 对效率要求相对高，对准确性要求相对低的场景 应用示例 TCP一般用于文件传输（FTP、http对数据准确性要求高，速度可以相对慢）；发送接收邮件（pop，SMTP,IMAP 对数据准确性要求高，非紧急应用）；远程登录（Telnet，SSH 有连接）等等 UDP一般用于即时通信（QQ，对数据准确性和丢包要求比较低，但速度必须快）；在线视频（速度一定要快，保证视频的连续性，但是偶尔花了一个图像帧用户还是能接受的）；网络电话等]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http和https的区别]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Fhttp%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[http协议是未加密的传输，即采用明文的方式发送内容，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就很容易直接读取其中的信息。https就是在http的基础之上加入了SSL协议，SSL用于对http协议传输的数据进行加密。 https协议需要到ca申请证书，一般需要一定的费用 http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密协议 http和HTTPS使用不同的连接方式，用的端口也不同，前者是80端口，后者是443端口 http的连接是简单无状态的，HTTPS协议是由ssl+http协议构成的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTP1.0 与HTTP1.1的区别 引入持久化连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。 引入管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 Http状态码： 1xx：指示信息，表示请求已经接收，继续处理 2xx：成功，表示请求已经被成功接收、理解、接受 3xx：重定向，表示完成请求必须进行更进一步的操作 4xx：客户端错误，请求有语法错误或者请求无法实现 5xx：服务器端错误，服务器未能实现合法的请求 常见的状态码： 200：OK——客户端请求成功 400：Bad request——客户端请求有语法错误，不能被服务器解析 401：unauthorized——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403：Forbidden——服务器收到请求，但是拒绝提供服务 404：Not found——请求资源不存在 如URL输入错误 500：Internal Server Error——服务器发生了不可预料的错误 503：Server Unavailable——服务器当前不能处理客户端的请求，一段时间后可能恢复正常 Http Request请求头常见字段： Http请求方式 ​ Host：请求的web服务器域名地址 User-Agent：Http客户端浏览器类型的详细信息 Accept：指定客户端能够接收的内容类型 text/xml、text/html Accept-Language：指定客户端浏览器用来显示返回信息所优先选择的语言 Accept-Encoding：指定客户端浏览器可以支持服务器返回内容的压缩编码类型，表示客户端浏览器所能支持的返回压缩格式 Accept-CharSet：浏览器可以接受的字符编码集 Content-type：此请求提交的内容类型，一般只有post提交时才需要设置该属性 Connection：表示是否需要持久连接，如果值是keep-Alive或者协议版本是HTTP1.1，就会进行持久连接 Cookie：http请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器 Date：请求发送的日期时间 Http Response响应头字段： Cache-Control：缓存机制,no-cache,private,public, Connection:是否要保持持久连接 Content-Encoding：返回来数据的压缩格式 Content-Language：相应体的语言 Content-type：返回资源文件的类型 Date：服务器发送资源时的服务器时间 Expiers:告诉客户端在这个时间前可以直接访问缓冲副本，相应过期时间 Last-Modifed:请求资源的最后修改时间]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 文章中插入图片问题]]></title>
    <url>%2F2017%2F05%2F13%2Fhexo%2Fhexo-%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 12345本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg)就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为 12345public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; 而不是愚蠢的 &lt;img src=&quot;本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt;]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识点]]></title>
    <url>%2F2017%2F05%2F13%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1. 进程管理1.1 进程基本概念程序顺序执行的特征 顺序性：每一个操作必须在下一个操作开始之前结束 封闭性：程序运行时独占全机资源，资源的状态只有本程序才能改变 可在现性 前趋图有向无环图 作用：用于描述程序段或进程间执行的前后顺序。 结点：表示程序段或进程，或一条语句** 有向边：表示结点之间的偏序(前驱)关系 并发执行时的特征 间断性——“停停走走” 失去封闭性——原因：多个程序共享资源 不可再现性 进程的定义与特征 结构性（PCB） 进程实体 = 程序 + 进程控制块(PCB) 程序=数据段+程序段 动态性 进程实质是进程实体的一次执行过程 体现在 “由创建而生，由调度而执行，由撤销而亡” 并发性 独立性 异步性 进程的定义进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 进程和程序的区别与联系 区别 进程是动态概念，强调的是执行，有创建、有撤销，存在是暂时的。程序是一静态概念，程序是指令的有序集合，“永远”存在； 进程具有并发性，而程序没有； 进程是接受计算机资源的基本单位，程序不是。 联系 进程是程序在数据集上的一次执行 一个程序可对应多个进程，一个进程可包括多个程序。 进程的三种状态 就绪状态 执行状态 阻塞状态 1.2 进程控制进程控制是进程管理中最基本的功能 用于创建新进程 终止一个已完成的进程 终止一个无法运行下去的进程 (Kill) 负责进程的状态转换 (就绪执行) 1.3进程图描述一个进程家族关系的有向树 1.4 经典进程同步问题生产者消费者问题记录型信号量方法 生产者 1234567891011121314 var mutex,empty,full:semaphore:=1,n,0；// 定义信号量 buffer:array[0,…,n-1] of item; // 定义缓冲区 in, out : integer :=0,0; // 定义下标指示变量begin //生产者如何执行(如何往缓冲区放东西) repeat 产生一个商品放入nextp中; wait(empty); //等待缓冲区有地方 wait(mutex); //等待可以使用缓冲区 buffer[in] := nextp; in := (in + 1) mod n; signal(mutex); //告诉其他进程：缓冲区可以使用了 signal(full); //告诉其他进程：缓冲区中多了一个商品 until false; end 生产者 1234567891011begin //消费者如何执行(如何从缓冲区取东西) repeat wait(full); //等待缓冲区有商品 wait(mutex); //等待可以使用缓冲区 nextc := buffer[out]; out := (out + 1) mod n; signal(mutex); //告诉其他进程: 缓冲区可以使用了 signal(empty); //告诉其他进程: 缓冲区空出一个地方 消费商品 nextc; until false;end; 注意wait(mutex)和signal(mutex)必须成对出现empty、full的wait、signal也要成对出现注意多个wait的顺序不能颠倒。 利用and信号量解决123456789101112生产者: … Swait(empty,mutex); buffer[in] := nextp; in := (in + 1) mod n; Ssignal(mutex,full);消费者: Swait(full,mutex); nextc := buffer[out]; out := (out + 1) mod n; Ssignal(mutex,empty); … 哲学家进餐问题利用记录型信号量12345678910var chopstick:array[0,…,4] of semaphore; 所有信号量初始值为1； repeat //第i个哲学家的活动 wait(chopstick[i]); //拿左筷子 wait(chopstick[(i+1) mod 5]); //拿右筷子 吃饭; signal(chopstick[i]); //放左筷子 signal(chopstick[(i+1) mod 5]); //放右筷子 思考; until false; 缺点： 如果每个人开始都先拿自己左边的筷子，可能导致人手一根筷子，而拿不到第二根筷子，从而全部阻塞，引起死锁。 and信号量12345678var chopstick: array[0,…,4] of semaphore; 所有信号量全部初始化为1; repeat Swait(chopstick[i], chopstick[(i+1) mod 5]); 吃饭; Ssignal(chopstick[(i+1) mod 5], chopstick[i]); 思考； until false; 1.5 进程通信进程通信类型 共享存储系统 消息传递系统 管道通信系统 1.6 线程和进程的区别与联系 调度 线程是调度的基本单位 进程是资源拥有的基本单位 拥有资源 线程不拥有系统资源，但是可以访问其隶属进程的系统资源，从而获得系统资源 并发性 支持多进程的系统中，不仅不同进程之间可以并发，同一进程中的线程也支持多并发 系统开销 进程切换时的时空开销大 进程切换时，只需保存和设置少量信息，因此开销很小 ​ 2. 处理机调度和死锁2.1 调度算法 先来先服务（FIFS）调度算法 短作业优先调度算法（SJF、SPF） 高优先权调度算法（FPF） 静态优先权：创建进程时分配，保持不变 动态优先权：随进程的执行或等待时间的增加而改变（防止长进程长期霸占） 高响应比优先权调度算法 动态优先权 优先权=（等待时间+要求服务时间）/要求服务时间 响应比=响应时间/要求服务时间 基于时间片的轮转调度算法——分时系统 2.2 实时调度实时调度与其他系统的区别：处理和控制的正确性不仅取决于计算的结果，还取决于计算和处理结果产生的时间。 实时调度算法 最早截止时间优先（EDF） 最低松弛度优先算法（LLF） 松弛度=完成截止时间-剩余运行时间-当前时间 2.3 产生死锁的原因和必要条件死锁：多个进程在运行过程中，因争夺资源二造成的一种僵局。这种僵局若无外力作用无法再向前推进。 产生死锁的原因： 资源竞争 进程推进顺序非法 死锁产生的必要条件 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 2.4 预防死锁的方法 摒弃请求和保持条件，规定所有进程在开始之前，都必须一次性申请其在整个运行过程中所需的全部资源，只要有一种资源不够，便不分配。 摒弃不剥夺条件，进程可以逐个申请资源，一旦申请的资源无法满足，立即释放已经保持的所有资源 摈弃环路等待条件 银行家算法：避免死锁 资源有序分配法：预防死锁 资源分配图化简法：检测死锁 撤销进程法：解决死锁 3. 存储器管理3.1 程序的装入和链接程序装入 绝对装入方式 程序中使用绝对地址，可编译时给出也可以有程序员直接赋予 可重定位装入方式 在装入是对程序中的指令和数据进行修改 动态运行时装入方式 执行代码是再进行地址转换 程序的链接 静态链接 装入时动态链接 运行时动态链接 3.2 连续分配方式 单一连续分配 把内存分为系统区和用户区两部分 固定分区分配 把用户区划分成若干个大小固定的分区，每个分区只放一个进程 当一个分区空闲时，可以选择一个新的进程进入那里运行 动态分区分配：根据进程的实际需要，动态分配内存空间 首次适应算法（FF） 以地址递增次序链接空闲分区，从链首开始查找，找到第一个满足请求大小的分区，从中划出请求大小的空间，余下的仍留在链中。 循环首次适应算法 由FF算法演变而成的。 从上次找到的空闲分区的下一个空闲分区查找。 最佳适应算法 分区按容量大小递增顺序排列，找到能满足分配的最小空闲分区。 动态重定位分区分配 对换定义：吧暂时不用的程序及其数据的部分或全部从内存移到外存上，以便腾出必要的空间 整体对换（进程对换） 部分对换（页面对换、分段对换） 3.3 基本分页存储管理方式页面与页表页面与物理块 把进程的逻辑地址空间分成若干大小相等的片，称之为页面或页，编号从0开始。 把内存的存储空间也划分成与页相同大小的片，这些片称为物理块或页框，编号从0开始 3.4 基本分段存储管理方式分页和分段的主要区别 页是信息的物理单位，分页是为消减内存的碎片，提高内存的利用率。分页仅是由于系统管理的需要。 段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 页的大小固定，由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；段的长度不固定，决定于用户所编写的程序，由编译程序编译源程序时，根据信息的性质来划分。 3.5 页面置换算法抖动：系统一直忙于页面的调入/调出，以致大部分CPU时间都用于处理缺页中断和页面淘汰上，很少能顾及到用户进程的实际执行的现象称为“抖动” 注意：缺页中断不一定引起页面淘汰。只有内存中没有空闲块时，缺页中断才会引起页面淘汰 最佳置换算法从内存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面 先进先出置换算法（FIFO）总是选择进程中驻留时间最长的页淘汰，即先进入内存的页面先淘汰出内存。 最近最久未使用置换算法（LRU）选择最近一段时间内最久不用的页面进行淘汰 4. 设备管理4.1 I/O控制方式程序控制方式忙——等待方式。 中断驱动方式​ 中断时以字节为单位进行控制的 进程要启动I/O设备工作时，由CPU向该设备控制器发出一条I/O命令，然后便可立即返回继续执行原来的任务。 设备控制器按照命令要求去控制指定设备。此时，CPU与I/O设备并行操作。 设备处理完数据后，便产生一个中断信号。此时，CPU便转而处理该信号。 DMA方式传输的基本单位是数据块，CPU与I/O设备之间每次传送至少一个数据块。仅在传送一个或多个数据块的开始或结束时才需要CPU干涉。 DMA工作过程 以从磁盘读入数据为例： 从磁盘读入数据块时，CPU将一条读指令送至磁盘控制器的命令寄存器(CR)中。 将数据读入的内存起始目标地址送入内存地址寄存器（MAR）中；将读数据的字(节)数送入数据计数器(DC)中 将磁盘的源地址送至DMA控制器的I/O逻辑中。 然后，启动DMA控制器进行数据传送，以后，CPU便可去处理其它任务。 此后，整个数据传送过程便由DMA控制器进行控制。 当DMA控制器已从磁盘读入一个字(节)的数据并送入数据寄存器(DR)后，将该字(节)传送到指定的内存单元中。 接着便对MAR内容加1，将DC内容减1。 若减1后DC内容不为0，表示传送未完，便继续传送下一个字(节)； 否则，由DMA控制器发出中断请求。 DR：数据寄存器，用于暂存数据 MAR：内存地址寄存器，存放数据的源/起始目标地址 DC：数据计数器，存放本次CPU要读或写的字节数 CR：命令/状态寄存器，接收从CPU发来的I/O命令或有关控制信息或设备状态 I/O通道控制方式 指令类型单一，主要局限于对I/O操作 没有自己的内存，通道程序放在内存里 在设置了通道后，CPU只需向通道发送一条I/O指令。通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成了规定的I/O任务后，才向CPU发中断信号 4.2 缓冲管理引入缓冲 缓和CPU与I/O设备间速度不匹配的矛盾 减少对CPU的中断频率 提高CPU和I/O设备之间的并行性 单缓冲和双缓冲单缓冲每当用户进程发出一个I/O请求时，OS便在内存总位置分配一个缓冲区 max(磁盘到缓冲区，CPU处理) + 缓冲区到用户区 双缓冲区设备输入时，先将数据送入缓冲区1，装满后转向缓冲区2 循环缓冲在循环缓冲中包括多个缓冲区，每个缓冲区的大小相同 作为输入的多缓冲区可分为三种类型： 空缓冲区R 已装满数据的缓冲区G 计算进程正在使用的工作缓冲区C 缓冲池公用缓冲池，池中设立多个缓冲区，为多个进程共享，以提高利用率 4.3 设备分配SPOOLing技术 脱机输入/输出技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反。 SPOOLing技术的实质是模拟脱机输入、输出 基本方法 用一个进程将设备输入的数据暂存到磁盘上 用另一个进程把暂存在磁盘上的数据传送到设备上 spooling 系统组成部分 输入井、输出井 磁盘上的两块大存储区，用于暂存输入、输出的数据 输入缓冲区、输出缓冲区 位于内存中，作用是缓和CPU和设备之间的速度差异 输入进程、输出进程 输入进程：利用输入缓冲区为中介，吧输入设备的数据存入输入井 输出进程：将用户数据存入输出井，设备空闲时再将输出井中的数据利用输出缓冲区送入设备 ​ 4.4 磁盘存储器管理磁盘调度算法 先来先服务（FCFS） 根据进程请求访问磁盘的先后次序进行调度 最短寻道时间优先（SSTF） 首先满足访问的磁道与当前所在磁道之间距离最短的进程。但是这种算法不能保证平均寻道时间最短 进程饥饿现象 因为只要不断有新进程的请求到达，且其所要访问的磁道与当前磁道之间的距离较近，新进程的I/O请求必然优先满足。致使老进程的请求长期无法得到满足 扫描算法（SCAN） 当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对象，应是要访问的磁道既在当前磁道之外，又是距离最近的。 这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁头换向为自外向里移动 循环扫描算法（CSCAN） 磁头只做单向移动。例如总是自里向外，当磁头移到最外的磁道并访问完后，磁头立即返回最里要访问的磁道。 5. 文件管理5.1 文件逻辑结构文件逻辑结构的类型 有结构文件 无结构文件（流式文件） Unix系统吧所有文件都看做流式文件 顺序文件记录可以任意顺序排列 索引文件顺序索引文件直接文件和hash文件外存分配方式连续分配方式文件存储于连续的盘块上 链接分配通过盘块上的链接指针，把保存在不同盘块上的各文件部分链接起来]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-theme-indigo-card主题安装及常见问题解决]]></title>
    <url>%2F2017%2F05%2F13%2Fhexo%2Fhexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令。 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 切换主题执行 git branch 显示所有本地分支，如果只存在一个分支，可以执行下面的命令获取另一分支的主题。 12345# 获取远程 card 分支，并切换$ git checkout -b card origin/card# 获取远程 master 分支，并切换$ git checkout -b master origin/master 此命令只需执行一次，之后使用 git checkout [branch] 命令在两个主题之间切换。 依赖安装还是在 Hexo 根目录，如果以下插件已安装过，无需再次安装。 Less主题默认使用 less 作为 css 预处理工具。 1$ npm install hexo-renderer-less --save Feed用于生成 rss。 1$ npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。 1$ npm install hexo-generator-json-content --save QRCode用于生成微信分享二维码。 可选，不安装时会请求 jiathis Api 生成二维码。 1$ npm install hexo-helper-qrcode --save 开启标签页1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 开启分类页仅 card theme 支持。 1hexo new page categories 修改 hexo/source/categories/index.md 的元数据 123layout: categoriescomments: false--- 常见问题如何设置文章摘要在 Markdown 中加 &lt;!-- more --&gt; 文章如何添加多个标签有两种多标签格式 1tags: [a, b, c] 或 1234tags: - a - b - c 修改 brand 图片（菜单上方背景图）替换 themes\indigo\source\img\brand.jpg，保持原文件名不变。 如何在文章中使用图标先到 fontawesome 找到你需要的图标名，比如：book，按以下格式使用： 1&lt;i class=&quot;icon icon-book&quot;&gt;&lt;/i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 1234567891011121314&lt;!-- 1.3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-lg&quot;&gt;&lt;/i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-2x&quot;&gt;&lt;/i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-3x&quot;&gt;&lt;/i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-4x&quot;&gt;&lt;/i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-5x&quot;&gt;&lt;/i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class=&quot;icon icon-book icon-pr&quot;&gt;&lt;/i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class=&quot;icon icon-book icon-pl&quot;&gt;&lt;/i&gt; 个别图标无法显示如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。 解决办法：可配置 ADBlock 不在你的站点运行。 生成站点后没有样式安装less 更改样式后网站没有生效确认非缓存问题后，执行 hexo clean 再进行生成上传。 更改站点配色编辑 themes\indigo\source\css\_partial\variable.less，更改对应的颜色变量。 配色参考：Material Design Color Palette Generator 添加404页面在 hexo/source 目录内新建 404.html。 设置元数据信息，如果不想套用主题布局可设置 layout 为 false。 123layout: false title: &quot;My Blog Name | 404&quot;--- 在博客中使用 Emoji参考 Can i use emoji in mypage? 多说 多说配置，取你的多说后台网址二级域名。比如我的是：http://ysblog.duoshuo.com/admin/中的 ysblog。 评论中如果显示 HTML 标签，你需要 进入多说设置 -&gt; 评论解析 -&gt; 解析HTML代码 勾选上。 已本地化多说脚本和样式，有个人需求的可以自行修改相关样式 source/css/_duoshuo/* 和脚本 source/css/js/embed.js。 配置站点配置编辑站点配置文件，hexo/_config.yml。 启用主题1theme: indigo 基本配置为了得到更好的使用体验，以下内容请务必填写完整，因为这些内容会在主题中得到展示。更多 1234567title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url feed配置参考 hexo-generator-feed 1234feed: type: atom path: atom.xml limit: 0 jsonContent配置为了节约资源，可以对 jsonContent 插件生成的数据字段进行配置，减少数据文件大小。参考 hexo-generator-json-content 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 主题配置编辑主题配置文件，themes/indigo/_config.yml。 左侧菜单默认配置如下 1234567891011121314151617menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下： 12345menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 fontawesome 图标已集成到主题中，你可以到 这个页面 挑选合适的图标。 rss1rss: /atom.xml favicon站点 logo，显示在浏览器当前标签页左上角。 1favicon: /favicon.ico 头像位于左侧菜单上方 1avatar: /img/logo.jpg email头像下方 1email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。 1color: &apos;#3F51B5&apos; 标签页 (old)配置标签页标题 12tags: title: 标签 页面标题 (card theme)自定义归档、标签、分类页的大标题。 123tags_title: Tagsarchives_title: Archivescategories_title: Categories 文章摘要可以在 Markdown 文件中加 &lt;!--more--&gt;以分割摘要与文章正文。未设置时，按 excerpt_length设置截取。 123456# 文章摘要渲染方式: 为 true 时将渲染为 html，否则为文本excerpt_render: false# 截断长度excerpt_length: 200# 文字正文页链接文字excerpt_link: 阅读全文... mathjax开启后，使你的站点支持公式渲染，by mathjax。 请按需开启，因为此项需要加载额外的 js 文件。 1mathjax: false 分享文章分享开关，by jiathis-api。 1share: true 文章打赏默认开启 1234reward: title: 谢谢大爷~ #显示的文字 wechat: /img/wechat.jpg #微信，关闭设为 false alipay: /img/alipay.jpg #支付宝，关闭设为 false 此外在 crad theme 中，可以通过在 markdown 头部添加 reward: false 来控制某些不想开启打赏的页面。 关闭 1reward: false 二维码请自行从微信、支付宝中下载。当两个二维码同时存在时，为保持显示效果的一致性，注意截图时的边框留白保持一致。必要时可借助PS等图片处理工具进行图片大小裁剪、压缩等。 站内搜索是否开启搜索 1search: true 布局开启后，文章页在大屏下会隐藏左侧菜单，专注阅读。 1hideMenu: true Toc开启文章内容导航。 123#toc: false #关闭toc: list_number: false # 决定导航使用的标签， true 为 ol， false 为 ul。 copyright (card theme)文章页版权声明内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io。 1copyright: 这里写留言或版权声明：&lt;a href=&quot;&lt;%- url_for(page.path) %&gt;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;%- url %&gt;&lt;/a&gt; less设置 less 编译时的入口文件路径，hexo-renderer-less。 1234less: compress: true # 是否压缩css paths: - source/css/style.less 评论集成了多说和 disqus，开启其一即可。 duoshuo-key 即多说创建站点时的二级域名。如：abc.duoshuo.com，就填 abc。 1duoshuo: duoshuo-key 或 1disqus_shortname: disqus_shortname 数据统计集成的有谷歌和 CNZZ，请填写你的站点标识。 12google_analytics: keycnzz: 站点id 谷歌站点验证 (card theme)1google_site_verification: false 规范网址 (card theme)让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径。使用规范网址 1canonical: http://imys.net 版权起始年份1since_year: 2006 自定义页面关于用户页面中作者相关的描述性文字，如不需要设为 false 1about: 用户页面中作者相关的描述性文字，如不需要设为 false]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布隆过滤器]]></title>
    <url>%2F2017%2F05%2F13%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介 布隆过滤器主要用于判断一个元素是否在集合中，常见的如垃圾邮件过滤的黑白名单方法、爬虫的网址判重模块等。 Hash表也可以用于判断元素是否在集合中，但是布隆过滤器只要Hash表的1/4或1/8甚至更少的空间复杂度就能完成同样的问题。 布隆过滤器存在一定的误报率，通过设计bitArray的大小可以将误报率控制在极低水平。使用布隆过滤器一定是在有一定容错概率的情况下。 布隆过滤器的设计假设数据查询的数据量为n，允许的失误率p 长度为m的BitArray，二进制数组，里面存放的数据都是0和1 k个相互独立的hash函数 添加元素 初始时将BitArray中的元素全部置为0 将单条数据str，分别用k个hash函数计算出对应的hash值，将这k个hash值再对m进行取模运算，得到数据h1,h2,……hk. 将BitArray h1、h2、……hk位置上的值置为1 每条数据都重复2、3步骤。 查询元素是否在集合中 将要查询的数据分别用k个hash函数计算出对应的hash值，然后对m进行取模运算，得到数据h1 h2 …… hk. 判断BitArray h1、h2、……、hk位置上的值是否全部都是1，如果全为1则表示数据已经在集合中，如果不全为1则表示数据不在集合中。 n k m p 之间的关系 样本个数n和允许失误概率p可以求出m $$m= - \frac{n*lnp}{(ln)^2}$$ 根据m可以求出k，hash函数的个数 ​$$k =ln2 \frac{m}{n} = 0.7 \frac{m}{n}$$ 由于在计算m和k的过程中都是向上取整的，失误率会降低，可以根据下面的公式计算出具体的失误率：$$p=(1- e ^-(\frac{nk}{m}))^k$$求出真实的失误率p]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合_Map介绍]]></title>
    <url>%2F2017%2F05%2F10%2Fjava%2FJava%E9%9B%86%E5%90%88-Map%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[HashMap（非线程安全） HashMap底层由一个EntrySet数组构成，每个EntrySet都是一个链表 12345678910111213static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; ……&#125; loadFactor，加载因子，默认值是0.75。当map中的元素个数size&gt;=table.length*loadFactor时，hashMap 会进行扩容。如果loadFactor过小，则空间浪费比较严重；若loadFactor过大，则hashmap冲突的概率会加大，造成一些EntrySet链表过长。 创建hashMap时可以指定初始容量和加载因子，默认初始容量为16，加载因子为0.75 计算元素o 在table数组中的下标，其中h是根据o.key计算的hash值，length是指数组的长度 123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; hashMap中的key和value都可以为null，当key==null时，该元素会放在table下标为0的位置上。 12if (key == null) return putForNullKey(value); 123456789101112131415private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; //如果map中原来已经存在key值为null的元素，则更新value值 if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // hash值为0，key=null value=value 在table中位置index=0 addEntry(0, null, value, 0); return null;&#125; map中添加新元素时，是将元素添加在链表头。 123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; //threshold = table.length * loadFactor 判断是否需要扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125; 1234567//创建一个新的结点，插入链表头。即创建新元素时是插入链表头的。void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; //table[bucketIndex]表示的是链表头，链表头指向了新建的结点，同时新节点的next指针指向 了原来的链表头结点。 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++; &#125; map扩容是原来table长度的2倍。扩容时，需要遍历原来的map，将每个元素重新计算hash值和在新table的中位置，再放入新的table中。 1234567891011121314151617void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; //计算元素在新table中的位置 int i = indexFor(e.hash, newCapacity); //newTable[i]是其中一个链表的链表头 e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125; &#125; Hashtable(线程安全) HashTable是线程安全的容器，而HashMap是非线程安全的 HashTable 继承自Dictionary类，该类自Java1.0就已经存在；HashMap继承自AbstractMap,这个抽象类是是在1.2才加入的 Hashtable 不允许key和value为空值null；HashMap允许key和value为空值null。 Hashtable的hash函数不同 1234private int hash(Object k) &#123; // hashSeed will be zero if alternative hashing is disabled. return hashSeed ^ k.hashCode(); &#125; HashTable 默认初始容量是11，加载因子默认是0.75 HashTable计算index方法与HashTable不同 1234//hashtable 计算indexint index = (hash &amp; 0x7FFFFFFF) % tab.length;// HashMap 计算下标return h &amp; (length-1); HashTable扩容时原来table数组长度的两倍加1 1int newCapacity = (oldCapacity &lt;&lt; 1) + 1; TreeMap(非线程安全) Treemap 底层是通过红黑树算法实现的，想要了解TreeMap的实现必须先对红黑树有一定了解，下面先介绍一下红黑树的相关概念 红黑树简介红黑树是一种自平衡的二叉查找树，具有二叉树的所有特性。红黑树具有如下五点性质 结点要么是红色要么是黑色 根节点是黑色 每个叶子结点是黑色 从根节点到叶子结点的所有路径上不能有两个连续的红色结点 从任一结点到其每个叶子结点的所有路径都包含相同数目的黑色结点 ​ 红黑树 ​ 普通二叉树，根节点的左右子树不平衡 TreeMap介绍TreeMap相关定义TreeMap中包含信息中比较重要的有如下这些 12345678//比较器，用于比较结点的大小private final Comparator&lt;? super K&gt; comparator;//根节点private transient Entry&lt;K,V&gt; root = null;//元素的个数private transient int size = 0;//map修改次数private transient int modCount = 0; 对叶子结点的定义如下： 123456789101112131415static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left = null; Entry&lt;K,V&gt; right = null; Entry&lt;K,V&gt; parent; //新生成的结点都是黑色的 boolean color = BLACK; Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125;&#125; TreeMap添加元素方法put添加元素的时候首先判断root结点是否为空，如果是空直接创建新的结点作为map的根节点；如果不为空，则根据比较器（若创建TreeMap时未指定比价器，则以key的字典序作为比较器）找到元素的位置。寻找元素位置时是对二叉搜索树进行查找，key&gt;node 则查找右子树，key&lt;node查找左子树，key==node 直接更新node的value值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; //根节点为空 if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; //创建TreeMap时已经指定比较器 if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); //父节点大于新加的结点，则遍历左子树 if (cmp &lt; 0) t = t.left; //父节点小于新加结点，则遍历右子树 else if (cmp &gt; 0) t = t.right; else //父节点等于新加结点，则直接更新父节点的value值 return t.setValue(value); &#125; while (t != null); //循环结束还没找到结点key和新节点key相等，此时parent指向了叶子结点 &#125; else &#123; if (key == null) throw new NullPointerException(); //未指定比较器，则比较器设为字典序 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; //结点位置查找过程和上面一样 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; //如果遍历后还未找到key,则创建新节点，新节点的parent指向前面遍历后的最后一个叶子结点 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); //如果新节点的key小于parent的key,则新节点作为parent的左孩子，反之作为右孩子 if (cmp &lt; 0) parent.left = e; else parent.right = e; // 添加完新节点后 需要对这棵树进行调整平衡 fixAfterInsertion(e); size++; modCount++; return null; &#125; 上面的put方法只是将新节点插入了适当的位置，保证了此时的二叉树是二叉搜树，但它不一是平衡二叉树。所以在插入新节点后有一个修正操作fixAfterInsertion(e)，修正操作就是保证二叉树是平衡二叉树。 修改后 修改后 最后修改成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; //将新插入的结点设为红色 x.color = RED; // 循环直到 x不是根结点，且x的父节点不为红色 while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; //如果结点x的父节点P 是P的父节点G的左子树 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; //否则结点x的父节点P 是P父节点G的右子树 G &#125; else &#123; // y P // x x可能是左子树也可能是右子树 Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; //如果x是P的左孩子 if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; TreeMap 查找复杂度是O(logN)，HashMap的查找复杂度是O(1)，查找效率来说HashMap 效率更高。但是TreeMap存储的数据是有序的，而HashMap存储的数据是无序的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>TreeMap</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合_List介绍]]></title>
    <url>%2F2017%2F05%2F08%2Fjava%2FJava%E9%9B%86%E5%90%88-List%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[集合类介绍 ArrayList（非线程安全） ArrayList底层采用数组存放数据 创建时可以指定初始容量的大小，若不指定则默认是10. ArrayList扩容是1.5倍的增长 123int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//将数组内容拷贝到新创建的数组中，并返回新创建数组的引用elementData = Arrays.copyOf(elementData, newCapacity); arrayList不是线程安全的容器 当数组元素已经达到数组容量时才会发生扩容 Vector（线程安全） Vector与ArrayList实现基本相同，当时Vector是线程安全的，每个操作方法中加了synchronized关键字，属于线程安全的容器 创建Vector时可以指定初始容量，也可以指定发生扩容时扩容的大小。若没指定初始容量大小默认是10；若没有指定扩容的大小，默认是两倍增长，否则 12int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); LinkedList（非线程安全） LinkedList底层实现是通过链表，每个元素是一个Node结点 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 定义两个变量first、last分别指向链表的头结点和尾结点 实现了Queue 接口 offer(E e) 操作调用add方法，将元素插入队列的尾部 添加元素e之后 poll操作删除队列头元素，删除的是first结点 element操作返回队列头结点，即first结点，如果first==null 抛出异常 peek操作返回队列头结点，即first结点，如果first==null 则返回null 实现了Stack功能 push添加元素，注意是在链表的头结点处插入元素 pop 操作是删除链表的头结点 peek 操作返回链表的头结点]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>vector</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-继承关系和常用API]]></title>
    <url>%2F2017%2F05%2F05%2Fjava%2FJava%E9%9B%86%E5%90%88-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[集合继承关系Collection集合的类继承关系图： Map集合继承关系图： 常用的APIArrayList：123456789101112131415161718//List尾部添加元素boolean add(E e);//在index位置添加元素public void add(int index,E element);//移除元素oboolean remove(Object o);//移除下标index的元素public E remove(int index);//清空列表public void clear();//添加集合中的全部元素public boolean addAll(Collection&lt;? extends E&gt; c);//返回list的遍历public Iterator&lt;E&gt; iterator();//是否包含元素public boolean contains(Object o);//将下标为index元素替换public E set(int index,E element) Queue：12345678910//添加元素boolean add(E e);//获取并移除队列头,此队列为空时将抛出一个异常。E remove();//获取并移除此队列的头，如果此队列为空，则返回 null。E poll();//获取，但是不移除此队列的头。此方法与 peek 唯一的不同在于：此队列为空时将抛出一个异常。E element();//获取但不移除此队列的头；如果此队列为空，则返回 null。E peek(); Set:12345678910//添加元素boolean add(E e);//移除元素boolean remove(Object o);//添加所有集合元素boolean addAll(Collection&lt;? extends E&gt; c);//清空集合void clear();//返回set的迭代器Iterator&lt;E&gt; iterator(); Stack: 继承自vector，是线程安全的12345678910//把项压入堆栈顶部。public E push(E item);//移除栈顶元素public E pop();//返回栈顶元素，但是不删除public E peek();//测试栈是否为空public boolean empty();//返回元素在栈中的位置，以1为基数，-1表示不存在public int search(Object o);]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql优化策略]]></title>
    <url>%2F2017%2F03%2F16%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[尽量少用IN操作，基本上所有的IN操作都可以用Exists代替 不用Not IN操作，可以用Not Exists代替 不用“!=”、或者“&lt;&gt;”操作符，不等操作会造成全表扫面，可以用&gt;或者&lt;代替 尽量不使用IS NULL或者IS NOT NULL操作，数据表设计时，对索引列设置为NOT NULL，查找的时候就可以避免使用IS NULL操作 通配符“%”、“_”作为第一个字符时索引会失效，因此一般不要作为第一个字符出现 where子句中避免在索引列上使用计算，否则将导致索引失效而进行权标扫描 MySQL SQL基本原则 尽量少使用join 尽量少排序 尽量避免select* 尽量用join代替子查询 尽量少使用or 尽量用union all 代替union 尽早的过滤 避免类型转换 尽量优化高并发的sql，而不是执行频率低的某些”大“SQL 从全局出发优化，而不是片面调整]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关知识点]]></title>
    <url>%2F2017%2F02%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[数据库相关概念：​ 数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库数据具有永久存储、有组织和可共享三个基本特点。 候选码若关系中的某一属性组的值能唯一的标识一个元组，则该属性组成为候选码 主码若一个关系中有多个候选码，选其中一个作为主码。 主属性候选码的诸属性成为主属性 外码若F是基本关系R中的属性（不是R的码），K是基本关系S的主码，如果F和K相对应，则陈F是R的外码 完整性约束 实体完整性： 若属性A是基本关系R的主属性，则A取值不能为空。 参照完整性： 若F是基本关系R的外码，F与基本关系S中的K相对应，则其取值要么为空要么是基本关系S中的主码值 用户定义完整性： 关系数据库标准语言SQL模式创建与删除 创建模式 create schema test authorization wang 删除模式 drop schema test cascade|restrict cascade:级联删除（默认） restrict:限制删除，如果有数据的话不能删除 基本表的创建、删除、修改 创建表 1234567create table Student( Sno char(16) primary key , /* Sno 是主码*/ name char(32) unique, /* 姓名唯一*/ age smallint default 0, /*默认值是0*/ Cpno int, foreign key (Cpno) references Coures(Cno)/* 外键 */); 12345678create table SC( Sno char(16), Cno char(16) default null, grade smallint, primary key (Sno,Cno), /*sno和cno 两个属性作为主码*/ foreign key (Sno) references Student(Sno), foreign key (Cno) references course(Cno)) 12345678create table sc( sno char(16), cno char(16), grade smallint, primary key (sno,cno), foreign key (sno) references student(sno) on delete cascade on update cascade, foreign key (cno) references course(cno) on delete cascade on update cascade) 修改表属性 1alter table Student add sex char(2) /*添加字段*/ 1alter table Student drop sex /*删除字段*/ 1alter table Student modify sex int; /*字段sex修改为int 类型*/ 1alter table student change sex ses int;/*修改字段名称和类型*/ 删除表 1drop table se cascade;/*删除表*/ cascade：级联删除 restrict：限制删除 索引的创建于删除 创建索引 1create unique index Sname on Student (name); unique:唯一索引 cluster:聚簇索引 删除索引 1alter table student drop index Sname; 数据查询单表查询查询指定列1select Sno,name from student; /*查询某些属性列*/ 查询全部1select * from student; /*查询全部内容*/ 查询计算值1select name,2004-age from student; 消除重复的行1select distinct Sno from SC 查询满足条件的元组 比较大小(=、&gt; 、&lt;、&gt;=、&lt;=、!=、!&gt;不大于、!&lt;、不小于) 1select name from student where Sdept='CS';/*比较大小*/ 确定范围(between…… and……、not between…… and……) 1select name,age from student where age between 20 and 23; 确定集合 1select name,age from student where Sdept in ('CS','MA','IS'); 1select * from student where sdept not in ('CS','IS','MA'); 字符匹配like %：任意长度的字符串 1select * from student where name like '张%';/*查找名字是张的学生*/ ：代表任意单个字符(其中汉字占两个字符，需要两个 ) 1select * from student where name like '张_ _'；/*查询姓张的名字只有一个字的学生*/ /:转换字符，如果查询的字符中含有% 、_ 就需要用/进行转义 1select * from student where sdept like '*/_IS';/*查询sdept 以'_IS'结尾的元组 */ 空值查询 1select* from student where name is null; 多重条件查询(and |or) 1select* from student where age=22 and name like '张%'； order by 排序asc:查询结果升序排列（默认） desc:查询结果将序排列 1select* from student where age=22 order by name desc; 聚合函数distinct:表示去除重复的数据 all:表示全部数据，可以重复（默认） count(distinct|all *):统计元组个数 count(distinct|all 列名):统计一列中值得个数（即一列中为空值得个数） sum(distinct|all 列名)：计算一列中值得总和（该列只能是数值型） avg(distinct|all 列名)：计算一列的平均值（该列只能是数值型） max(distinct|all 列名)：求一列中的最大值 min(distinct|all 列名)：求一列中的最小值 1select count(distinct age)from student; 1select sum(distinct age)from student; group by查询结果分组，值相等的为一组1select Cno count(Sno) from Sc group by Cno;/*按Cno分组*/ 对分组进行筛选 1select Sno from SC group by Sno having count(*)&gt;3;/*查询选修3门课以上的学生学号*/ where：作用于基本表或试图，从中选中满足条件的元组 having：作用于组，从中选择满足条件的组。 连接查询等值与非等值连接查询=、&gt;、&lt;、&gt;=、&lt;=、!= 1select student.*,sc.*from student,sc where student.sno = sc.sno 自身连接查询先修课程cpno是指先修课 1select first.cno,second.cno from course first,course second where first.cpno=second.cno 外连接1select student.sno,student.name,sc.cno,sc.grade from student left outer join sc on(student.sno=sc.sno)；/*左外连接*/ 1select student.sno,student.name,sc.cno,sc.grade from student right outer join sc on(student.sno=sc.sno)；/*右外连接查询*/ 复合条件连接1select student.sno,student.name,sc.grade,course.cno,course.cname from student,sc,course where student.sno=sc.sno and sc.cno = course.cno; 嵌套查询不相关子查询：子查询条件不依赖于父查询，称为不相关子查询 相关子查询：子查询条件依赖于父查询，称为相关子查询 带有in谓词的查询123select student.* from student where sdept in ( select sdept from student where name="张三");/*查询和张三同一个系的学生*/ 带有比较运算符的子查询123456select sno,cno from sc xwhere grade&gt;(select avg(grade) from sc y where x.sno = y.sno );/*子查询一定要跟在比较符之后*/ 带有any|all谓词的子查询>any :大于子查询中的某个值 >all :大于子查询中的全部值 \&lt;any :小于子查询中的某个值 \&lt;all :小于子查询中的全部值 带有exists谓语的子查询带有exists谓语的子查询不返回任何数据，只产生逻辑真值true 或逻辑假值false 1234567select namefrom studentwhere exists( select * from sc /*子查询子产生true或false*/ where sno=student.sno and cno ='1');/*查询选了1号课程学生的姓名*/ 集合查询注意：参与集合操作的个查询结果列数必须相同，对应项的数据类型也必须相同，MySQL数据库中只有union union:并操作，默认是去掉重复数据，union all 保留重复数据 1234/*查询计算机系的学生或年纪不大于19岁的学生信息*/select * from student where sdept='cs'unionselect * from student where age&lt;='19'; 1234/*查询选了1号或2号课程的学生*/select sno from sc where cno ='1';unionselect sno rom sc where cno='2'; intersect:交集 1234/*查询选了1号和2号课程的学生*/select sno from sc where cno ='1';intersectselect sno rom sc where cno='2'; except:差操作 1234/*查询计算机系的学生和年龄不大于19岁的学生的差集*/select * from student where sdept='cs'expectselect * from student where age&lt;='19'; 数据更新插入数据插入元组12insert into student (sno,name,age,sdept)values ('123','bob',12,'cs'); 若未指定任何属性名，则插入的元组必须在每个属性上均有值 12insert into student values ('345','nick',12,'in'); 插入子查询数据123/*插入每个系学生的平均年龄*/insert into sdept_age(dept,age)select sdept,avg(age) from student group by sdept; 修改数据修改一个元组的值123update studentset age =23where sno ='244'; 修改多个元组的值123/*所有学生年龄加1*/update studentset age =age+1; 删除数据1delete from student where sno ='123' 视图操作创建视图12345create view is_student asselect sno,name,age from student where sdept='is'; 1234567create view cs_student (cs_no,cs_name,cs_age)asselect sno,name,age from student where sdept='cs'with check option;/*表示以后对视图进行插入删除修改时，自动加上sdpet='cs'*/ with check option:表示对视图进行修改插入和删除时，要保证更新的行满足视图定义中的谓词条件.就是当对视图进行插入和修改时，操作后该数据还能满足视图查询条件。 删除视图1drop view is_student 数据库安全性授权与回收grant1234grant 权限1，权限2，……on 对象1，对象2，……to user1，user2,……with grant option 123grant selecton table studentto u1;/*给u1赋予查询student表的权限*/ 123grant all privilegeson table student，courseto user1,user2；/*赋予全部权限*/ 123grant selecton table student，courseto public;/*查询权限赋予所有人*/ 1234grant inserton table studentto user1with grant option;/*将插入权限赋予user1，并且user1还可以将这个权限赋予其他人*/ revoke123revoke 权限1，权限2……on 对象1，对象2……from user1，user2； 123revoke inserton table studentfrom user1 cascade;/*级联回收插入权限*/ 关系数据库理论规范化函数依赖定义：对于R(U)的任意一个可能的关系r,r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X—&gt;Y. X—&gt;Y,但Y不是X的子集，则称X—&gt;Y是非平凡的函数依赖。列如：（sno,cno）—&gt;grade X—&gt;Y,但Y是X的子集，则称X—&gt;Y是平凡的函数依赖。列如：（sno,cno）—&gt;sno 完全函数依赖如果X—&gt;Y,并且对于X的任意一个真子集X‘，都有Y不函数依赖于X’，则称Y对X是完全函数依赖。(sno,cno)—&gt;grade 若果X—&gt;Y,但是Y不完全依赖于X，则称Y对于X部分函数依赖。(sno,cno)—&gt;sdept，sno—&gt;sdept 传递函数依赖如果X—&gt;Y，X不函数依赖于Y，Y—&gt;Z,则称Z 对于X传递函数依赖。X—&gt;Y,Y—&gt;Z ==&gt; X—&gt;Z 范式1NF（第一范式）每一个分量必须是不可分的数据项。 2NF(第二范式)若R属于第一范式，且每一个非主属性完全函数依赖于码，则R属于2NF。即消除了部分函数依赖。 S-L-C(sno,sdept,sloc,cno,grade); sno:学号 sdept:所属院系 sloc:院系住的位置 cno:课程号 grade:成绩 (sno,cno)—&gt;grade :完全函数依赖 sno—&gt;sdept, (sno,cno)—&gt;sdept:部分函数依赖 sno—&gt;sloc,(sno,cno)—&gt;sloc:部分函数依赖。 拆分： SC（sno,cno,grade） SL（sno,sdept,sloc） 3NF(第三范式)关系模式R\ 中若不存在这样的码X，属性组Y，及非主属性Z，使得X–&gt;Y,Y—&gt;Z成立，则称R属于3NF。 即消除了部分函数依赖和传递依赖。 SL(sno,sdept,sloc)：每个院系学生住同一个位置 sno—&gt;sdept,sdept—&gt;sloc ==&gt; sno—&gt;sloc :属于传递函数依赖 拆分 SD(sno,sdept) SL(sdept,sloc) BCNF关系R属于第一范式，若X—&gt;Y且Y不属于X时，X比含有码，则称R属于BCNF。 即每个决定因素都包含码。 数据库恢复技术事务定义：事务就是用户定义的数据库操作序列，这些操作要么全都做要么全都不做，是一个不可分割的工作单位 事务的特性 原子性：事务中的操作要么全都做要么全都不做 一致性：事务执行结果必须是使数据库从一个一致性状态变到另一个一致性状态 隔离性：一个事务的执行不能被其他事务干扰 持续性：一个事务一旦提交，他对数据库中的数据的改变就应该是永久性的。 ​ 并发控制数据不一致性 丢失修改 两个事务T1和T2读入同一个数据并修改，T2提交的结果破坏了T1提交的结果，导致了T1的修改丢失 不可重复读 指事务T1读取数据后，事务T2对数据执行了更新操作，使T1无法再现第一次读取的结果 读“脏”数据 指事务T1修改数据后并将其写回数据库，同时事务T2读出修改后的数据，但T1因为某些原因被撤销，这时候T1修改的数据恢复原先的值，这时T2读取的数据就和数据库中的数据不一致，则T2读到的数据就是“脏”数据，即不正确的数据。 R(X):表示读取数据 W(X):表示写入数据 T1 T2 T1 T2 T1 T2 R(A)=16 R(A)=50 R(B)=100 求和=150 R(C)=100 C=C*2 W(C)=200 R(A)=16 R(B)=100 B=B*2 W(B)=200 R(C)=200 A=A-1 W(A)=15 R(A)=50 R(B)=200 和=250 (验算不正确) ROLLBACK C恢复为100 A=A-1 W(A)=15 丢失修改 不可重复读 读脏数据 事务的隔离级别 Read uncommitted(未授权读取、读未提交) 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。 Read committed（授权读取、读提交） 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。 该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。 Repeatable read（可重复读取） 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 避免了不可重复读取和脏读，但是有时可能出现幻读。这可以通过“共享读锁”和“排他写锁”实现。 Serializable（序列化） 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。 序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 封锁排它锁（写锁）​ 若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他的任何事务都不能再对A加任何类型的锁，直到T 释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A 共享锁（读锁）​ 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能在对A加S锁，而不能加X锁，直到T释放A上的S锁，这就保证了其他事务可以读取A，但在T释放A上的S锁之前不能对A做任何修改。 活锁与死锁活锁​ 如果事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的请求后，系统又批准了T4的请求，这样有可能T2永远处于等待状态，这就是活锁。 ​ 避免活锁的方法就是采用先来先服务的策略。 死锁​ 如果事务T1封锁了数据R1，事务T2封锁了数据R2，然后事务T1又请求封锁数据R2，因为T2已经封锁了R2，所以T1等事务T2释放数据R2上的锁。接着T2又请求封锁数据R1，由于T1已经封锁了R1，所以T2又等T1释放R1上的锁。这样就出现了T1等待T2，而T2有等待T1的现象，T1和T2两个事务永远无法结束，形成死锁。 死锁的预防 一次封锁法 要求每个事务一次性将所有要使用的数据全部加锁，否则不能继续进行。 顺序封锁法 死锁的诊断和预防 超时法 如果事务的等待时间超过了规定的时限，就认为发生了死锁。 等待图法 若T1等待T2，则T1T2之间画一条有向边，从T1指向T2。如果发现图中存在回路，则表示系统中出现了死锁。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构知识点]]></title>
    <url>%2F2017%2F01%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[9.查找折半查找(已排好序)平均查找长度ASL=log2(n+1)-1 顺序表查找平均查找长度（n+1）/2 二叉排序树（二叉搜索树、二叉查找树） 若它的左子树不为空，则左子树上的所用结点的值都小于它的根节点的值 若它的又子数不为空，则又子树上的所有结点的值都大于他的根节点的值 他的左右子树也分别为二叉排序树。 按中序遍历二叉排序树得到的一定是一个递增序列。 平衡二叉树（AVL数）（查找时间复杂度O(logn)） 要么是空树 它的左子树和右子树都是平衡二叉树，且左子树和右 子树的深度之差的绝对值不超过1 平衡因子：该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上的所有结点的平衡因子只能是-1、1、0 B-树主要用作文件的索引 一棵 m 阶的B-树，或为空树，或为满足下列特性的m叉树： 所有非叶结点均至少含有⎡m/2⎤棵子树，至多含有 m 棵子树； 根结点或为叶子结点，或至少含有两棵子树； 所有非终端结点含有下列信息数据： （n，A0，K1，A1，K2，A2，…Kn，An） 其中：K**i为关键字，且均自小至大有序排列，即：K1&lt; K2&lt; … &lt; Kn ； Ai为指向子树根结点的指针，且指针Ai-1所指子树上所有关键字均小于Ki ； An 所指子树上所有关键字均大于Kn ； 树中所有叶子结点均不带信息，且在树中的同一层次上； B+树适用于文件系统，适合顺序查找和随机查找。 哈希表处理冲突的方法 开放地址法 Hi=(H(key)+di)mod m 线性探测再散列：di=1,2,3,4…… 二次探测再散列：di=1^2,-1^2,2^2,-2^2 …… 伪随机探测在散列：di=伪随机数 再哈希法 链接地址法 建立一个公共溢出区 10.排序 插入排序12345678910void InsertionSort ( SqList &amp;L ) &#123; // 对顺序表 L 作直接插入排序。 for ( i=2; i&lt;=L.length; ++i ) if (L.r[i].key &lt; L.r[i-1].key) &#123; L.r[0] = L.r[i]; // 复制为监视哨 for ( j=i-1; L.r[0].key &lt; L.r[j].key; -- j ) L.r[j+1] = L.r[j]; // 记录后移 L.r[j+1] = L.r[0]; // 插入到正确位置 &#125;&#125; // InsertSort 希尔排序 1234567891011121314151617void ShellInsert ( SqList &amp;L, int dk ) &#123;//对顺序表L作一//趟希尔插入排序，dk 为增量 for ( i=dk+1; i&lt;=n; ++i ) if ( L.r[i].key&lt; L.r[i-dk].key) &#123; L.r[0] = L.r[i]; // 暂存在L.r[0] for (j=i-dk; j&gt;0&amp;&amp;(L.r[0].key&lt;L.r[j].key); j-=dk) L.r[j+dk] = L.r[j]; // 记录后移，查找插入位置 L.r[j+dk] = L.r[0]; // 插入 &#125; // if&#125; // ShellInsertvoid ShellSort (SqList &amp;L, int dlta[], int t)&#123; // 按增量序列dlta[0..t-1]对顺序表L作希尔排序 for (k=0; k&lt;t; ++t) ShellInsert(L, dlta[k]); //一趟增量为dlta[k]的插入排序&#125; // ShellSort 堆排序堆： 根都大于等于左右子树 或者 根都小于等于左右子树 ki&lt;=K(2i) and Ki&lt;=K(2i+1) ===&gt;小顶堆 ki&gt;=K(2i) and Ki&gt;=K(2i+1) ===&gt;大顶堆 ​ 样例输入：{49，38，65，97，76，13，27，49} ​ 创建初始堆 ​ 输出堆顶后创建新堆的过程 6.树和二叉树定义结点:数据元素及若干指向其子树的分支 结点的度:结点拥有的子树的数目 树的度:树中所有结点的度的最大值 叶子结点:度为零的结点 分支结点:度不为零的结点 孩子：结点子树的根节点称为该节点的孩子结点 双亲：该节点称为子树孩子的双亲 双亲：同一个双亲的孩子之间称为兄弟 祖先：从根节点到该节点所经分支上的所有结点 层次：从根开始定义，根为第一层，根的孩子为第二层 堂兄弟：其双亲在同一层的结点互为堂兄弟 树的深度：树中结点的最大层次称为树的深度或高度 二叉树定义：二叉树或为空树，或是由一个根结点加上两棵分别称为左子树和右子树的、互不交的二叉树组成。 二叉树的性质 在二叉树的第i层上最多有2^(i-1)个结点 深度为k的二叉树上最多含2^k - 1个结点 对任何一棵二叉树，若它含有n0 个叶子结点、n2 个度为 2的结点，则必存在关系式：n0 = n2+1。 二叉树的度数+1=二叉树的结点树 满二叉树：指的是深度为k且含有2^k-1个结点的二叉树。 完全二叉树：树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应。 ​ 完全二叉树 ​ 满二叉树 二叉树遍历 先根遍历：根左右 中序遍历：左根右 后续遍历：左右根 已知先序遍历和中序遍历可求出后序遍历，已知后序遍历和中序遍历可求出先序遍历 已知先序遍历和后序遍历不能求出先序遍历 二叉树遍历算法12345678910111213Status PreOrderTraverse( BiTreee T, Status ( * Visit)(TElemType e) ) &#123; //采用二叉链表存储结构， Visit是对数据元素操作的应用//函数，先序遍历二叉树T的递归算法，对每个数据元素调用//函数Visit。最简单的Visit函数是： // Status PrintElement(TElemType e)&#123; //输出元素e的值 // printf( e ); //实用时，加上格式串 // return OK; // &#125; //调用实例： PreOrderTraverse( T, PrintElement);if (T) &#123; if (Visit(T-&gt;data )) if (PreOrderTraverse(T-&gt;lchild, Visit)) if (PreOrderTraverse(T-&gt;rchild, Visit)) return OK; return ERROR; &#125;else return OK;&#125;// PreOrderTraverse 统计叶子结点个数12345678void CountLeaf (BiTree T, int&amp; count)&#123; if ( T ) &#123; if ((!T-&gt;lchild)&amp;&amp; (!T-&gt;rchild)) count++; // 对叶子结点计数 CountLeaf( T-&gt;lchild, count); CountLeaf( T-&gt;rchild, count); &#125; // if&#125; // CountLeaf 计算二叉树的深度12345678910int Depth (BiTree T )&#123; // 返回二叉树的深度 if ( !T ) depthval = 0; else &#123; depthLeft = Depth( T-&gt;lchild ); depthRight= Depth( T-&gt;rchild ); depthval = 1 + (depthLeft &gt; depthRight ? depthLeft : depthRight); &#125; return depthval;&#125; 表达式与二叉树之间的关系 线索二叉树定义：线索二叉树就是在二叉树链表结构中添加两个标志位，LTag、RTag. LTag=0时，Lchild指针指向其左孩子，LTag=1时，Lchild指针指向其前驱 RTag=0时，Rchild指针指向其右孩子 RTag=1时，Rchild指针指向其后继 线索化：以某种次序遍历使其变为线索二叉树的过程称为线索话。 树和森林树的存储结构孩子兄弟表示法：以二叉链表作为树的存储结构，链表中的两个链域分别指向该节点的第一个孩子结点和下一个兄弟结点。 森林和二叉树的转化 ​ 森林和二叉树转换采用孩子兄弟表示法，每棵树的根节点看作是兄弟。 ​ 二叉树转换成森林，从根节点出发，每个右结点分支断开，即做分支变成树。即AE之间断开，EG之间断开 哈夫曼树（最优二叉树）定义路径长度：从树中的一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称为路径长度。 树的路径长度：是指从树的根到每一个结点的路径长度之和。 结点的带权路径长度：是该结点到树根之间的路径长度与结点上权的乘积。 树的带权路径长度：是树中所有叶子结点的带权路径长度之和 哈夫曼树：带权路径长度最小的二叉树称为哈夫曼树 ​ 带权路径介绍 构造哈夫曼树 结点带权值和编号集合依次排开，选取权值最小的两个结点构造一颗二叉树，根节点为两个结点权值之和。两个结点分别为左右子树，并且子树权值大于右子树权值或者相反，但是每次得保持一致。 将上面两个结点和放入集合中，并且将两个结点从集合中移除。 重复第一个步骤。当集合中只剩一个结点时结束。 7、图定义图：图是由一个顶点集 V 和一个弧集 R构成的数据结构 \表示从 v 到 w 的一条弧，并称 v 为弧尾，w 为弧头。 假设图中有 n 个顶点，e 条边，则 含有 e=n(n-1)/2 条边的无向图称作完全图； 含有 e=n(n-1) 条弧的有向图称作 有向完全图； 若边或弧的个数 e&lt;nlogn，则称作稀疏图，否则称作稠密图。 假若顶点v 和顶点w 之间存在一条边，则称顶点v 和w 互为邻接点， 边(v,w)** 和顶点v 和w 相关联**。 度：和顶点v 关联的边的数目定义为顶点v的度。 有向图中： 顶点的出度：以顶点v为弧尾的弧的数目； 顶点的入度：以顶点v为弧头的弧的数目。 顶点的度(TD)=出度(OD)+入度(ID)。 路径长度：路径长度是指路径上的边或弧的数目 回路或环：第一个顶点和最后一个顶点相同的路径称为环或回路 简单路劲：序列顶点不重复出现的路径称为简单路径 简单环或简单回路：除了第一个和最后一个顶点外，其余的顶点不重复出现的回路称为简单回路或简单环 无向图中 连通图：对于图中的任意两个顶点都是连通的，称这个图是连通图 连通分量：无向图中的极大连通子图 有向图中 强连通图 ：对于图中每一对顶点vi和vj,从vi到vj和从vj到vi都存在路径，则称图是强连通图 强连通分量：有向图中的极大强连通子图 图的存储数组表示法（邻接矩阵法） 无向图的邻接矩阵一定是对称矩阵，而有向图的邻接矩阵则不一定为非对称矩阵 . 邻接表 ​ 无向图的邻接矩阵 ​ 有向图的邻接矩阵 图的遍历深度优先搜索​ 从图中某个顶点V0 出发，访问此顶点，然后依次从V0的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和V0有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直到图中所有顶点都被访问到为止。 ​ 访问次序：v1—&gt;v2—&gt;v4—&gt;v8—&gt;v5—&gt;v3—&gt;v6—&gt;v7 深度优先算法：定义一个数组存放顶点是否被访问 12345678910111213141516void DFSTraverse(Graph G, Status (*Visit)(int v)) &#123; // 对图 G 作深度优先遍历。 VisitFunc = Visit; for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; // 访问标志数组初始化 for (v=0; v&lt;G.vexnum; ++v) if (!visited[v]) DFS(G, v); // 对尚未访问的顶点调用DFS&#125;void DFS(Graph G, int v) &#123; // 从顶点v出发，深度优先遍历图 G visited[v] = TRUE; VisitFunc(v);//访问第v个顶点 for(w=FirstAdjVex(G, v); w&gt;=0; w=NextAdjVex(G,v,w)) if (!visited[w]) DFS(G, w); // 对v的尚未访问的邻接顶点w， 递归调用DFS&#125; // DFS 广度优先搜索遍历类似于树的层次遍历 从图中的某个顶点V0出发，并在访问此顶点之后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访到。 若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 ​ 广度优先搜索：V1—&gt;V2—&gt;V3—&gt;V4—&gt;V5—&gt;V6—&gt;V7—&gt;V8. 123456789101112131415161718192021222324void BFSTraverse(Graph G, Status (*Visit)(int v))&#123; //按广度优先非递归遍历图G，使用辅助队列Q和//访问标志数组visited for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; //初始化访问标志 InitQueue(Q); // 置空的辅助队列Q for ( v=0; v&lt;G.vexnum; ++v ) if ( !visited[v]) // v 尚未访问 &#123; visited[v] = TRUE; Visit(v); // 访问v EnQueue(Q, v); // v入队列 while (!QueueEmpty(Q)) &#123; DeQueue(Q, u); // 队头元素出队并置为u for(w=FirstAdjVex(G, u); w&gt;=0;w=NextAdjVex(G,u,w)) if ( ! visited[w]) &#123; //W为u的尚未访问的邻接顶点 visited[w]=TRUE; Visit(w); EnQueue(Q, w); // 访问的顶点w入队列 &#125; // if &#125; // while &#125; &#125; // BFSTraverse 最小生成树最小生成树：构造网的一棵最小生成树，即：在 e 条带权的边中选取 n-1 条边（不构成回路），使“权值之和”为最小 普里姆算法取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n-1 条边为止。 算法的时间复杂度是O(n^2),与网中的边数无关，因此适合求边稠密的网的最小生成树 克鲁斯卡算法先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止。 算法的时间复杂度O(eloge),e为边的数目，适用于稀疏图。 有向无环图的应用有向无环图：一个无环的有向图称为有向无环图。简称（DAG） 拓扑排序定义：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序 所谓偏序关系就是如果A–&gt;B成立 ， 但是从B–&gt;A 不成立 从有向图中选取一个没有前驱的顶点，并输出之； 从有向图中删去此顶点以及所有以它为尾的弧； 重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。后一种情况说明有向图中存在环。 关键路径路径长度最长的路径就是关键路径。 最早发生时间：从v1到vi的最长路径长度叫做事件vi的最早发生时间 最迟发生时间：在不推迟项目进度的情况下，最晚发生的时间。 关键活动：最早发生时间和最迟发生时间相同的活动叫做关键活动。 关键路径上的活动都是关键活动 最短路径从某个顶点到其余各个顶点的最短路径。（迪杰斯特拉算法）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>查找</tag>
        <tag>二叉树</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法]]></title>
    <url>%2F2017%2F01%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、冒泡排序3, 1, 8, -4, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, 8, -4, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, 8, -4, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 9, 20, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 9, 2, 20, 0, 12, 4, 7, 6 1, 3, -4, 8, 9, 2, 0,20, 12, 4, 7, 6 1, 3, -4, 8, 9, 2, 0, 12,20, 4, 7, 6 1, 3, -4, 8, 9, 2, 0, 12, 4,20, 7, 6 1, 3, -4, 8, 9, 2, 0, 12, 4, 7,20, 6 1, 3, -4, 8, 9, 2, 0, 12, 4, 7, 6,20 这是一趟比较，每次比较两个前后两个数，前面的大则向后移动 1234567891011121314151617public static void bubbleSort(int[] arr)&#123; int len = arr.length; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 2、插入排序方法一：从第二个元素开始，将元素arr[i]插入前面排好序的数组中。首先找到arr[i]在0——(i-1)这些元素中的位置j，然后将(j+1)到(i-1)中的元素往后移动一位，最后将arr[i]插入arr[j]中。 123456789101112131415161718public static void insertSort(int[] arr)&#123; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; int j = 0; //找到元素arr[i]要插入的位置j while (j &lt; i &amp;&amp; arr[j] &lt; arr[i]) j++; int temp = arr[i]; //将数组元素 j到 i-1 的元素向后移动一位 for (int n = i - 1; n &gt;= j; n--) arr[n + 1] = arr[n]; //将arr[i]元素插入位置j arr[j] = temp; &#125; System.out.println(Arrays.toString(arr));&#125; 方法二：从第二元素开始，将元素arr[i]插入前面已经排好序的序列中。定义下标j,j 从(i-1)出发，如果arr[j] 大于arr[i],则将arr[j]向后移动一位，否则跳出循环 12345678910111213141516public static void insertSort(int[] arr)&#123; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; int temp = arr[i]; int j = i - 1; //从i-1开始，把大于arr[i]的元素全部向后移动一位 while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + 1] = arr[j]; j--; &#125; arr[++j] = temp; &#125;&#125; 3. 希尔排序将数组分成dk个增量序列(i,i+dk*1,i+dk*2,i+dk*3,……i+dk*n)，将这dk个序列排序，每个增量序列中用插入排序方法将其进行排序。 12345678910111213141516171819202122232425262728public static void shellSort(int[] arr)&#123; int[] dk = &#123; 7, 5, 3, 1 &#125;; for (int i = 0; i &lt; dk.length; i++) &#123; if (dk[i] &lt; arr.length) shellInsert(arr, dk[i]); &#125;&#125;public static void shellInsert(int[] arr, int dk)&#123; //对dk个序列进行排序 for (int n = 0; n &lt; dk; n++) &#123; //对其中的一个序列进行插入排序 for (int i = dk + n; i &lt; arr.length; i += dk) &#123; int temp = arr[i]; int j = i - dk; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + dk] = arr[j]; j -= dk; &#125; arr[j + dk] = temp; &#125; &#125;&#125; 4. 简单选择排序假设数组长度为n，对数组进行n-1趟操作，每次在i到n元素中选择最小的元素与arr[i]进行交换 1234567891011121314151617181920public static void simpleSelectSort(int[] arr)&#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 从i到n中选择最小的元素 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) min = j; &#125; //如果最小元素下标不是i则进行交换 if (min != i) &#123; int temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 5. 快速排序1234567891011121314151617181920212223242526272829303132//递归方法public static void quickSort(int[] arr, int low, int high)&#123; if (low &lt; high) &#123; int index = partition(arr, low, high); quickSort(arr, low, index - 1); quickSort(arr, index + 1, high); &#125;&#125;public static int partition(int[] arr, int low, int high)&#123; //以第一个元素作为轴 int key = low; int value = arr[low]; while (low &lt; high) &#123; //从高位开始找第一个比key小的数 while (high &gt; low &amp;&amp; arr[high] &gt;= value) high--; //将高位第一个比key小的数与low位置交换 arr[low] = arr[high]; //从低位开始找第一个比key大的数 while (low &lt; high &amp;&amp; arr[low] &lt;= value) low++; //将低位第一个比key大的数与high位置交换 arr[high] = arr[low]; &#125; arr[low] = value; return low;&#125; 快速排序非递归方法1234567891011121314151617181920public static void quickSort1(int[] arr)&#123; LinkedList&lt;Integer&gt; lowQueue = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; highQueue = new LinkedList&lt;&gt;(); lowQueue.add(0); highQueue.add(arr.length - 1); while (!lowQueue.isEmpty()) &#123; int low = lowQueue.pop(); int high = highQueue.pop(); if (low &lt; high) &#123; int index = partition(arr, low, high); lowQueue.add(low); highQueue.add(index - 1); lowQueue.add(index + 1); highQueue.add(high); &#125; &#125;&#125; 6. 堆排序12345678910111213141516171819202122232425262728293031323334353637public static void heapAdjust(int[] arr, int s, int end)&#123; //以结点rc作为堆顶构造极大堆 int rc = arr[s]; for (int j = 2 * s + 1; j &lt;= end; j = j * 2 + 1) &#123; //判断两个叶子结点哪个大，j表示下标大的结点 if (j + 1 &lt;= end &amp;&amp; arr[j] &lt; arr[j + 1]) j++; //如果父节点大于两个叶子结点则直接跳出 if (rc &gt;= arr[j]) break; //将大的叶子结点上移到父节点 arr[s] = arr[j]; //接下来以j为父节点，构造极大堆 s = j; &#125; //初始结点要插入的位置 arr[s] = rc;&#125;public static void heapSort(int[] arr)&#123; int len = arr.length; // 构建极大堆 for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; //从最后一个非叶子结点开始一直往前，以这些非叶子结点构造极大堆 heapAdjust(arr, i, arr.length - 1); &#125; //将堆顶的最大元素放到队列尾部 for (int i = 0; i &lt; len; i++) &#123; int temp = arr[0]; arr[0] = arr[len - 1 - i]; arr[len - 1 - i] = temp; heapAdjust(arr, 0, len - i - 2); &#125;&#125; 7.2路 归并排序1234567891011121314151617181920212223242526272829303132333435363738public static void mergeSort(int[] arr, int start, int end) &#123; if (start &lt; end) &#123; int middle = (start + end) / 2; mergeSort(arr, start, middle); mergeSort(arr, middle + 1, end); merge(arr, start, middle, end); &#125; &#125; //合并两个有序的数组 数组1：start——middle 数组2：middle+1——end public static void merge(int[] arr, int start, int middle, int end) &#123; int low = start; int high = middle + 1; int[] tempArr = new int[end - start + 1]; int index = 0; while (low &lt;= middle &amp;&amp; high &lt;= end) &#123; //两个数组中较小的元素放入tempArr中 if (arr[low] &lt; arr[high]) tempArr[index] = arr[low++]; else tempArr[index] = arr[high++]; index++; &#125; //如果数组1中元素未放入完全，则将数组1剩余元素放入tempArr中 if (low &lt;= middle) for (; low &lt;= middle; low++, index++) tempArr[index] = arr[low]; else for (; high &lt;= end; high++, index++) tempArr[index] = arr[high]; //将两个排好序的数组元素放入 原先数组中 for (int i = 0; i &lt; tempArr.length; i++) arr[start + i] = tempArr[i]; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>