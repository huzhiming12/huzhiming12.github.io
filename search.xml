<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F13%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F%E4%B8%AA%E4%BA%BA%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[个人面经CVTE一面 个人介绍 springMVC拦截器和过滤器的区别 excel导出功能如何实现 SpringIOC和AOP，动态代理实现方式 自动装配有哪几种方式，自动装配有什么局限性 数据库引擎，Innodb,MyISAM的区别 索引实现方式，B+树有什么特点，B树和B+数的区别，B+树的实现方式 索引的最左配原则 HashMap和HashSet的区别，HashMap是有序的吗 LinkedHashMap，保证什么有序，底层实现。 java多线程的方式，FutureTask CallAble介绍，CallAble和Runnable的区别 线程池 类的加载过程，双亲委派机制 CVTE 二面 介绍项目 为什么要用Hibernate，Hibernate和mybatis的区别，各自使用场景。 Hibernate的三态（临时态、持久态、游离态）。 为什么要设计抢购系统 redis和MenCache的区别 redis持久化 redis如何学习 设计模式，用过哪些设计模式 单例有哪些实现方式 volatile关键字，功能 写代码，斐波那契数列的实现。写的是递归，然后问了这个写法有什么优缺点吗。其他方式实现。 职业规划，你期待的是什么工作。 怎么看待业务和编码。 怎么看待业务需求变化和代码的重复修改]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql主从复制配置]]></title>
    <url>%2F2017%2F07%2F30%2F%E6%9E%B6%E6%9E%84%2Fmysql%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[数据库安装12sudo apt-get update //更新系统sudo apt-get install mysql-server //安装MySQL，中间会让输入密码 安装完成之后，设置数据库的远程访问权限： 1GRANT ALL PRIVILEGES ON *.* TO'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; 其中root是用户名，123456是密码，‘%’表示所有IP都能访问。 最后如果远程连接出现：MySQL远程连接ERROR 2003 (HY000):Can’t connect to MySQL server on’XXXXX’(111) 之类的问题。 解决方法：修改云主机上的/etc/mysql/my.cnf 文件，注释掉 bind_address=127.0.0.1。这句ok。 注：如果mysql.cnf 中没有bind_address,则在etc/mysql/mysql.conf.d/mysqld.cnf中 修改主库的配置文件1sudo vim /etc/mysql/my.cnf 添加如下内容： 1234567[mysqld]##[必须]启用二进制日志log-bin=mysql-bin ###[必须]服务器唯一ID，默认是1，一般取IP最后一段server-id=222 #指定同步的数据库，如果不指定则同步全部数据库binlog-do-db=seckill 修改从库的配置文件123[mysqld]log-bin=mysql-bin //[不是必须]启用二进制日志server-id=226 //[必须]服务器唯一ID，默认是1，一般取IP最后一段 重启两台MySQL1service mysql restart 在master服务器上创建账户并授权1GRANT REPLICATION SLAVE ON *.* to &apos;user&apos;@&apos;%&apos; identified by &apos;123456&apos;; //一般不用root帐号，&apos;%&apos;表示所有客户端都可能连，只要帐号，密码正确，此处可用具体客户端IP代替，如192.168.145.226，加强安全。 在主服务器中查询master状态1234567mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000002 | 1372 | secondkill | | |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec) 这里需要记住| mysql-bin.000002 | 1372 | 这两个参数 配置从服务器123mysql&gt;change master to master_host=&apos;192.168.145.222&apos;,master_user=&apos;mysync&apos;,master_password=&apos;q123456&apos;, master_log_file=&apos;mysql-bin.000002&apos;,master_log_pos=1372; //注意不要断开，308数字前后无单引号。mysql&gt;start slave; //启动从服务器复制功能 查看从服务器状态123456789101112131415mysql&gt; show slave status\G;*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 120.77.87.222 Master_User: slave1 Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000002 Read_Master_Log_Pos: 1372 Relay_Log_File: VM-58-249-ubuntu-relay-bin.000004 Relay_Log_Pos: 597 Relay_Master_Log_File: mysql-bin.000002 Slave_IO_Running: Yes #这两个状态必须是Yes Slave_SQL_Running: Yes …………………… Slave_IO及Slave_SQL进程必须正常运行，即YES状态，否则都是错误的状态(如：其中一个NO均属错误)。]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[红黑树的实现原理]]></title>
    <url>%2F2017%2F07%2F19%2Fjava%2Fblog%2F%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[红黑树的性质 根节点是黑色的 红黑树中只有红色结点和黑色结点 叶子结点时黑色的 从根节点到叶子节点之间的路径上不能出现连续两个红色结点 从任意结点到叶子结点的路径上黑色结点个数相同。 红黑树的基本操作：左旋、右旋左旋​ 以根节点A作为基点进行左旋： ​ 左旋效果图 右旋​ 以根节点A作为基点进行右旋： ​ 右旋效果图 红黑树结点添加​ 红黑树添加新节点，必须将新加结点设成红色，因为这样能够保证从任一点到其叶子结点的路径黑色结点个数相同。因此添加新节点可能会违背红黑树的性质1和性质4，故需对其进行旋转和着色操作。具体操作分为以下几点 1. 添加结点为根结点​ 操作：直接将当前结点置成黑色即可 2.黑父​ 操作：这种情况下红黑树的性质没有发生变化，不用改变 3.红父红父红叔​ 当前结点的父亲结点和叔叔结点都是红色，此时只需将父亲结点和叔叔结点设成黑色，祖父结点设成红色。然后将祖父结点设成当前结点，循环进行操作 如图，新插入结点12，其父亲结点15和叔叔结点42都是红色的。因此将父亲结点和叔叔结点设成黑色，将祖父结点36设成红色。接着讲祖父结点36设成当前结点，进行循环操作 红父黑叔 LL型红父黑叔 当父亲结点在祖父结点的左侧，且当前结点也在父亲结点的左侧，即是LL型的结构。 具体操作： 将父亲结点设成黑色 将祖父结点设成红色 以祖父结点为支点进行左旋操作 把父亲结点设成当前结点进行循环操作。 如图新插入结点12，父亲结点15是红色，叔叔结点是黑色。先着色，然后左旋 ​ LR型红父黑叔 当父亲结点在祖父结点的左侧，且当前结点也在父亲结点的右侧，即是LR型的结构。 具体操作如下： 将父亲结点设成当前结点 以新的当前结点为支点进行左旋，将LR型结构编程LL型结构 以新的当前结点进行循环操作（后面是按LL型进行变换） ​ RR型红父黑叔 当父亲结点在祖父结点的右侧，且当前结点也在父亲结点的右侧，即RR型结构。 具体操作如下： 将父亲结点设成黑色 将祖父结点设成红色 以祖父结点为支点进行左旋操作 将父亲结点设成当前结点，然后进行循环操作 ​ ​如图，先对父节点和祖父结点着色，父亲结点40设成黑色，祖父结点36设成红色。接着以36为支点进行，进 行左旋操作。 RL型红父黑叔 当父亲结点在祖父结点的右侧，且当前结点在父亲结点的左侧，即RL型结构。 具体操作如下： 将父亲结点设为当前结点 以新的当前结点为支点进行右旋操作 以新的当前结点为进行循环操作（后面是按RR型进行操作） 下面是添加结点的一个过程： 红黑树结点删除]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu Nginx+Tomcat负载均衡配置]]></title>
    <url>%2F2017%2F07%2F18%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2FUbuntu%20Nginx%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Tomcat安装与配置 官网下载Tomcat，解压，复制两份。因为是在一台主机上模拟，所以主机上需要有多个Tomcat。 配置修改Tomcat的配置文件：apache-tomcat/conf/server.xml，主要修改下面三处的端口号，防止两个Tomcat使用端口冲突。注意：两个Tomcat中端口不能重复 1234567&lt;Server port="65004" shutdown="SHUTDOWN"&gt;&lt;Connector port="65005" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="65006" protocol="AJP/1.3" redirectPort="8443" /&gt; 配置Tomcat的 JDK路径，在文件apache-tomcat/bin/catalina.sh中添加下面配置 123CATALINA_HOME=/root/apache-tomcat-7 #tomcat的路劲JAVA_HOME=/root/java/jdk1.7 #JDK安装路劲JRE_HOME=/root/java/jdk1.7/jre #jre路径 测试Tomcat，进入apache-tomcat/bin/文件目录下执行 1sudo ./startup.sh 在浏览器中输入localhost:65005 能显示出Tomcat主页，说明配置成功。 Nginx的安装与配置 安装命令 1sudo apt-get install nginx 如果安装不成功，可能是缺少依赖，将缺少的依赖安装即可。 Nginx的启动 1nginx #直接输入nginx 就能启动 Nginx的关闭 123从容停止 : Kill -QUIT 13421 快速停止 : kill -TERM 13421 或 kill -INT 13421 强制停止 : pkill -9 nginx ngnix 配置，修改配置文件/etc/ngnix/nginx.conf 进程数与每个进程的最大连接数 1234567#工作进程个数，一般跟服务器cpu核数相等，或者核数的两倍worker_processes 2;#单个进程最大连接数events&#123; worker_connections 1024; &#125; nginx进程数，建议设置为和服务器cup核数相等，或者是核数的两倍 单个进程最大连接数，该服务器的最大连接数=连接数进程数； 服务器支持最大并发数=(连接数进程数) /2 ，因为反向代理是双向的。 Nginx的基本配置 12345#nginx基本配置server&#123; listen 8088; #端口号 server_name 192.168.22.227; #服务名&#125; 监听端口一般都为http端口：80;可以修改为其他，这里修改为8088。 server_name ：默认为localhost ，这里修改为服务器ip地址。 负载均衡列表基本配置 12345678910111213141516171819 #服务器集群 upstream zyhzm.me&#123; #这里添加的是上面启动好的两台Tomcat服务器 server 192.168.22.229:8080 weight=1; server 192.168.22.230:8080 weight=1; &#125;location /&#123; #将访问请求转向至服务器集群,zyhzm.me和上面upstream zyhzm.me 对应 proxy_pass http://zyhzm.me; # 真实的客户端IP proxy_set_header X-Real-IP $remote_addr; # 请求头中Host信息 proxy_set_header Host $host; # 代理路由信息，此处取IP有安全隐患 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 真实的用户访问协议 proxy_set_header X-Forwarded-Proto $scheme; &#125; ​ 完整的配置文件示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445user nobody;#工作进程个数，一般跟服务器cpu核数相等，或者核数的两倍worker_processes 2;#单个进程最大连接数events&#123; worker_connections 1024; &#125;http&#123; keepalive_timeout 65; gzip on; #服务器集群 upstream mycluster&#123; #集群有几台服务器即可配置几台，weight表示权重，权重越大被访问到的几率越大 #这里添加的是上面启动好的两台Tomcat服务器 server 192.168.22.229:8080 weight=1; server 192.168.22.230:8080 weight=1; &#125; #nginx基本配置 server&#123; listen 8088; #端口号 server_name 192.168.22.227; #服务名 location /&#123; #将访问请求转向至服务器集群,mycluster和上面upstream mycluster 对应 proxy_pass http://mycluster; # 真实的客户端IP proxy_set_header X-Real-IP $remote_addr; # 请求头中Host信息 proxy_set_header Host $host; # 代理路由信息，此处取IP有安全隐患 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 真实的用户访问协议 proxy_set_header X-Forwarded-Proto $scheme; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125;]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F07%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[整理一下计算机网络部分的面试常考点，参考书籍：《计算机网络》第五版 谢希仁的那本，希望对大家有所帮助 OSI，TCP/IP，五层协议的体系结构，以及各层协议 OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。 每一层的协议如下： 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关） 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机） 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） IP地址的分类 A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）； B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）； C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）； 10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部） IP地址与子网掩码相与得到主机号 ARP是地址解析协议，简单语言解释一下工作原理。 1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。 3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。 各种协议 ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术， DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 描述：RARP RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 TCP三次握手和四次挥手的全过程 三次握手： 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次握手 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 在浏览器中输入www.baidu.com后执行的全部过程 1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 TCP和UDP的区别？ TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。 TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。 TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 TCP对应的协议和UDP对应的协议 TCP对应的协议： （1） FTP：定义了文件传输协议，使用21端口。 （2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 （3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 （4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。 （5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。 UDP对应的协议： （1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 （2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 （3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 DNS域名系统，简单描述其工作原理。 当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。 面向连接和非面向连接的服务的特点是什么？ 面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。 ​ 非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。 TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？ 答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 （1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 （2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 （3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 端口及对应的服务？ 服务 端口号 服务 端口号 FTP 21 SSH 22 telnet 23 SMTP 25 Domain(域名服务器) 53 HTTP 80 POP3 110 NTP（网络时间协议） 123 MySQL数据库服务 3306 Shell或 cmd 514 POP-2 109 SQL Server 1433 IP数据包的格式 IP数据报由首部 和数据 两部分组成。首部由固定部分和可选部分 组成。首部的固定部分有**20**字节。可选部分的长度变化范围为1——40字节。固定部分的字段： 字段名 位数（bit） 字段名 位数 版本 4 Ipv4 首部长度 4（表示的最大数为15个单位，一个单位表示4字节） 服务类型 8 以前很少用 总长度 16 （首部和数据部分的总长度，因此数据报的最大长度为65535字节，即64KB，但是由于链路层的MAC都有一定的最大传输单元，因此IP数据报的长度一般都不会有理论上的那么大，如果超出了MAC的最大单元就会进行分片） 标识 16 （相同的标识使得分片后的数据报片能正确的重装成原来的数据报） 标志 3 （最低位MF=1表示后面还有分片，MF=0表示这是若干个数据报片的最后一个中间位DF=0才允许分片） 片偏移 片偏移指出较长的分组在分片后，某片在原分组中的相对位置，都是8字节的偏移位置 生存时间 数据报在网络中的生存时间，指最多经过路由器的跳数 协议 8 （指出该数据报携带的数据是何种协议，以使得目的主机的IP层知道应将数据部分上交给哪个处理程序）如ICMP=1 IGMP=2 TCP=6 EGP=8 IGP=9 UDP=17 Ipv6=41 OSPF=89 首部校验和 这个部分只校验首部，不包括数据部分，计算方法：将首部划分为多个16位的部分，然后每个16位部分取反，然后计算和，再将和取反放到首部校验和。接收方收到后按同样的方法划分，取反，求和，在取反，如果结果为零，则接收，否则就丢弃 源地址 32 目的地址 32 TCP数据报的格式？ 源端口 目的端口 序号 确认序号 数据偏移 保留 URG ACK PSH RST SYN FIN 窗口 检验和 紧急指针 选项和填充 数据 一个TCP报文段分为首部和数据两部分。首部由固定部分和选项部分组成，固定部分是20字节。TCP首部的最大长度为60。首部固定部分字段： 字段名 字节（Byte） 字段名 字节（Byte） 源端口 2 目的端口 2 序号 4 确认号 4，是期望收到对方的下一个报文段的数据的第一个字节的序号 数据偏移 4bit 指出TCP报文段的数据起始处距离TCP报文段的起始有多远 保留 6bit 紧急比特URG 确认比特ACK 只有当ACK=1时，确认号字段才有效 推送比特PSH 复位比特RST 同步比特SYN 终止比特FIN 窗口 2 检验和 2 （包括首部和数据两部分，同时还要加12字节的伪首部进行校验和计算） 选项 长度可变（范围1——40） TCP的12字节伪首部： 源IP地址（4） 目的IP地址（4） 0 (1) 6(1) 代表这是TCP，IP协议中提到过 TCP长度（2） TCP数据报的格式？ 用户数据报UDP由首部和数据部分组成。首部只有8个字节，由4个字段组成，每个字段都是两个字节。 字段名 字节 字段名 字节 源端口 2 目的端口 2 长度 2 检验和 2 （检验首部和数据，加12字节的伪首部） UDP的12字节伪首部： 源IP地址（4） 目的IP地址（4） 0 (1) 17(1) 代表这是UDP UDP长度（2） 以太网MAC帧格式？ 前导码 前定界符 目的地址 源目的地址 长度字段 数据字段 校验字段 7B 1B 6B 6B 2B 46-1500 4B 了解交换机、路由器、网关的概念，并知道各自的用途1）交换机 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。 交换机被广泛应用于二层网络交换，俗称“二层交换机”。 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。 2）路由器 路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 3）网关 网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。 对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。 原文地址：http://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F07%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E8%AE%A1%E7%BD%915%E5%B1%82%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据链路层数据链路层是网络的底层，主要使用两种信道：点对点信道、广播信道 点对点信道三个基本问题 封装成帧 在数据前后添加首部和尾部，数据报： SOH数据部分EOT 透明传输 如果数据部分也出现SOH或者EOT，则在其前面添加转义字符ESC；如果数据中本身有ESC，则再加一个ESC。 差错检测 循环冗余检测 MAC帧格式源地址（6字节）、目的地址（6字节）、类型（2字节）、数据报（46—1500）、FCS帧检验序列（4） 网络层网际协议IP，与之配套使用的三个协议： 地址解析协议（ARP） 网际控制报文协议（ICMP） 网际组管理协议（IGMP） IP地址划分IP地址={网络号，主机号} A类地址：网络号8位且以0开头，主机号24位 0.0.0.0—127.255.255.255 B类地址：网络号16位且以10开头，主机号16位 128.0.0.0—191.255.255.255 C类地址：网络号24位且以110开头，主机号8位 192.0.0.0—223.255.255.255 D类地址：以1110开头，用于多播 224.0.0.0—239.255.255.255 E类地址：以1111开头，保留地址 240.0.0.0—255.255.255.255 ARP协议ARP协议适用于同一局域网上的主机或者路由器的IP地址和硬件地址的映射问题。 每个主机都设有一个ARP高速缓存，里面存放了本局域网中IP地址到Mac地址之间的映射。 主机A通过ARP查找主机B的MAC地址步骤： 如果ARP高速缓存中存在这个IP地址到Map地址的映射，则直接查找Mac地址 如果不存在，则在局域网上广播一个ARP请求，请求内容大致是“我的IP地址是“12.23.121.23，我的Mac地址是00-34-45-23-45-34，我想知道IP地址是23.54.23.45的Mac地址”。 本局域网上的所有主机运行的ARP进程都能收到此ARP请求分组。 主机B发现这个ARP请求的IP地址和自己的相同，就收下这个ARP请求，并向主机A发送ARP相应分组，并在这个响应分组中写入自己的MAC地址，同时将A的IP和MAC地址写入自己的APR高速缓存中。 其他的主机发现IP地址和自己的不一致，因此全都不理睬。 主机A收到响应之后，将B的MAC地址写入高速缓存中。 ARP高速缓存中的每一个映射项目都设置一个生存时间，超过这个时间就将该项目删除。 子网划分IP地址={网络号，子网号，主机号} 子网掩码：将子网掩码与IP地址逐位进行与（and）运算，可立即得出网络地址。 运输层UDP（用户数据报协议） UDP无连接的 最大努力交互，不保证可靠交互 UDP是面向报文的 UDP不使用拥塞控制 UDP支持一对一、一对多、多对一和多对多的交互通信 UDP的首部开销小，只有8个字节 TCP传输控制协议 TCP是面向连接的运输层协议 每一条TCP连接只能有两个端点，每条连接只能是点对点的 TCP是可靠交付服务 TCP提供全双工通信 TCP是面向字节流的 停止等待协议 无差错情况：A向B发送数据M1，B收到M1后，向A发送确认，A收到确认后，就发送下一个分组M2 出现差错：A向B发送分组M1，在传输过程出现差错，B收到后检测数据出错直接丢弃而不做其他任何操作。A过一段时间还没有收到确认报文，就认为前面发送的报文出错了，会重新发送报文M1。这就是超时重传，在每次发送完数据都设置一个超时重传计时器。超时重传的时间应当比数据在分组传输的平均往返时间更长一些。 确认丢失和确认迟到：B发送的对M1的确认丢失了，A在超时计时器到期后会对M1进行重传，B再次收到M1时应进行两步操作，一是丢弃这个数据分组M1，二是想A发送确认报文M1。 这种确认重传机制叫做 自动重传ARQ。 TCP报文首部格式 序号：本报文段发送的数据的第一个字节序号 确认号：是期望下收到对方下一个报文段的第一个数据字节序号 数据偏移：是指TCP报文段的数据起始处距离TCP报文段的起始处多远，即可知道首部的长度。数据偏移最大值15，单位是4字节，故最大偏移是60字节，即首部最长为64字节 URG紧急：URG=1时，表明仅仅指针字段有效 确认ACK：ACK=1时确认号字段才有效 同步SYN：在连接建立时用来同步序号。SYN=1 ACK=0时，表明这是一个连接请求报文段；SYN=1，ACK=1 表明这是一个同意建立连接报文 终止FIN：用来释放一个连接。当FIN=1，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。 窗口：接收窗口的大小。 TCP拥塞控制慢开始和拥塞避免 初始化是拥塞窗口cwnd=1(单位是报文个数)，慢开始门限ssthresh=16 执行慢开始是，cwnd是以指数增大2，4，8……，当大于ssthresh时，采用拥塞避免算法，即每次增加一个。 当出现拥塞时，ssthresh变成当前cwnd的一半，cwnd从1开始，重复2步骤。 快重传和快恢复 初始化是拥塞窗口cwnd=1(单位是报文个数)，慢开始门限ssthresh=16 执行慢开始是，cwnd是以指数增大2，4，8……，当大于ssthresh时，采用拥塞避免算法，即每次增加一个。 当出现拥塞时，ssthresh变成当前cwnd的一半，cwnd从ssthresh开始，每次窗口值加1。 TCP三次握手 SYN=1，ACK=0 表示这是一个建立连接的请求 SYN=1，ACK=1 表示这是一个同意创建连接的报文 （ACK=1时，确认号才有用） 为什么要采用三次握手： 主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。例如：A发送连接请求，但中途丢失，于是又发送一个连接请求，数据发送完毕连接关闭。此时丢失的连接请求又来到B，B误认为A又发送了连接请求，于是向A发送确认报文同意建立连接。此时A不知道建立了连接，因此不理睬A的确认请求；而B建立了连接，浪费了资源 TCP四次挥手 FIN=1 表示数据已经发送完毕，请求关闭连接。 MSL最长报文段寿命，一般建议是2分钟 为什么TIME-WAIT必须等待2MSL？ 保证A发送的最后一个ACK报文段能够到达B 防止已失效的连接请求报文段出现在本连接中。]]></content>
  </entry>
  <entry>
    <title><![CDATA[面经知识点]]></title>
    <url>%2F2017%2F07%2F11%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[作者：Xoper.ducky链接：https://www.nowcoder.com/discuss/3043?type=2&amp;order=0&amp;pos=5&amp;page=2来源：牛客网 J2SE基础 九种基本数据类型的大小，以及他们的封装类。 byte（1）、short（2）、int（4）、long(8)、char(2)、boolean(1)、double（8）、float（4） Switch能否用string做参数？ 可以，可以用除浮点类型以外的任何基本类型，及其封装类型。包括String（JDK1.7及以后支持） equals与==的区别。 如果类中没有重写equals方法，则效果和==一样，Object类中equals方法就是通过==进行判断。String类中对equals方法进行了重写。重写equals方法时，必须重写hashCode方法，否则类似hashMap这种用到hashCode的类将会出现问题。 Object有哪些公用方法？ 123456789101112131415161718192021public final native Class&lt;?&gt; getClass();//返回hashCodepublic native int hashCode();//判断是否相等public boolean equals(Object obj) &#123;return (this == obj);&#125;//克隆方法protected native Object clone() throws CloneNotSupportedException;//hashCode十六进制打印public String toString() &#123;return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125;//唤醒通过wait函数阻塞的线程public final native void notify();//唤醒所有通过wait函数阻塞的线程public final native void notifyAll();//阻塞线程public final native void wait(long timeout) throws InterruptedException;public final void wait(long timeout, int nanos) throws InterruptedException&#123;……&#125;public final void wait() throws InterruptedException&#123;wait(0);&#125;//垃圾回收时调用此方法，必须重写这个方法垃圾回收时才会调用，但是重写之后不一定会调用protected void finalize() throws Throwable &#123; &#125; Java的四种引用，强弱软虚，用到的场景。 强引用：一般使用的都是强引用，JVM宁愿报OutOfMemory异常也不会进行垃圾回收 软引用：当JVM内存快溢出时会进行垃圾回收 弱引用：JVM垃圾收集器以扫描到就会进行垃圾回收，不管内存是否充足都会进行回收 虚引用：虚引用不会决定对象的生命周期，通过get方法永远都无法获取其引用值，虚引用主要用来跟踪对象被垃圾回收器回收的活动。 Hashcode的作用。 equals相等的两个对象，则hashCode也相等。反之hashCode相等的两个兑现equals方法不一定相等。hashCode方法应该保证同一次执行每次返回的结果都相等。 ArrayList、LinkedList、Vector的区别。 ArrayList、Vector底层实现是通过数组，LinkedList是通过链表；Vector是线程安全的。ArrayList和LinkedList是非线程安全的。 String、StringBuffer与StringBuilder的区别。 String是字符串常量，StringBuffer和StringBuilder是字符串变量；StringBuffer线程安全的、StringBuilder是非线程安全的。 Map、Set、List、Queue、Stack的特点与用法。 ​ HashMap和HashTable的区别。 HashMap是非线程安全的，HashTable是线程安全的 HashMap是继承自Map接口，HashTable是继承自Dictionary HashMapkey和Value都可以是null，HashTable不允许null HashMap和ConcurrentHashMap的区别，HashMap的底层源码。 TreeMap、HashMap、LindedHashMap的区别。 Collection包结构，与Collections的区别。 try catch finally，try里有return，finally还执行么？ try里面有return，finally中代码块依然会执行。 1234567891011121314151617public class Test&#123; public static void main(String[] args) &#123; System.out.println(test()); &#125; public static int test() &#123; try&#123; return 12; &#125; catch (Exception e)&#123; &#125; finally&#123; System.out.println("这是finally函数块"); return 13; &#125; &#125;&#125; 12输出：这是finally函数块 13 如果try中直接返回变量，finally中对变量值进行修改，返回结果不会发生变化。 1234567891011121314 public static int test() &#123; int x=12; try&#123; x++; return x; &#125; catch (Exception e)&#123; &#125; finally&#123; System.out.println("这是finally函数块"); x++; //x的修改对前面的返回值无效 &#125; return 0; &#125;///输出结果是13 Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。 Excption与Error继承自Throwable。Error和RuntimeException及其子类称为未检查异常，其他异常称为受检查异常。 Error与Exception的区别： Error类一般是和虚拟机相关的问题，如系统崩溃，虚拟机错误、内存空间不足，方法调用栈溢出等。如StackOverFLowError、OutOfMemoryError等，对于这类错误，Java编译器不去检查他们，对于这类错误导致的应用程序中断，仅靠程序本省无法恢复和预防，遇到这类问题建议让程序终止。 Exception：表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常应该尽可能处理异常，使程序恢复运行，而不应随意终止异常。 运行时异常和受检查的异常 RuntimeException：其特点是Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try……catch捕获，也没有用throws抛出，还是会编译通过，如除数为零的ArithmeticException、错误的类型转换、数组越界访问和试图访问空指针等。处理RuntimeException的原则是：如果出现RuntimeException，那么一定是程序员的错误。 受检查的异常（IOException等）：这类异常如果没有try……catch也没有throws抛出，编译是通不过的。这类异常一般是外部错误，例如文件找不到、试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。 throw和throws的区别： throw：用于抛出各种类型的异常，可以抛出任意Throwable，包括自定义的异常类对象。 throws：总是出现在一个函数头，用来标识该成员函数可能抛出的各种类型异常。如果方法抛出异常，那么调用这个方法的时候就需要处理这个异常。 常见的runtimeException： NullPointException：空指针异常 ClassCastException：类型强制转换异常 IllegalArgumentException：传递非法参数异常 IndexOutOfBoundsException：数组越界 arithmeticException：算术运算异常（被除数为0） SecurityException：安全异常 ArrayStoreException：向数组中存放于声明类型不兼容对象异常。 Java面向对象的三个特征与含义。 封装：类的设计者将类设计成一个黑匣子，使用者只能看见类中定义的公共方法和公共变量，而看不见具体的实现细节，也不能对垒中非公共的数据进行操作，这样防止了外部的干扰和误用。 继承：继承是指从已有的类中派生出新类，新的类能吸收已有类的数据属性和行为，并能扩展新的功能。 多态：是指同一行为具有多种表现形式。同一个方法根据调用的不同而产生多种结果。包括重载和重写。 Override和Overload的含义去区别。 override是重写，子类覆盖父类中的方法。当通过父类引用子类时，调用父类方法执行的却是子类方法。 overload是重载，方法名相同，通过传递的参数不能，调用不同的方法。 Interface与abstract类的区别。 interface 所有抽象方法必须是public的，并且是abstract的，如果方法没有修饰，默认是public abstract JDK8时，interface中可以有静态方法。 不能有成员变量，但是可以有静态常量。final static int a=3,常量必须初始话。 一个类实现了某个接口，则必须要实现所有的抽象方法。 abstract class 抽象类中可以有变量，也可以成员方法（非抽象的） 抽象类中也可以有抽象方法，也可以没有抽象方法。 抽象类不能实例化 一个类继承自抽象类，则必须重写所哟抽象方法。 ​ Static class 与non static class的区别。 静态内部类： 创建静态内部类时，不需要拥有外部类的引用，可以直接创建，如： 1AA.B b = new AA.B(); //AA是外部类，B是AA的一个静态内部类 静态内部类只能调用外部类的静态变量或者静态方法。 非静态内部类： 创建非静态内部类时，必须要有外部类的引用，不能直接创建内部类，必须先创建外部类，然后通过外部类的引用创建内部类，如： 12AA aa = new AA(); //AA是外部类，A是AA的一个非静态内部类AA.A a = aa.new A(); 非静态内部类可以调用外部类的所有变量和方法 java多态的实现原理。 实现多线程的两种方法：Thread与Runable。 继承Thread类，实现run方法 实现Runable接口，实现run方法 实现Callable接口，实现call方法，创建FutureTask将callable参数传入，通过Thread类将FutureTask传入开启线程 123456789101112131415161718192021222324class MyCallable implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(i + " " + Thread.currentThread().getName()); Thread.sleep(100); &#125; return 10; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; MyCallable callable1 = new MyCallable(); FutureTask task1 = new FutureTask(callable1); new Thread(task1).start(); //获取返回值 System.out.println(task1.get()); &#125;&#125; 线程同步的方法：sychronized、lock、reentrantLock等。 锁的等级：方法锁、对象锁、类锁。 方法锁和对象锁是相同的 synchronized(this)，synchronized(obj)，public synchronized void method(){} 这两种是方法锁（对象锁） synchronized(Object.class),public static synchronized void method(){} 是类锁。 写出生产者消费者模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ConsumerAndProducer&#123; //缓冲区的大小 int len = 10; //模拟的缓冲区,用于存放生产的商品 int[] buffer = new int[len]; //in 表示生产放的位置, out表示即将消费的位置 int in = 0, out = 0; //缓冲区中剩下的商品数量 Integer remain = 0; //即将生产的产品编号 int productId = 0; //生产产品 public void produce() &#123; if (remain &lt; len) synchronized (remain) &#123; if (remain &lt; len) &#123; //剩下产品数量加1 remain++; buffer[in] = productId; System.out.println("生产了产品:"+productId+"剩余产品数量:"+remain); //下一个生产产品的位置向前加1 in = (in + 1) % len; productId++; &#125; &#125; &#125; //消费商品 public void consume() &#123; if (remain &gt; 0) synchronized (remain) &#123; if (remain &gt; 0) &#123; //剩余数量减1 remain--; System.out.println("消费了产品:"+buffer[out]+"剩余产品数量:"+ remain); out = (out + 1) % len; &#125; &#125; &#125;&#125; ThreadLocal的设计理念与作用。 ThreadLocal为每个线程提供一个变量的副本，这个变量副本存储在Thread中的ThreadLocalMap中。 ThreadPool用法与优势。 主要包括这几个参数：corePoolSize, MaximumPoolSize, keepLiveTime, TimeUnit, BlockingQueue, RejectedExecutionHandler 。 Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。 ​ wait()和sleep()的区别。 wait使线程阻塞，同时会释放占用的资源锁；sleep使线程阻塞，但是会依然占用资源锁。 foreach与正常for循环效率对比。 Java IO与NIO 反射的作用于原理。 泛型常用特点，List能否转为List。 解析XML的几种方式的原理与特点：DOM、SAX、PULL。 Java与C++对比。 Java1.7与1.8新特性。 设计模式：单例、工厂、适配器、责任链、观察者等等。 JNI的使用。 Java里有很多很杂的东西，有时候需要你阅读源码，大多数可能书里面讲的不是太清楚，需要你在网上寻找答案。 推荐书籍：《java核心技术卷I》《Thinking in java》《java并发编程》《effictive java》《大话设计模式》 ​ JVM 内存模型以及分区，需要详细到每个区放什么。 堆里面的分区：Eden，survival from to，老年代，各自的特点。 对象创建方法，对象的内存分配，对象的访问定位。 GC的两种判定方法：引用计数与引用链。 GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？ GC收集器有哪些？CMS收集器与G1收集器的特点。 Minor GC与Full GC分别在什么时候发生？ 几种常用的内存调试工具：jmap、jstack、jconsole。 类加载的五个过程：加载、验证、准备、解析、初始化。 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。 分派：静态分派与动态分派。 ​ JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。 ​ 推荐书籍：《深入理解java虚拟机》 ​ ​ 操作系统 进程和线程的区别。 死锁的必要条件，怎么处理死锁。 必要条件：互斥条件、请求保持条件、不剥夺条件、循环等待条件 Window内存管理方式：段存储，页存储，段页存储。 进程的几种状态。 IPC几种通信方式。 什么是虚拟内存。 虚拟地址、逻辑地址、线性地址、物理地址的区别。 ​ 因为是做android的这一块问得比较少一点，还有可能上我简历上没有写操作系统的原因。 ​ 推荐书籍：《深入理解现代操作系统》 ​ ​ TCP/IP OSI与TCP/IP各层的结构与功能，都有哪些协议。 OSI：物理层、数据链路层、网络层、运输层、会话层、 表示层、应用层、 TCP/IP：网络接口层、网际层IP、运输层、应用层 5层协议：物理层、数据链路层、网络层、运输层、应用层 TCP与UDP的区别。 TCP报文结构。 TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。 TCP拥塞控制。 TCP滑动窗口与回退N针协议。 Http的报文结构。 Http包括两种报文，一种是请求报文，一种是响应报文。无论是请求报文还是响应报文都包括三个部分：开始行、首部行、实体主体。两者的不同之处在于开始行，请求报文中开始行叫做请求行，响应报文中开始行叫做状态行 请求报文 请求行：包括三个部分，分别是方法、请求资源的URL、Http版本 首部行：用来说明浏览器、服务器或报文主体的一些信息，首部行包括很多字段，也可以没有 实体主体：请求报文中一般不使用这个字段 响应报文 状态行：也包括三个部分，Http版本号、状态码、解释状态码的短语 首部行：和请求报文类似 实体主体：返回显示的主体部分。 Http的状态码含义。 1xx：表示通知信息，如请求收到了或者正在处理 2xx：表示成功，如接受或知道了 3xx：表示重定向，如要完成请求还必须采取进一步的行动 4xx：表示客户端的差错，如请求中有错误的语法或不能完成 5xx：表示服务器的差错，如服务器失效无法完成请求 Http request的几种类型。 option：请求一些选项信息 head：仅仅只是返回响应的头部 get：向特定URL发出请求，从服务器取回数据 post：向特定URL提交数据，例如表单提交或者文件上传。数据包含在请求体中。 put：向指定字眼位置上传最新内容。一般用来更新一个已有的实体 delete：用来删除服务器上已有的资源 trace：用来进行回环测试的请求报文 connect：主要用来建立一个对资源的网络连接 Http1.1和Http1.0的区别 http1.1默认保持长连接，数据传输完成了保持TCP连接不断开。Connection：keep-alive Http怎么处理长连接。 ​ Cookie与Session的作用与原理。 电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。 Ping的整个过程。ICMP报文是什么。 C/S模式下使用socket通信，几个关键函数。 IP地址分类。 路由器与交换机区别。 ​ 网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。 ​ 推荐书籍：《TCP/IP协议族》 ​ ​ 数据结构与算法 链表与数组。 队列和栈，出栈与入栈。 链表的删除、插入、反向。 字符串操作。 Hash表的hash函数，冲突解决方法有哪些。 各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。 快排的partition函数与归并的Merge函数。 对冒泡与快排的改进。 二分查找，与变种二分查找。 二叉树、B+树、AVL树、红黑树、哈夫曼树。 二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。 图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。 KMP算法。 排列组合问题。 动态规划、贪心算法、分治算法。（一般不会问到） 大数据处理：类似10亿条数据找出最大的1000个数………等等 ​ 算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看。 ​ 推荐书籍：《大话数据结构》《剑指offer》《编程之美》]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面经总结]]></title>
    <url>%2F2017%2F07%2F05%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[[TOC] Java基础基础面向对象的三大特性、六大原则特性：封装、继承、多态 六大原则：单一责任原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口分离原则、组合聚合复用原则 参考： 面向对象基本原则 Object方法12345678910111213141516171819202122232425262728293031323334353637class Object&#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); //重写equals方法时，必须重写hashCode，否则在使用HashMap、HashSet等时会出现问题 public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0)) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; protected void finalize() throws Throwable &#123; &#125;&#125; Java反射机制Class类，通过Class类可以获取一个类中所有信息，包括构造函数、成员变量、方法等信息。同时通过Class类可以生成一个类的实例。 Java反射中主要涉及到到的类有Class、Constructor、Filed、Method。 Java强软弱虚引用 强引用：只要引用存在，垃圾回收机就不会回收，JVM宁愿报OutOfMemory错误 软引用：在内存溢出之前回收，垃圾回收时扫描到这个对象会做上标记，但不会立即回收，当内存要溢出时才会进行垃圾回收 弱引用：只要垃圾回收器扫描到就会立刻回收。 虚引用：只是用来判断对象是否还在内存中，因为通过get方法无法获取到值 依赖、关联、组合、聚合 依赖 可以简单的理解为一个类A使用了另一个类B，而这种使用关系是具有偶然性、临时性的，但是B类的变化会影响到A。在代码层面上就是B类作为一个参数被A类在某个方法中实现。 1234567class A&#123; void dependMethod(B b) &#123; …… &#125;&#125; 关联 它体现在两个类之间语义级别的一种强依赖关系。这种关系比依赖更强，不存在偶然性、临时性，一般指长期性的。在代码层面上，被关联的B以成员的形式出现在关联类A中。 1234class A&#123; private B b;&#125; 聚合 组合是关联关系的一种特例，它体现的是整体与部分、拥有关系，即has-a的关系。此时整体与部分之间是可分离的，他们可以具有各自的生命周期。比如雁群与大雁之间的关系，雁群是由很多大雁组成，但是大雁也可以和雁群分离。 组合 组合也是关联关系的一种特例，它体现的是一种contains-a的关系，这种关系比聚合更强，也成为强聚合。它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期借宿也就意味着部分的生命周期的结束；比如大雁的一对翅膀与大雁之间的关系，翅膀脱离了大雁无法单独存在。 java8 新特性 Lambda表达式 接口默认方法与静态方法 Java8允许给接口添加一个非抽象方法的实现，只需在方法前使用Default关键字即可 123456interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; 还可以在接口中定义静态方法，只需在方法前添加Static关键字 123456public interface StaticFunctionInterface &#123; static String staticFunction() &#123; return "static function"; &#125;&#125; 重复注解，注解本身需要添加@Repeatable元注解 扩展了注解支持，几乎可以为任何东西添加注解 java类加载器类加载过程 装载：查找并加载类的二进制文件 链接 验证：确保被加载类的正确性 准备：为静态变量分配内存，并将其初始化默认值 解析：把类中的符号引用转换为直接引用 初始化：为类的静态变量赋予正确的初始值 加载器 启动类加载器（Bootstrap ClassLoader）：负责加载HOME\jre\lib\目录下的rt.jar中的类 扩展类加载器（Extendsion ClassLoader）：负责加载HOME\jre\lib\ext\目录下的类 应用程序类加载器：这个类加载器负责加载CLASSPATH下的类库，一般我们编写的类都是这个类加载器负责加载。也叫做系统类加载器。 用户自定义加载器：用户自己编写的类加载器 类加载器的双亲委派模型​ 双亲委派模型是一种组织类加载器之间关系的一种规范,他的工作原理是:如果一个类加载器收到了类加载的请求,它不会自己去尝试加载这个类,而是把这个请求委派给父类加载器去完成,这样层层递进,最终所有的加载请求都被传到最顶层的启动类加载器中,只有当父类加载器无法完成这个加载请求(它的搜索范围内没有找到所需的类)时,才会交给子类加载器去尝试加载. 这样的好处是:java类随着它的类加载器一起具备了带有优先级的层次关系.这是十分必要的,比如java.langObject,它存放在\jre\lib\rt.jar中,它是所有java类的父类,因此无论哪个类加载都要加载这个类,最终所有的加载请求都汇总到顶层的启动类加载器中,因此Object类会由启动类加载器来加载,所以加载的都是同一个类,如果不使用双亲委派模型,由各个类加载器自行去加载的话,系统中就会出现不止一个Object类,应用程序就会全乱了. java异常java异常Throwable，包括Error和Exception。 Error：是程序无法处理的错误，表示运行程序中的严重问题。一般是代码运行时JVM出现的问题，例如内存溢出等问题。 Exception：是程序本身可以处理的异常。Exception有一个重要的子类RuntimeException，表示运行时异常。通常java异常分为可检查的异常和不可查的异常。 可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。 运行时异常：都是RuntimeException类及其子类异常，如NullPointException、IndexOutOfBoundException等 编译时异常：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等 Java检测死锁通过jstack命令导出线程堆栈信息。 12##将进程2745 的线程堆栈信息导出到info.txt文件中jstack 2745 &gt; info.txt 123456789101112131415161718192021222324252627Found one Java-level deadlock:============================="Thread-1999": waiting to lock monitor 0x00007fb92480b558 (object 0x00000007ecb88510, a java.lang.Integer), which is held by "Thread-441""Thread-441": waiting to lock monitor 0x00007fb92480a0b8 (object 0x00000007ecb98068, a java.lang.Integer), which is held by "Thread-444""Thread-444": waiting to lock monitor 0x00007fb92480b558 (object 0x00000007ecb88510, a java.lang.Integer), which is held by "Thread-441"Java stack information for the threads listed above:==================================================="Thread-1999": at pers.concurrent.DeadLock.run(DeadLock.java:23) - waiting to lock &lt;0x00000007ecb88510&gt; (a java.lang.Integer)"Thread-441": at pers.concurrent.DeadLock.run(DeadLock.java:25) - waiting to lock &lt;0x00000007ecb98068&gt; (a java.lang.Integer) - locked &lt;0x00000007ecb88510&gt; (a java.lang.Integer)"Thread-444": at pers.concurrent.DeadLock.run(DeadLock.java:25) - waiting to lock &lt;0x00000007ecb88510&gt; (a java.lang.Integer) - locked &lt;0x00000007ecb98068&gt; (a java.lang.Integer)Found 1 deadlock. 死锁信息。 方法重写规则123456789101112131415class A&#123; protected A test() &#123; return null; &#125;&#125;class B extends A&#123; public B test() &#123; return null; &#125;&#125; 子类重写父类方法时，访问权限应该相同或者更大，返回类型应该相同或者是其子类. 方法重写遵循 两同两小一大原则，方法名相同，形参列表相同，两小是，子类方法的返回值类型应当比父类方法的返回值类型更小或者相同，子类方法声明抛出的异常要比父类方法抛出的异常更小或者相等，一大是子类的方法访问权限要大于父类方法的访问权限。 1234567891011public static void main(String[] args) &#123; int i = 0; Integer i1 = 0; Integer i2 = new Integer(0); Integer i3 = 0; System.out.println(i == i1); //true System.out.println(i == i2); //true System.out.println(i1 == i2); //false System.out.println(i1 == i3); //true &#125; Java容器HashMap底层实现hashMap底层存储是用一个Entry数组，数据中每个Entry都是一个链表，当新元素添加时，直接添加到链表头即可。 hashMap可以设定初始容量，不设定的话初始容量为16，默认加载因子是loadFactor=0.75，当map中的元素个数n&gt;=table.length*0.75时，Map会发生扩容，扩容机制是原来数组长度的两倍：resize(2 * table.length)。 hashMap 解决冲突的办法是将数组元素设计成一个链表，当同一个有多个元素映射到同一个数组元素中，直接将其添加到链表头，更好的解决冲突的办法是将链表设计成一颗红黑树。 HashMap多线程下扩容问题会出现死循环问题 http://coolshell.cn/articles/9606.html 详细参考： Java集合_Map介绍 ArrayList和LinkedList区别 arrrayList底层实现是用的数组，而LinkedList用的是链表。 ArrayList的查找效率更高，但是LinkedList的添加和删除元素更快 ArrayList的默认容量是10，扩容比例是：1.5倍 1int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 详细请参考：Java集合_List介绍 TreeSet如何实现排序TreeSet底层是通过TreeMap实现的，TreeMap实现排序是通过红黑树。 Java虚拟机Java内存管理Java虚拟机将内存分为：堆、方法区、虚拟机栈、本地方法栈、程序计数器 五块区域。其中虚拟机栈、本地方法栈和程序计数器是线程隔离的；堆和方法区是线程共享区域。 详细参考:Java内存管理 Java垃圾回收机制如何确定一个对象是否是垃圾？ 引用计数法 可达性分析 常见的垃圾回收算法 标记清除算法 标记整理算法 复制算法 分代收集算法 新生代采用复制算法，老年代采用标记整理算法 典型的垃圾收集器 serial收集器（适用于新生代） 这是一个单线程的收集器，在进行垃圾回收时必须暂停其他所有的工作线程。 parnew收集器（适用于新生代） serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为和serial收集器一样。 parallel scavengel 收集器（适用于新生代） 和parnew收集器比较相似，不同之处在于ps更多关注的是系统吞吐量，最求系统吞吐量的最大化。 系统吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)； 这个收集器无法与CMS收集器配合使用。 serial old 收集器 是serial收集器的老年代版本，同样是一个单线程收集器。采用的是标记整理算法。 parallel old收集器 是parallel scavenge收集器的老年代版本，使用多线程和标记整理算法。 cms收集器 cms收集器是一种以获取最短回收停顿时间为目标的收集器。是基于标记清除算法实现的。主要包括四个步骤： 初始标记：暂停所有用户线程，仅仅只是标记一个GC Root能直接关联到的对象。 并发标记：就是进行GC Root Tracing的过程。 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个时间比初始标记的时间稍长，但远小于并发标记的时间 并发清除：并发清除所有未标记过的对象。 G1收集器 G1将堆内存分割成若干个大小相同的Region区域，一部分是Eden、一部分是survivor、一部分是old，还有一部分是Humongous区域，Humongous是存放大对象的地方（一个对象大于等于Region/2）。在young GC时，判定对象是否存活的时候，为了避免扫描整个Java堆，引入Remembered Set。young gc时会扫描所有的Eden和survivor区域，因此他们之间的引用不用考虑，但是old区域到新生代的引用需要记录。用Card Table将一个Region在逻辑上划分为固定大小的连续区域，每个区域称之为卡，卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。 参考： Java垃圾回收机制 Java内存模型Java内存模型规定所有变量都存储在主内存中（可以类比物理硬件中的内存），没条线程还有自己的工作内存（与处理器的高速缓存类似），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所哟操作都必须在工作内存中进行，而不能直接读取内存中的变量。 这里所说的主内存、工作内存与Java内存区域划分中的Java堆、栈、方法区不是同一个曾是的内存划分。 JVM参数配置 -Xms：初始堆大小 -Xmx：最大堆大小 -Xmn：年轻代大小 -XX:PermSize：永久代大小 -XX:NewRatio：年轻代和老年代的比例 -XX:SurvivorRatio=4：设置Eden和survivor的大小比值 参考：JVM参数配置大全 JVM频繁FullGC及应对策略参考：JVM频繁Full GC的情况及应对策略 JVM性能调优和监控工具 jps 查看JVM中运行的进程状态信息 -q 不输出类名、jar名和传入main方法的参数 -m 输出传入main方法的参数 -l 输出main类或jar的全名 -v 输出传入JVM的参数 jstack查看某个Java进程的线程堆栈信息 jmap 用来查看内存使用状况 用jmap把进程内存使用情况dump到文件中，可以用MAT或visualVM查看 1jmap -dump:format=b,file=dumpFileName pid 查看进程内存使用情况 123456789101112131415161718192021222324252627282930313233343536373839404142jmap -heap 2378 //输出结果Heap Configuration: MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 1073741824 (1024.0MB) NewSize = 1310720 (1.25MB) MaxNewSize = 17592186044415 MB OldSize = 5439488 (5.1875MB) NewRatio = 2 SurvivorRatio = 8 PermSize = 21757952 (20.75MB) MaxPermSize = 85983232 (82.0MB) G1HeapRegionSize = 0 (0.0MB)Heap Usage:PS Young GenerationEden Space: capacity = 17301504 (16.5MB) used = 2101464 (2.0041122436523438MB) free = 15200040 (14.495887756347656MB) 12.146134810014205% usedFrom Space: capacity = 2621440 (2.5MB) used = 0 (0.0MB) free = 2621440 (2.5MB) 0.0% usedTo Space: capacity = 2621440 (2.5MB) used = 0 (0.0MB) free = 2621440 (2.5MB) 0.0% usedPS Old Generation capacity = 57147392 (54.5MB) used = 26782288 (25.541580200195312MB) free = 30365104 (28.958419799804688MB) 46.865284771000574% usedPS Perm Generation capacity = 22020096 (21.0MB) used = 7535448 (7.186363220214844MB) free = 14484648 (13.813636779785156MB) 34.220777239118306% used Jstat JVM统计工具，统计Survivor、Eden、Old使用情况 jstat -gc pid：GC堆的状态 12S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 19968.0 2560.0 0.0 0.0 16896.0 3047.6 72192.0 38157.8 21504.0 7292.4 5 0.132 3 0.710 0.842 jstat -gcutil pid：GC汇总 参考： JVM调优工具 JMM(java内存模型)参考：http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html Java并发编程创建线程的三种方式 继承Thread类 实现Runable接口 通过FutureTask和CallAble 12345678910111213141516171819class MyCallable implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println("调用call方法创建线程"); return 1; &#125;&#125;public class ThreadDemo&#123; public static void main(String[] args) throws Exception &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyCallable()); new Thread(futureTask).start(); System.out.println(futureTask.get()); &#125;&#125; Callable和Runnable的区别 CallAble规定的是call方法，二runnable规定是run方法 CallAble的任务执行完成后可返回值，而Runnable的任务是没有返回值的 call方法可以抛出异常，run方法不可以 实现线程安全方式 加锁 通过对线程共享资源加锁，使得资源一次只能有一个线程访问。加锁的方式有lock和synchronized。 ThreadLocal 为每个线程提供变量的一个副本，实质是用空间换时间。ThreadLocal通过维护Thread类中的ThreadLocalMap，以实现对同一变量不同线程提供不同的副本。Map中，ThreadLocal作为key值，Value是每个线程对应的变量副本。 12345678910111213public void set(T value) &#123; Thread t = Thread.currentThread(); //获取线程Thread中的ThreadLocalMap变量 ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 12//Thread类中对threadLocals的定义ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal详细参考：ThreadLocal Lock与synchronized比较synchronized 获取锁的线程执行完代码，然后线程自动释放对锁的占有 线程执行发生异常，此时JVM会让线程自动释放锁 Lock Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问； Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。 当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。 tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。 volatile关键字 保证了线程对变量的修改是内存可见的，即一个线程对变量的修改，会立刻会更新到主内存中，其他线程想要读取变量值必须到主内存中读取，而不能在线程的工作内存中读，保证其他线程能够立刻看到修改值 禁止指令的重排序。 指令重排序：处理器为了提高程序运行效率，可能会对输入的代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是他会保证程序执行结果和代码顺序执行的结果是一致的。处理器进行指令重排序时，会考虑指令之间的数据依赖性。虽然重排序不会影响单个线程的执行结果，但是对多线程却是有影响的。 如果变量声明为volatile，则代码中这个变量所在的顺序就是其执行的顺序，即它前面语句执行顺序可能会变，后面的语句执行顺序会变，但是它本身执行不会变 12345a=2;//语句1b=3;//语句2c=5;//语句3 c是volatile变量，1和2执行顺序可能交换，4和5的执行顺序也可能交换，但是3一定是第三个执行d=2;//语句4e=6;//语句5 Thread中的几种状态 new：用new 操作符创建一个新线程时状态，如new Thread(r); runnable：当线程调用start()方法后，就处于这种状态。可运行状态可能正在运行，也可能没有运行。这取决于操作系统提供的运行时间。 Blocked：被阻塞状态，IO操作等待资源锁等 waiting：等待状态，调用了Object.wait()方法或者join()方法 Timed waiting：计时等待， Terminated：终止状态，run方法运行结束，或者线程发生异常 Thread中的方法 join():当某个程序执行流中调用其他线程的join()方法，调用其他线程的线程本身会被阻塞，直到被调用的线程执行完毕为止。如A线程中调用了B线程，B线程中执行了join()方法，则A线程会被阻塞，直到B线程执行完 yield()：线程让步，yield会让出执行权限，让系统重新从优先级大于或等于当前线程的这些线程选择（包括当前线程），也就是说可能还会选择当前线程继续执行 interrupt()：只是改变中断状态而已，interrupt()不会中断一个正在运行的线程。这一方法实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，那么，它将接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态.如果线程没有被阻塞，这时调用interrupt()将不起作用；仅仅是设置中断标志位为true sleep()：睡眠 j2eeservlet和jsp的区别servlet是java提供的用于开发web服务器应用程序的一个组件，运行在服务端，由servlet容器所管理，用于生成动态内容。 jsp是servlet的扩展，在没有jsp之前，就已经出现了servlet技术。servlet是利用输出流动态生成HTML页面，包括每一个HTML标签和每一个在HTML页面中出现的内容。 事实上，jsp是servlet的一种特殊形式，每一个jsp页面就是一个servlet实例，jsp由系统编译成servlet,再由servlet负责响应用户请求。 servlet和jsp的不同之处在于，servlet的响应逻辑在java文件中，并且完全从表示层中的HTML里分离，而jsp是java和HTML组合成一个扩展名为.jsp的文件。jsp侧重于视图，servlet侧重于控制逻辑。 servlet 生命周期： init（）：初始化，每个servlet只能初始化一遍，在第一次创建的时候被调用，在后续用户每次请求时不再调用。 service（）：是执行实际任务的主要方法，servlet调用service方法来处理来自客户端的请求，每次产生一个新线程调用doGet、doPost等方法 doGet()\doPost()：具体的业务方法 destroy()：servlet生命周期结束 session 和Cookie的区别 Cookie保存在本地，session保存在服务器端 存取方式不同，Cookie中只能保存ASCALL字符串，Cookie中也不能之间存取java对象；而session中能够存取任何类型的数据，session中也能够直接保存java对象，相当于一个java容器。 服务器压力的不同，session保存在服务端。每个用户都会产生一个session。假如并发访问的用户十分多，会产生很多的session，耗费大量的内存。而Cookie保存在客户端，不占用服务器资源，如果并发用户多的话。Cookie是很好的选择。 浏览器支持上不同。Cookie需要客户端浏览器的支持，如果客户端禁用Cookie的话，Cookie回话跟踪会失效，需要使用session和URL重写。 参考文章：http://www.lai18.com/content/407204.html POST和GET的区别 GET请求数据会附在URL之后，POST把提交数据放置在HTTP包的BODY里面 GET方式提交的数据最多是1024字节，POST理论上是没有限制的，可以传送大量的数据 POST的安全性要比GET高。 RESTful简单的定义：URL定位资源，用HTTP动词（GET、POST、DELETE、PUT）来描述操作。 REST描述的是网络中Client客户端和Server的一种交互形式，REST本身没什么意义，只是提供了一种设计RESTful API(网络接口)的约束。 Server提供的RESTful API中，URL中只能使用名词来指定资源，原则上不能使用动词。比如： http://api.qc.com/v1/newfriends: 获取某人的新鲜; http://api.qc.com/v1/friends： 获取某人的好友列表; http://api.qc.com/v1/profile： 获取某人的详细信息; 通过http协议中的动词来添加、修改、删除资源 GET 用来获取资源 POST 用来新建资源 PUT 用来更新资源 DELETE 用来删除资源 SSH框架SpringMVCSpring MVC运行原理 1.http请求：客户端请求提交到DispathcherServlet. 2.寻找处理器：DispatcherServlet控制器查询一个或多个HandlerMaping，找到处理请求的Controller(我们俗称Controller，实际是Handler)。 3.调用处理器：DispatcherServlet将请求提交到Controller中。 4.5.调用处理业务和返回结果：Controller调用业务逻辑处理后，返回ModelAndView 6.7处理视图映射并返回模型：DispathcerServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图 8.Http响应：视图复制将结果显示到客户端 拦截器与过滤器的区别 拦截器是基于java的反射机制，而过滤器是基于函数回调 拦截器不依赖于servlet容器，而过滤器依赖于servlet容器 拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用 拦截器可以访问Action上下文，值栈里的对象，而过滤器不能访问 在Action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次 springMVC和Struts2的区别 Struts2是类级别的拦截，一个类对应一个request上下文；springMVC是方法级别的拦截，一个方法对应一个request上下文。 springMVC方法之间基本上是独立的，独享request和response数据，请求数据通过参数获取处理结果通过modelMap交回给框架，方法之间不共享变量。而Struts2比较混乱，虽然方法之间也是独立的，但其所有Action变量是共享的， 拦截器实现机制上，Struts2有自己的interceptor机制；springMVC采用的是独立的AOP方式。 springMVC的入口是servlet,而Struts2是Filter。 springMVC和Spring是无缝的，从项目管理和安全上也比Struts2高 springMVC开发效率和性能高于Struts2 HibernateHibernate缓存Hibernate缓存包括两大类：一级缓存和二级缓存 一级缓存：一级缓存又称为session缓存，session缓存是事务范围的缓存，只存在与session的生命周期中。当程序调用session接口的save、update、saveOrUpdate、get、load等方法时，如果session缓存中没有响应的对象，Hibernate就会把对象加入到一级缓存中，当session关闭时，该session所管理的一级缓存也会立即被清除。 二级缓存：二级缓存是sessionFactory级别的缓存，又称应用缓存，使用第三方插件，可插拔的。缓存的范围是所有session共享，缓存的生命周期依赖于应用的生命周期，应用结束了缓存也就结束了。 Hibernate的三态瞬时态(临时态)：对象刚被创建但没有被持久化。 特点：不和session实例关联；在数据库中没有和瞬时对象关联的记录 持久态：持久化对象就是已经保存进数据库的实体对象，并且这个实体对象现在还处于Hibernate的session缓存管理之中。这时对实体对象的任何修改，都会在清理缓存时同步到数据库中。 特点：持久的实例在数据库中有对应的记录，并拥有一个持久化标识；和session相关联的对象 游离态：当一个持久化对象脱离Hibernate的缓存管理后，它就处于游离状态 特点：本质上和瞬时对象相同；比瞬时对象多了一个数据库记录标识值ID Hibernate与Mybatis的优缺点对比 SQL优化方面，Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而mybatis的SQL是手动表写的，所以可以按需求指定查询的字段 扩展方面，Hibernate与具体的数据库无关，只需配置XML文件即可，所有的HQL语句与具体使用的数据库无关，移植性好。mybatis项目中的所有SQL语句都是依赖数据库的，所以不同的数据库类型支持不好 开发工作量来说，mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，无需开发者关系SQL的生成与结果映射。 优势对比 mybatis优势： mybatis可以更为细致的SQL优化，可以减少查询字段 mybatis容易掌握，而Hibernate门槛较高 Hibernate优势： Hibernate的DAO层开发比mybatis简单，mybatis需要维护SQL和结果映射 Hibernate对对象的维护和缓存比mybatis好，对增删改查的对象的维护要方便 Hibernate数据库移植性很好，mybatis的数据库移植性不好，不同的数据库要写不同的SQL 应用场景 Hibernate：适用于 SpringSpring事务传播特性 事务传播行为类型 说明 PROPAGATION_REQUIRED 如果当没有事务，就创建一个新的事务，如果已经存在一个事务，就加入这个事务。这是默认设置 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行 Propagation_mandatory 使用当前事务，如果没有事务，就抛出异常 PROPAGATION_REQUIRES_NEW 新建事务，如果当前有事务，则把当前事务挂起 PROPAGATION_NOT_SUPPORTED 以非事务方式执行，如果当前有事务，则把当前事务挂起 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常 PROPAGATION_Nested 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 Spring自动注入的三种方式12345678910//注意 get和Set方法省略class OrderItem&#123; private String goodsName;&#125;class Order&#123; private String orderNum; private OrderItem orderItem;&#125; 接口注入 setter注入 default 1234567891011&lt;beans&gt; &lt;bean id="item" class="org.jia.OrderItem"&gt; &lt;property name="goodsName" value="球拍"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="order" class="org.jia.Order" &gt; &lt;!-----注入变量 名字必须与类中的名字一样-------&gt; &lt;property name="orderNum" value="20170638994"&gt;&lt;/property&gt; &lt;!--注入对象id和前面的OrderItem的id一样--&gt; &lt;property name="orderitem" ref="item"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; byName 123456789&lt;beans&gt; &lt;!--此时的id就必须与Order.java中所定义的OrderItem的对象名称一样了，不然就会找不到--&gt; &lt;bean id="orderItem" class="org.jia.OrderItem"&gt; &lt;property name="goodsName" value="item00001"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="order" class="org.jia.Order" autowire="byName"&gt; &lt;property name="orderNum" value="20170638994"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; byType 123456789&lt;beans&gt; &lt;!--按照byType注入则就与id没有关系，可以随便定义id ！！！但是不能出现多个此类的id--&gt; &lt;bean id="orderitdfadafaem" class="org.jia.OrderItem"&gt; &lt;property name="orderdec" value="item00001"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="order" class="org.jia.Order" autowire="byType"&gt; &lt;property name="orderNum" value="20170638994"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 构造方法注入 1234public Order(OrderItem item)&#123; this.orderItem=item;&#125; 构造方法注入需要在原来类的基础之上添加构造函数 12345678&lt;beans&gt; &lt;bean id="orderItem" class="org.jia.OrderItem"&gt; &lt;property name="orderdec" value="item00001"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="order" class="org.jia.Order" autowire="constructor"&gt; &lt;property name="orderNum" value="order000007"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 数据库数据库相关知识点数据库事务的理解事务：用户定义的一个数据库操作序列，要么全都做，要么全都不做，是一个不可分割的工作单位。 事务的四个特性：原子性、一致性、隔离性、持续性。 原子性：事务中的操作要么全都做，要么全都不做。 一致性：事务的执行结果必须是从一个状态变到另一个状态。当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。 隔离性：一个事务的执行不能被其他事务干扰。 持续性：一个事务一旦提交，他对数据库中数据的改变就应该是永久的。 数据库的隔离级别 Read Uncommited 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 ReadCommited 写事务的时候不允许其他事务，读事务的时候可以其他事务 RepeatableRead 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 serializable(序列化) 它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行 脏读 不可重复读 幻读 read Uncommited yes yes yes read Commited no yes yes repeatableRead no no yes serializable no no no 脏读、幻读、不可重复读脏读：一个事务正在读数据库进行修改，而这种修改还没有提交到数据库中。这时另外一个事务也访问这个数据，然后使用了这个数据。前面这个事务可能进行回滚。即一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的。 不可重复读：一个事务内多次读同一个数据却返回了不同的数据，这是由于读取数据过程中，其他事务对这个数据进行了修改。 幻读：A对表中的所有数据进行修改，B这时又插入一条新数据。A发现还有一条数据没有修改，就好像发生了幻觉一样。例如：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。 参考： 数据库的脏读、不可重复读、幻读以及不可重复读和幻读的区别 数据库索引索引的主要目的是加快检索表中数据。索引是对数据库表中的一列或者多列的值进行排序的结构。 索引的分类 普通索引：没有任何的限制，可以对表中的没一列添加索引 1create index in_username on student(name); 唯一索引：索引列的值必须唯一，但允许有空值 1create unique index in_username on student(name); 主键索引：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引 123456create table tt (id int auto_increment,name varchar(16),address varchar(20),primary key(id)); 组合索引：对多个列同时添加索引 1create index in_co on tt(id,name); 详细介绍可参考：http://www.jb51.net/article/49346.htm 索引的实现方式 B+树索引 Hash索引 详细介绍可参考：http://www.cnblogs.com/heiming/p/5865101.html 聚集索引和非聚集索引 聚集索引 聚集索引也称聚簇索引、聚类索引。聚集索引是指数据库表中数据的物理顺序与键值的逻辑顺序相同。一个表中只能有一个聚集索引，因为一个表的物理顺序只有一种情况。逻辑顺序决定表中的物理顺序。一般索引是通过树来描述，聚集索引的叶子结点就是最终的数据结点。 非聚集索引 该索引的逻辑顺序与磁盘上行的物理存储顺序不同。叶子结点存储的只是数据域的地址，而不是真正的数据。 乐观锁和悲观锁 乐观锁 乐观锁认为数据一般情况下是不会造成冲突的，所以在数据进行提交更新时，才会正式对数据的是否冲突进行检测，如果发生冲突了，则让返回错误信息，让用户决定如何去做。可以通过版本号和时间戳等方法判断数据是否冲突。 适用场景：冲突比较少的时候，这样可以减少加锁的开销。如果冲突交多，则会不断进行retry，反而降低了系统的吞吐量。 悲观锁 悲观锁是指对数据被外界修改保持保守的态度，每次去拿数据都认为别人会修改，所以每次在拿数据库的时候都会上锁，这样别人想拿这个数据就会阻塞，知道拿到这个锁。 适用场景：冲突比较多的时候。 内连接和外连接内连接：包括等值连接和自然连接，内接接只有两个表相匹配的行才能输出在结果集中 外连接：包括左外连接、右外连接和完整外部连接 左外连接：结果集中不仅是连接中匹配的行，如果坐标的某行在右表中没有匹配，则右表中属性列显示null 完整外部连接：返回左表和右表的中的所有行，当某行在另一个表中没有匹配时，则另一个表选中列显示null Innodb与MyIASM引擎比较Innodb引擎 Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。 名词解析： ACID A 事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成. C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变. I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致. D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚. MyIASM引擎 MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。 两种引擎的选择 大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候。 redis缓存redis数据类型String、List、Set、Hash、ZSet(sorted Set) memcache和redis的区别 存储方式不同，MenCache吧所有数据全部存在内存之中，断电后会挂掉，数据不能超过内存的大小；redis有部分存在磁盘上，这样能保证数据的持久性 数据支持类型不同，MenCache对数据类型支持相对简单；redis有5种数据类型，相对复杂。 使用的底层模型不同，它们底层的实现方式以及客户端之间的应用协议不一样，redis直接构建了VM机制，因为一般的调用系统函数会浪费一定的时间去移动和请求。 Value的大小不同，redis最大可以达到1GB，而MenCache只有1M redis数据淘汰策略 volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据 redis常见性能问题和解决方案 Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内 尽量避免在压力很大的主库上增加从库 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3，这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。 架构session分布式部署架构下如何设计session session复制 应用服务器开启web容器的session复制功能，在集群中的几台服务器之间同步session对象，使得每台服务器上都不存所有用户的session信息。 缺点： 当服务器集群较大时，需要大量的通信进行session复制，占用服务器和网络资源。而且用户数量很多时，服务器内存远不够存储这些session信息。 session绑定 可以利用负载均衡将源地址做Hash运算映射其中一台服务器上，同样的IP地址总是分配同一个web服务器。 缺点： 当某一台服务器宕机时，那么该机器上的session全部消失，用户请求切换到其他服务器后也没有session信息，进而无法完成业务处理。 利用Cookie记录session 将session信息记录到本地cookie。 缺点：cookie有大小限制，能记录的信息有限；每次请求都要传输cookie，影响 性能；本地cookie容易被劫持复制，不安全。 session服务器 独立部署session服务器集群，同一管理session。每次调用session时，都访问session服务器。 参考： 分布式环境下5种session处理策略 数据结构树红黑树 根节点是黑色的 树中只有结点要么是黑色，要么是红色 每个叶子结点都是黑色的 红色结点的两个子节点都是黑色的（从叶子结点到根节点的所有路径上不能有两个连续的红色结点） 从任意结点到期每个叶子结点的所有路径都包含相同数目的黑色结点。 二叉搜索树（B树） 所有非叶子结点至多拥有两个儿子儿子结点 父节点的值大于左儿子结点的值，小于右儿子结点的值 二叉搜索树中序遍历是一个递增序列 B+树Hash解决冲突的办法 开发定址法 f(x)= (H(x)+d)%m;当有冲突时，改变d的值 再Hash法 链地址法 HashMap的实现方式 建立一个公共溢出区 网络基础OSI七层模型协议 OSI分层 功能 相关协议 应用层 用户接口、应用程序 HTTP、Telnet、FTP、TFTP 表示层 数据表示、压缩和加密 JPEG、ASCALL、MPEG 会话层 回话的建立、管理、终止 SQL、NFS、RPC 传输层 提供端到端数据传输 TCP、UDP 网络层 负责数据包从源到宿的传递 IP、ARP、ICMP、IGMP 数据链路层 将比特组装成帧和点对点传输 PPP、MAC 物理层 传输比特流 V.35、X.21、RS-232、RS-449 GET和POST的区别 get请求的数据会附在URL之后，而POST把提交的数据则放在Http包的包体中 get方法提交数据最多是1024字节，理论上POST没有限制，可以上传大量数据。 POST的安全性要比get安全性高 工具ping命令返回结果常见的三种错误： unknown host：不知名主机，主机名无法被DNS解析 Destinationn host Unreachable：主机不可达，一般是线路中断。 Request time out：在规定时间内没有返回结果，可能是防火墙阻隔。 联通时返回结果： 1234567891011huzhimingdeMacBook-Air:~ huzhiming$ ping www.baidu.comPING www.a.shifen.com (119.75.216.20): 56 data bytes64 bytes from 119.75.216.20: icmp_seq=0 ttl=244 time=70.714 ms64 bytes from 119.75.216.20: icmp_seq=1 ttl=244 time=74.515 ms64 bytes from 119.75.216.20: icmp_seq=2 ttl=244 time=64.175 ms64 bytes from 119.75.216.20: icmp_seq=3 ttl=244 time=63.792 ms64 bytes from 119.75.216.20: icmp_seq=4 ttl=244 time=64.381 ms^C--- www.a.shifen.com ping statistics ---5 packets transmitted, 5 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 63.792/67.515/74.515/4.338 ms 119.75.216.20：解析出的ping的IP地址 64：返回数据包大小 ttl:Time To LIve 生存时间，防止数据报在网络中形成广播风暴 time：返回数据所耗费的时间 参考： ping命令使用解析 Http协议相关HTTP1.0 与HTTP1.1的区别 引入持久化连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。 引入管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 增加了Host头域，使多个Server同时共享一个IP地址和端口号 增加状态码100，客户端先发送一个只有请求头的数据，测试地址是否可以访问，可以访问随后再发送含有包含body字段的请求 Http状态码 1xx：指示信息，表示请求已经接收，继续处理 2xx：成功，表示请求已经被成功接收、理解、接受 3xx：重定向，表示完成请求必须进行更进一步的操作 4xx：客户端错误，请求有语法错误或者请求无法实现 5xx：服务器端错误，服务器未能实现合法的请求 常见的状态码： 100：Continue 请求继续，客户端应当继续发送请求的其余部分 200：OK——客户端请求成功 202：Accepted 请求已经接受，但尚未处理 300： Multiple Choices 客户端请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出 301：Moved Permanently 客户端请求的文档在其他地方，新的URL在location中给出，浏览器应该自动访问新的URL 304：服务器端内容未修改 400：Bad request——客户端请求有语法错误，不能被服务器解析 401：unauthorized——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403：Forbidden——服务器收到请求，但是拒绝提供服务 404：Not found——请求资源不存在 如URL输入错误 500：Internal Server Error——服务器发生了不可预料的错误 502：网关错误 503：Server Unavailable——服务器当前不能处理客户端的请求，一段时间后可能恢复正常 301与302的区别302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。 301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。 Request请求头常见字段： Host：请求的web服务器域名地址 User-Agent：Http客户端浏览器类型的详细信息 Accept：指定客户端能够接收的内容类型 text/xml、text/html Accept-Language：指定客户端浏览器用来显示返回信息所优先选择的语言 Accept-Encoding：指定客户端浏览器可以支持服务器返回内容的压缩编码类型，表示客户端浏览器所能支持的返回压缩格式 Accept-CharSet：浏览器可以接受的字符编码集 Content-type：此请求提交的内容类型，一般只有post提交时才需要设置该属性 Connection：表示是否需要持久连接，如果值是keep-Alive或者协议版本是HTTP1.1，就会进行持久连接 Cookie：http请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器 Date：请求发送的日期时间 Http Response响应头字段： Cache-Control：缓存机制,no-cache,private,public, Connection:是否要保持持久连接 Content-Encoding：返回来数据的压缩格式 Content-Language：相应体的语言 Content-type：返回资源文件的类型 Date：服务器发送资源时的服务器时间 Expiers:告诉客户端在这个时间前可以直接访问缓冲副本，相应过期时间 Last-Modifed:请求资源的最后修改时间 http缓存策略强制缓存 对比缓存 expiresexpires值为缓存的到期时间，当前时间小于expires值时，会直接使用缓存。expires是http1.0里的内容，现在基本使用http1.1，故其作用基本可以忽略。 Cache-controlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。private：客户端可以缓存public：客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx：缓存的内容将在 xxx 秒后失效no-cache：强制将请求需要使用对比缓存来验证缓存数据no-store：所有内容都不会缓存，强制缓存，对比缓存都不会触发 当使用max-age且未超出时间限制时，则使用强制缓存。 当使用max-age且超出时间限制时，使用对比缓存 Etag / If-None-Match 使用对比缓存时，首先检测response的header中是否用Etag字段，Etag表示当前资源在服务器中的唯一标识符，再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 Last-Modified / If-Modified-Since（优先级比etag低） 服务器在响应请求时，告诉浏览器资源的最后修改时间。再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 运输层TCP和UDP的区别UDP（用户数据报协议） UDP无连接的 最大努力交互，不保证可靠交互 UDP是面向报文的 UDP不使用拥塞控制 UDP支持一对一、一对多、多对一和多对多的交互通信 UDP的首部开销小，只有8个字节 TCP传输控制协议 TCP是面向连接的运输层协议 每一条TCP连接只能有两个端点，每条连接只能是点对点的 TCP是可靠交付服务 TCP提供全双工通信 TCP是面向字节流的 操作系统：进程管理进程与线程的区别与联系进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的基本单位 线程：是进程的一个实体，是CPU调度和分配的基本单位。它是比进程更小的能独立运行的基本单位，线程基本上不拥有系统资源，只拥有一点在运行中必不可杀的资源。 区别： 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程间通信的方法 无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 高级管道：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们称为高级管道方式。 有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 消息队列： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号量： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。 套接字（socket）：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。 死锁的必要条件避免和解除方法必要条件 互斥条件：一个资源每次只能被一个进程使用 请求保持条件：一个进程因请求资源二阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 预防死锁的办法： 摒弃请求保持条件，规定所有进程在开始之前，都必须一次性申请其在整个运行过程中所需的全部资源，只要有一种不够，便不分配 摒弃不剥夺条件，进程可以逐个申请资源，一旦申请资源无法满足，立即释放已经保持的所有资源。 摒弃环路等待条件 避免死锁的算法：银行家算法 解决死锁的办法： 剥夺资源 撤销进程 自旋锁和互斥锁自旋锁：但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。 互斥锁：对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。 存储管理内存碎片采用分区存储管理的系统，在存储分配过程中产生的不能供用户进程使用的小分区称为“内存碎片”，内存碎片分为内部碎片和外部碎片。 内部碎片内部碎片就是已经分配出去（明确指出属于哪个进程）却不能被利用的内存空间。 单道连续分配只有内部碎片，固定分区分配即有内部碎片也有外部碎片 外部碎片外部碎片是指还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。 动态分区分配只有外部碎片。 分页和分段的区别 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外部碎片，提高内存的利用率。或者说分页只是由于系统管理的需要而不是用户的需要。而段是信息的逻辑单位，它含有一组意义相对完整的信息。分段的目的是为了更好的满足用户的需要 页的大小固定且由系统决定，把逻辑地址划分为页号和页内地址两部分。而段的长度是不固定的，决定于用户所编写的程序。 ​ 算法动态规划 最长回文子串问题 ​]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[负载均衡几种方式]]></title>
    <url>%2F2017%2F06%2F29%2F%E6%9E%B6%E6%9E%84%2F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[负载均衡的几种方式​ 负载均衡是网站架构必不可少的基础手段，不但可以实现网站的伸缩性，同时还可以改善网站的可用性。负载均衡的方式有以下几种： Http重定向负载均衡 DNS域名解析负载均衡 反向代理负载均衡 IP负载均衡 数据链路层负载均衡 Http重定向负载均衡 Http重定向服务器唯一功能就是根据用户的http请求计算一台真实的web服务器地址，并将该web服务器地址写入http重定向相应中返回给用户浏览器。 这种方案的有点事比较简单，缺点是浏览器每次请求都需要两次请求服务器才能完成，性能较差。重定向服务器自身处理能力可能成为瓶颈。 DNS域名解析负载均衡 DNS服务器中配置了多个A 记录： www.mysite.com IN A 114.100.80.1; www.mysite.com IN A 114.100.80.2; www.mysite.com IN A 114.100.80.3; 每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置的多个服务器就构成一个集群，并实现负载均衡。 优点：将负载均衡的工作转交给DNS，省掉了网络管理维护负载均衡服务器的麻烦，同时许多DNS还支持基于地理位置的域名解析，即会将域名解析成距离用户地理位置最近的服务器地址，这样可加快用户访问速度，改善性能。 缺点：目前DNS是多级解析，每一级DNS都可能缓存A记录，当下线某台服务器后，即使修改了DNS的A记录，要使其生效也需要较长的时间，这段时间DNS依然会将域名解析到已经下载的服务器，导致访问失败。而且DNS负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。 一般大型网站总是部分使用DNS域名解析，利用域名解析作为第一级负载均衡，即域名解析得到的一组服务器实际上同样是负载均衡服务器，这组内部的负载均衡服务器在进行负载均衡，将请求分发到真是的web服务器上。 反向代理负载均衡 IP负载均衡 用户请求数据包到达负载均衡服务器114.100.80.10后，负载均衡服务器在操作系统内核进程获取网络数据报，根据负载均衡算法计算得到一台真实web服务器10.0.0.1，然后将数据目的IP地址修改为10.0.0.1，不需要通过用户进程处理。处理完成之后，响应数据报回到负载均衡服务器，负载均衡服务器再将数据报源地址修改为自身的IP地址发送给用户浏览器。 真实web服务器如何将响应数据包返回给负载均衡服务器，方案是：在负载均衡服务器修改目的IP地址的同时修改源地址，将数据报原地址设为自身IP，这样web服务器的响应会再回到负载均衡服务器。 缺点：所有请求响应都必须经过负载均衡服务器，对于下载或者视频等服务，负载均衡服务器会成为瓶颈。 数据链路层负载均衡 负载均衡算法 轮询 所有请求被依次分发到每台应用服务器上。 加权轮询 在轮询的基础上，按照配置的权重将请求分发到每个服务器上，高性能的服务器能分配到更多的请求 随机 请求被随机分配到各个应用服务器上 最少连接 记录每个应用服务器正在处理的连接请求数，将新的请求分发到最少连接的服务器上。 源地址散列 根据请求来源的IP地址进行Hash计算，得到应用服务器，这样来自同一个IP地址的请求总在一个服务器上处理。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统命令]]></title>
    <url>%2F2017%2F06%2F20%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FLinux-%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一 、文件安全与权限 文件1234ls - ltotal 145456-rwxr-xr-x 1 root root 9338896 Dec 22 21:24 apache-tomcat-7.0.53.zip-rwxr-xr-x 1 root root 139444114 Dec 22 21:26 jdk-7u51-linux-i586.tar.gz total 145456：表示这个目录中所有文件占用的大小 -rwxr-xr-x： -：这个位表示文件类型 其余9个字符分别对应9个权限位，r：可读 w:可写 x:可执行 -：禁止该项操作 rwx：文件属主的权限 前三位 r-x：同组用户权限 中间三位 r-x：其他用户权限 最后三位 1：该文件的硬链接的数目 root：文件的属主 root：文件数组所在的缺省组 9338896：表示文件长度，单位是字节 Dec 22 21:24：文件最后更新时间 apache-tomcat-7.0.53.zip：文件名 文件类型d：目录 l：符号链接 s：套接字文件 b:块设备文件 c:字符设备文件 p:命名管道文件 -：普通文件 改变文件权限符号模式1chmod [who] operator [permission] filename who的含义： u：文件属主的权限 g：同组用户权限 o：其他用户权限 a：所有用户权限 operator的含义： +：增加 -：取消权限 =：设定权限 permission的含义： r：读 w:写 x:执行 绝对模式1chmod [mode] file mode含义：Mode中包含3个数， 741 第一个数代表文件属主的权限 第二个数代表文件属主同组用户权限 第三个数代表其他用户权限 每个数转换成3位的二进制，如7 转换成111， 第一位：表示读的权限，0：不可读 1：表示可读 第二位：表示写的权限 0：不可写 1：可写 第三位：表示执行权限 0：不可执行 1：可执行 12345chmod 741 code#执行之后权限 7-&gt;111:可读 可写 可执行# 4-&gt;100:可读 不可写 不可执行# 1-&gt;001:不可读 不可写 可执行-rwxr----x 1 root root 0 Jun 20 10:40 code 可同过 -R选项连同子目录下的文件一起设置权限 1chmod -R 741 /root/test/* ​ 更改文件所属用户chown,更改用户所属组chgrp1chown user filename 1chgrp group filename 符号链接 有两种不同的链接，软连接和硬链接。我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。 硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。 123456789101112#创建硬链接 source_path:真实的文件 target:创建的硬链接ln source_path target#创建软链接ln -s source_path target#查看文件属性,包括inodels -litotal 8303106 -rwxr----x 2 root root 55 Jun 21 10:23 code303106 -rwxr----x 2 root root 55 Jun 21 10:23 hard.link303108 lrwxrwxrwx 1 root root 22 Jun 21 10:31 soft -&gt; /root/apache-tomcat-7/303107 lrwxrwxrwx 1 root root 4 Jun 21 10:22 soft.link -&gt; code 303106:文件的inode，真实文件code 和硬链接hard.link的iNode是相同的 软链接文件soft.link的inode与code是不相同的，它指向了code文件 二、使用find和xargsfind命令选项1find pathname -option [-print -exec -ok] pathname:表示要查找的目录路径 name选项 12# 查找自己根目录下以 .txt结尾的文件find ~ -name "*.txt" -print 12# 查找etc目录下以Host 开头的文件find /etc -name "host*" -print 使用perm选项 12#查找当前目录下 权限是755的文件find . -perm 755 -print 忽略某个目录 prune 12#在当前目录下找含有 . 的文件，其中忽略 ./app这个文件夹find ./ -path ./app -prune -o -name "*.*" -print 使用user和nouser选项 12#在自己的根目录下找所属用户是Ubuntu的所有文件find ~ -user ubuntu -print 12#在自己的根目录下查找 属主账户被删除的所有文件find ~ -nouser -print 使用group和nogroup选项 12#在当前目录下查找 所属组是root的所有文件find ./ -group root -print 12#在当前目录下查找 所属组被删除的所哟文件find ./ -nogroup -print 按照更改时间查找文件 12#在当前目录下查找最后更改时间在5日以内的文件find ./ -mtime -5 -print 12#在当前目录下查找最后更改时间在3日之前的文件find ./ -mtime +3 -print 使用type选项 12#在当前目录下查找所有目录find ./ -type d -print 12#在当前目录下查找所有除目录以外的文件find ./ ! -type d -print 使用size选项 文件长度可以有两种衡量方式，一种是一块为单位（一块=512字节），另一种是以字节为单位，表达方式 N c(如1000c，表示1000字节)。 12#在当前目录下查找长度大于1000字节的所有文件find ./ -size +1000c 12# 在当前目录下查找长达小于1000字节的所有文件find ./ -size -1000c 12# 在当前目录下查找文件长度等于1000块的文件(1块=512字节)find ./ -size 1000 depth命令，在目录中查找，首先匹配文件，然后再在子目录中查找。 1find ./ -name "*.txt" -depth -print mount，查找是不进入其他文件系统，只在当前文件系统中查找 1find ./ -name "*.txt" -mount -print xargs命令xargs与find命令一起使用，find命令把匹配到的文件传递给xargs命令，而xargs 命令每次只获取一部分文件而不是全部，不像-exec选线那样，这样它就可以先处理最先获取的一部分文件，然后是下一批，如此继续下去。 1find ./ -type f -print | xargs file shell输入与输出cat命令 显示文件内容 1cat filename | more //分页显示文件内容，按空格显示下一页 同时显示多个文件内容 1cat file1 file2 file3 …… 将多个文件合并到一个新文件中 1cat file1 file2 file3 &gt; newfile 创建新的文件，并从标准输入（键盘）输入一些内容 1cat &gt; newfile ##输入命令后即可添加文件内容，Ctrl+D 结束输入 管道可以通过管道把一个命令的输出传递给另一个命令作为输入，管道用竖杠 |表示，一般形式是：命令1 | 命令2 tee命令把输出的一个副本拷贝到另一个文件中 1ls -l | tee -a myfile ##将列出的全部文件信息 追加到文件myfile中，如果没哟-a选项则会覆盖文件内容 进程管理命令ps浏览系统中的进程命令。 -a:列出所有进程 pstree以可视化方式显示进程，通过显示进程的树状图来展示进程之间的关系 123456789systemd-+-accounts-daemon-+-&#123;gdbus&#125; | `-&#123;gmain&#125; |-acpid |-2*[agetty] |-atd |-barad_agent-+-barad_agent | `-barad_agent---2*[&#123;barad_agent&#125;] |-cron |-dbus-daemon top监视系统中不同的进程所使用的资源。它提供实时的系统状态信息。 12345678910111213141516171819202122top - 14:59:07 up 22 days, 17:11, 1 user, load average: 0.00, 0.01, 0.00Tasks: 129 total, 2 running, 127 sleeping, 0 stopped, 0 zombie%Cpu(s): 1.3 us, 0.7 sy, 0.0 ni, 97.7 id, 0.3 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 893032 total, 71288 free, 516640 used, 305104 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 230560 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 25867 root 20 0 36492 18800 5220 R 0.7 2.1 35:45.28 sap1009 5679 root 20 0 14704 3032 2604 S 0.3 0.3 0:43.49 sap1006 1 root 20 0 6776 3996 2660 S 0.0 0.4 0:16.37 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:31.20 ksoftirqd/0 5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 7 root 20 0 0 0 0 S 0.0 0.0 14:08.48 rcu_sched 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh 9 root rt 0 0 0 0 S 0.0 0.0 0:00.00 migration/0 10 root rt 0 0 0 0 S 0.0 0.0 0:04.88 watchdog/0 11 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kdevtmpfs 12 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 netns 13 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 perf 14 root 20 0 0 0 0 S 0.0 0.0 0:00.46 khungtaskd 15 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 writeback nice设置和修改进程的优先级。默认情况下，进程以0的优先级启动。 1nice --3 top ##给top命令设置优先级-3 Kill结束进程 12kill 123 ##结束进程ID为123的进程kill -9 123 ##强制结束进程123 w显示当前登录用户及其执行的进程信息。 1234root@VM-58-249-ubuntu:~# w 15:12:31 up 22 days, 17:24, 1 user, load average: 0.14, 0.08, 0.04USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 222.195.151.10 13:38 3.00s 0.12s 0.00s w who显示当前所有登录的用户信息 12root@VM-58-249-ubuntu:~# whoroot pts/0 Aug 22 13:38 (222.195.151.10) whoami显示当前用户的用户名 12root@VM-58-249-ubuntu:~# whoamiroot]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>shell命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——适配器模式]]></title>
    <url>%2F2017%2F06%2F19%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式：将一个类的接口转换成客户希望的另一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 被适配的对象，即含有特殊功能的类，客户端需要调用这个类中的特殊功能，但是因为接口不匹配，所以不能调用， 12345678910/** * 被适配的对象,含有特殊的功能 */class Adaptee&#123; public void spacialRequest() &#123; System.out.println("被适配的对象,具有的特殊功能"); &#125;&#125; 适配器， 12345678910/** * 适配器对象 */class Adapter extends Adaptee implements Target&#123; public void request() &#123; super.spacialRequest(); &#125;&#125; 抽象的目标类 1234567/** * 目标对象接口 */interface Target&#123; void request();&#125; 抽象目标类的具体实现，只含有普通的功能 12345678910/** * 目标对象的实现,含有的是普通的功能 */class ConcreateTarget implements Target&#123; public void request() &#123; System.out.println("普通的需求"); &#125;&#125; 测试类 12345678910public class AdapterDemo&#123; public static void main(String[] args) &#123; Target commonTarget = new ConcreateTarget(); commonTarget.request(); Target adapter = new Adapter(); adapter.request(); &#125;&#125; 12普通的需求被适配的对象,具有的特殊功能]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——观察者模式]]></title>
    <url>%2F2017%2F06%2F19%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式：观察者模式有佳作发布-订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。 Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。 ConcrereObserver：具体观察者，是实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 下面是一个微信工作号发布-订阅的一个例子： 抽象的观察者 1234abstract class Observer&#123; public abstract void update(String message);&#125; 具体的观察者对象：微信用户 1234567891011121314class WechatUser extends Observer&#123; private String userName; public WechatUser(String userName) &#123; this.userName = userName; &#125; public void update(String message) &#123; System.out.println(this.userName + " " + message); &#125;&#125; 抽象的主题类： 12345678abstract class Subject&#123; public abstract void attach(Observer observer); public abstract void detach(Observer observer); public abstract void notify(String message);&#125; 具体的一个主题，主题可以有多个，这里列举了一个 12345678910111213141516171819202122232425262728class WechatSubject extends Subject&#123; private ArrayList&lt;Observer&gt; users = new ArrayList&lt;Observer&gt;(); private String name; public WechatSubject(String name) &#123; this.name = name; &#125; public void attach(Observer observer) &#123; users.add(observer); &#125; public void detach(Observer observer) &#123; users.remove(observer); &#125; public void notify(String message) &#123; for (Observer user : users) &#123; user.update(name + message); &#125; &#125;&#125; 测试类： 1234567891011121314151617public class ObserverDemo&#123; public static void main(String[] args) &#123; Observer user1 = new WechatUser("张三"); Observer user2 = new WechatUser("李四"); Observer user3 = new WechatUser("王五"); Subject subject = new WechatSubject("科技前沿"); subject.attach(user1); subject.attach(user2); subject.attach(user3); subject.notify("添加了一篇文章&lt;&lt;云计算&gt;&gt;"); System.out.println(); subject.notify("添加了一篇文章&lt;&lt;大数据时代&gt;&gt;"); &#125;&#125; 测试输出： 1234567张三 科技前沿添加了一篇文章&lt;&lt;云计算&gt;&gt;李四 科技前沿添加了一篇文章&lt;&lt;云计算&gt;&gt;王五 科技前沿添加了一篇文章&lt;&lt;云计算&gt;&gt;张三 科技前沿添加了一篇文章&lt;&lt;大数据时代&gt;&gt;李四 科技前沿添加了一篇文章&lt;&lt;大数据时代&gt;&gt;王五 科技前沿添加了一篇文章&lt;&lt;大数据时代&gt;&gt;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——建造者模式]]></title>
    <url>%2F2017%2F06%2F19%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造者模式：将一个复杂对象的建造与它的表示分离，是得同样的构建过程可以创建不同的表示。 House：产品类，需要建造的产品 123456789101112131415class House&#123; private ArrayList&lt;String&gt; parts = new ArrayList&lt;String&gt;(); public void addPart(String part) &#123; parts.add(part); &#125; public void showHous() &#123; for (String part : parts) System.out.println(part); &#125;&#125; Builder：建造House的抽象类，定义了建造各部分的接口 12345678910abstract class AbstractHouseBuilder&#123; public abstract void buildWindow(); public abstract void buildDoor(); public abstract void buildWall(); public abstract House getHouse();&#125; Builder：建造的具体实现了，有不同的实现方式，对每个部件提供具体的建造方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class HouseBuilder1 extends AbstractHouseBuilder&#123; private House house = new House(); public void buildWindow() &#123; house.addPart("铝合金窗户"); &#125; public void buildDoor() &#123; house.addPart("铝合金门"); &#125; public void buildWall() &#123; house.addPart("白色墙"); &#125; public House getHouse() &#123; return house; &#125;&#125;class HouseBuilder2 extends AbstractHouseBuilder&#123; private House house = new House(); public void buildWindow() &#123; house.addPart("木质窗户"); &#125; public void buildDoor() &#123; house.addPart("木质门"); &#125; public void buildWall() &#123; house.addPart("木质纹理墙"); &#125; public House getHouse() &#123; return house; &#125;&#125; Director：指挥者，负责建造的过程的流程控制，每个步骤需要做什么 123456789class Director&#123; public void CreateHouse(AbstractHouseBuilder builder) &#123; builder.buildWall(); builder.buildWindow(); builder.buildDoor(); &#125;&#125; 测试类 12345678910111213141516171819public class BuilderDemo&#123; public static void main(String[] args) &#123; Director director = new Director(); AbstractHouseBuilder builder1 = new HouseBuilder1(); AbstractHouseBuilder builder2 = new HouseBuilder2(); System.out.println("房屋一:"); director.CreateHouse(builder1); House house1 = builder1.getHouse(); house1.showHous(); System.out.println("\n房屋二:"); director.CreateHouse(builder2); House house2 = builder2.getHouse(); house2.showHous(); &#125;&#125; 输出结果： 123456789房屋一:白色墙铝合金窗户铝合金门房屋二:木质纹理墙木质窗户木质门]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>建造模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——外观模式]]></title>
    <url>%2F2017%2F06%2F19%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观类： 123456789101112131415161718192021222324class Fund&#123; private Sokect1 sokect1 = new Sokect1(); private Sokect2 sokect2 = new Sokect2(); private Sokect3 sokect3 = new Sokect3(); public void buyFund() &#123; System.out.println("买入基金,包括以下操作:"); sokect1.buySokect(); sokect2.buySokect(); sokect3.buySokect(); System.out.println(); &#125; public void sellFund() &#123; System.out.println("卖出基金,包括以下操作"); sokect1.sellSokect(); sokect1.sellSokect(); sokect1.sellSokect(); System.out.println(); &#125;&#125; 子类： 1234567891011121314151617181920212223242526272829303132333435363738class Sokect1&#123; public void buySokect() &#123; System.out.println("购买股票一!"); &#125; public void sellSokect() &#123; System.out.println("卖出股票一"); &#125;&#125;class Sokect2&#123; public void buySokect() &#123; System.out.println("购买股票二!"); &#125; public void sellSokect() &#123; System.out.println("卖出股票二"); &#125;&#125;class Sokect3&#123; public void buySokect() &#123; System.out.println("购买股票三!"); &#125; public void sellSokect() &#123; System.out.println("卖出股票三"); &#125;&#125; 测试类： 123456789public class FacadeDemo&#123; public static void main(String[] args) &#123; Fund fund = new Fund(); fund.buyFund(); fund.sellFund(); &#125;&#125; 输出： 123456789买入基金,包括以下操作:购买股票一!购买股票二!购买股票三!卖出基金,包括以下操作卖出股票一卖出股票二卖出股票三]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——模板方法模式]]></title>
    <url>%2F2017%2F06%2F15%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式，定义一个操作中的算法骨架，而将一些不走延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式是通过把不变行为版移到超类中，去除子类中的重复代码，提供了一个很好的代码复用平台。 抽象的模板类：把所有重复的代码集成到模板方法中 12345678910111213abstract class AbstractClass&#123; public abstract void primitiveOperation1(); public abstract void primitiveOperation2(); public void templateMethod() &#123; primitiveOperation1(); primitiveOperation2(); System.out.println("模板方法"); &#125;&#125; 具体实现类一： 1234567891011class ConCreateClassA extends AbstractClass&#123; public void primitiveOperation1() &#123; System.out.println(this.getClass().getName() + " 操作一"); &#125; public void primitiveOperation2() &#123; System.out.println(this.getClass().getName() + " 操作二"); &#125;&#125; 具体实现二： 123456789101112class ConCreateClassB extends AbstractClass&#123; public void primitiveOperation1() &#123; System.out.println(this.getClass().getName() + " 操作一"); &#125; public void primitiveOperation2() &#123; System.out.println(this.getClass().getName() + " 操作二"); &#125;&#125; 测试类： 12345678910public class TemplateDemo&#123; public static void main(String[] args) &#123; AbstractClass a = new ConCreateClassA(); AbstractClass b = new ConCreateClassB(); a.templateMethod(); b.templateMethod(); &#125;&#125; 模版方法模式的结构 模版方法模式由一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种： 抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。 模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。 钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。 抽象类的任务是搭建逻辑的框架，通常由经验丰富的人员编写，因为抽象类的好坏直接决定了程序是否稳定性。 下面用一个排序算法的例子说明： 抽象的排序算法类：定义了一个抽象排序算法方法，和一个显示排序结果的模板方法类。 1234567891011121314abstract class AbstractSort&#123; public abstract void sort(int[] arr); public void showSortResult(int[] arr) &#123; sort(arr); System.out.println("排序后结果:"); for (int i = 0; i &lt; arr.length; i++) System.out.print(arr[i] + " "); System.out.println(); &#125;&#125; 冒泡排序算法的实现类： 1234567891011121314151617181920class BubleSort extends AbstractSort&#123; public void sort(int[] arr) &#123; int len = arr.length; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 选择排序的实现类： 123456789101112131415161718class InsertSort extends AbstractSort&#123; public void sort(int[] arr) &#123; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; int temp = arr[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; arr[j + 1] = arr[j]; j--; &#125; arr[++j] = temp; &#125; &#125;&#125; 测试类： 12345678910public class TemplateDemo&#123; public static void main(String[] args) &#123; AbstractSort bubleSort = new BubleSort(); bubleSort.showSortResult(new int[]&#123;4, 6, 1, 6, 3, 6, 9, 2, 0&#125;); AbstractSort insertSort = new InsertSort(); insertSort.showSortResult(new int[]&#123;6, 3, 5, 1, 4, 7, 9, 4, 2, 0&#125;); &#125;&#125; 结果： 1234排序后结果:0 1 2 3 4 6 6 6 9 排序后结果:0 1 2 3 4 4 5 6 7 9 参考：http://www.importnew.com/15546.html]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——原型模式]]></title>
    <url>%2F2017%2F06%2F15%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 原型模式原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何的创建细节。下面我们通过一个例子来说明，对用户信息的复制。 原型类：实现Cloneable接口，表明这个类是可以复制的，复制方法直接用调用本地的Native方法复制。 123456789101112131415abstract class Prototype implements Cloneable&#123; @Override public Object clone() &#123; try &#123; return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 用户信息类：UserInfo 继承了Prototype，clone方法直接调用Prototype的克隆方法 1234567891011121314151617181920212223242526272829class UserInfo extends Prototype&#123; String name; String birthDate; String address; University university; public UserInfo(String birthDate, String address, String name, University university) &#123; this.birthDate = birthDate; this.address = address; this.name = name; this.university = university; &#125; @Override public String toString() &#123; return "UserInfo&#123;" + "name='" + name + '\'' + ", birthDate='" + birthDate + '\'' + ", address='" + address + '\'' + ", university=" + university + '&#125;'; &#125; @Override public Object clone() &#123; return super.clone(); &#125;&#125; University类： 123456789101112131415class University&#123; String uName; public University(String uName) &#123; this.uName = uName; &#125; @Override public String toString() &#123; return "&#123;" + "uName='" + uName + '\'' + '&#125;'; &#125;&#125; 测试类： 12345678910public class PrototypeDemo&#123; public static void main(String[] args) throws CloneNotSupportedException &#123; UserInfo info = new UserInfo("张三", "1990-03-23", "山东青岛"); UserInfo infoCopy = (UserInfo) info.clone(); System.out.println(info); System.out.println(infoCopy); &#125;&#125; 输出结果： 12UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;青岛大学&apos;&#125;&#125;UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;青岛大学&apos;&#125;&#125; 原型模式的优点及适用场景 使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。 ​ 因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。 浅拷贝与深拷贝浅拷贝Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如上面的例子中，用户信息中有一个对象是所在的大学，对university字段进行如下修改： 12345UserInfo info = new UserInfo("张三", "1990-03-23", "山东青岛",new University("青岛大学"));UserInfo infoCopy = (UserInfo) info.clone();infoCopy.university.uName="中国海洋大学";System.out.println(info);System.out.println(infoCopy); 输出结果是： 12UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;中国海洋大学&apos;&#125;&#125;UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;中国海洋大学&apos;&#125;&#125; infoCopy是info的一份拷贝，对infoCopy的修改原则上info中的信息是不会变得，但是Object中的clone方法只是一个浅拷贝，浅拷贝只会拷贝8种基本数据类型和String，对于数组、容器、引用对象只是拷贝对其的引用。 深拷贝深拷贝就是对对象中的所有数据进行拷贝，包括基本数据类型和引用对象。具体实现就是必须将原型模式中数组对象、引用对象、容器对象等进行单独的拷贝。 UserInfo对象中clone方法修改： 1234567891011121314151617class UserInfo extends Prototype&#123; …… @Override public Object clone() &#123; UserInfo info = (UserInfo) super.clone(); try &#123; info.university = (University) this.university.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return info; &#125;&#125; University类中添加clone方法： 123456789class University implements Cloneable&#123; …… @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 输出结果： 12UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;青岛大学&apos;&#125;&#125;UserInfo&#123;name=&apos;山东青岛&apos;, birthDate=&apos;张三&apos;, address=&apos;1990-03-23&apos;, university=&#123;uName=&apos;中国海洋大学&apos;&#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——代理模式模式]]></title>
    <url>%2F2017%2F06%2F14%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理（proxy）提供对目标对象的另外一种访问方式，即通过代理对象访问目标对象。这样做的好处就是：可以在目标对象的基础之上增强额外的功能操作，即扩展目标对象的功能。 编程思想：不要随便修改别人已经写好的功能方法，如果要修改可以通过代理的方式来扩展该方法。 静态代理静态代理代理对象和被代理对象一起实现相同的接口，或者是继承相同的父类。 接口父类： 123public interface IUserDAO&#123; void save();&#125; 目标对象： 12345public class UserDAO implement IUserDAO&#123; public void save()&#123; System.out.println("数据正在保存！"); &#125;&#125; 代理对象： 1234567891011public class UserDAOProxy implement IUserDAO&#123; private IUserDAO target； public UserDAOProxy(IUserDAO target)&#123; this.target=target; &#125; public void save()&#123; System.out.println("数据校验完毕，开始保存数据！"); target.save(); //执行目标方法 System.out.println("数据保存完毕！"); &#125;&#125; 测试类： 123456789public class Main&#123; public static void main(String[]args)&#123; //创建目标对象 IUserDAO target = new UserDAO(); //代理对象，把目标对象传给代理对象，建立代理关系 UserDAOProxy proxy = new UserDAOProxy(target); proxy.save(); &#125;&#125; 静态代理可以在不修改目标对象的前提下实现对目标对象的扩展， 缺点：但是静态代理必须要实现与目标对象一样的接口，这样就会产生很多代理类，类很多。一旦接口方法增加，目标对象和代理对象都要进行维护修改。 动态代理动态代理主要有两种方法，一种是JDK动态代理，一种是第三方库 cglib动态代理。 JDK动态代理jdk动态代理是基于Java反射机制实现的。 Proxy代理类，通过newInstance()方法，创建代理类。 1234public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException ClassLoader loader：被代理对象的类加载器 Class&lt;?&gt;[] interfaces:被代理对象中实现的接口类型 InvocationHandler h：事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入 下面是测试样例 父类接口： 12345interface IUserDAO&#123; void save(); void delete();&#125; 目标对象，实现父类接口 123456789101112131415class UserDAO implements IUserDAO&#123; @Override public void save() &#123; System.out.println("user info saving..."); &#125; @Override public void delete() &#123; System.out.println("user is delete!"); &#125;&#125; InvocationHandler类，每个代理 的实例都关联了一个handler，每个代理对象调用方法时候，都会转变为有InvocationHandler调用invoke()方法。 123456789101112131415161718class ProxyHandler implements InvocationHandler&#123; private Object target; public ProxyHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("代理方法 " + method.getName() + " 开始"); Object res = method.invoke(target, args); System.out.println("代理方法 " + method.getName() + " 结束"); return res; &#125;&#125; 测试类 1234567891011121314151617public class JDKProxy&#123; public static void main(String[] args) &#123; //目标对象，即被代理对象 IUserDAO target = new UserDAO(); //我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 ProxyHandler proxyHandler = new ProxyHandler(target); IUserDAO userDAO = (IUserDAO）Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), target.getClass().getInterfaces(), proxyHandler); userDAO.save(); userDAO.delete(); &#125;&#125; 代理方法 save 开始 user info saving… 代理方法 save 结束 代理方法 delete 开始 user is delete! 代理方法 delete 结束 jdk动态代理生成代理对象速度快，但是有一个局限就是被代理对象必须实现接口，若被代理对象没有实现接口，将不能进行jdk动态代理。 第三方库CGLib动态代理CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。 被代理对象： 1234567class UserDaoImpl&#123; void save() &#123; System.out.println("info saved!"); &#125;&#125; 123456789101112131415161718192021222324252627class CglibProxy implements MethodInterceptor&#123; private Object target; public CglibProxy() &#123; &#125; public CglibProxy(Object target) &#123; this.target = target; &#125; @Override public Object intercept(Object arg0, Method method, Object[] arg2, MethodProxy proxy) throws Throwable &#123; System.out.println("before proxy!"); // 两种方式调用都行 // 第一种 JDK反射机制 method.invoke(target, arg2); // 第二种 这种方法速度更快 Object object = proxy.invokeSuper(arg0, arg2); System.out.println("end proxy!"); return object; &#125;&#125; 123456789101112public static void main(String[] args) &#123; Enhancer enhancer = new Enhancer(); CglibProxy proxy = new CglibProxy(new UserDaoImpl()); enhancer.setCallback(proxy); enhancer.setSuperclass(UserDaoImpl.class); UserDaoImpl userDaoImpl = (UserDaoImpl) enhancer.create(); userDaoImpl.save(); &#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——装饰器模式]]></title>
    <url>%2F2017%2F06%2F13%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰器模式：在不必改变原有类文件和使用继承的情况下，动态的扩展一个对象的功能。他是通过创建一个包装对象也就是装饰来包裹真实的对象。 装饰器模式：在不改变接口的前提下，动态的扩展对象的功能。 代理模式：在不改变接口的前提下，控制对象的访问 下面是装饰器的结构图： 下面通过一个例子来说明装饰器模式的用法： 抽象的person类 1234abstract class Person&#123; //显示人的信息 public abstract void show();&#125; 具体的Man类，继承自person 12345678910111213class Man extends Person&#123; //人的姓名 private String name; public Man(String name) &#123; this.name = name; &#125; @Override public void show() &#123; System.out.println(name + "的装扮"); &#125;&#125; 抽象装饰类 123456789101112131415abstract class Decorator extends Person&#123; //这是装饰器模式的核心 private Person person; public void setPerson(Person person) &#123; this.person = person; &#125; @Override public void show() &#123; this.person.show(); &#125;&#125; 具体的装饰类： 123456789101112131415161718192021222324252627282930//T恤装饰类class TshirtsDecorator extends Decorator&#123; @Override public void show() &#123; super.show(); System.out.println("装扮了T恤!"); &#125;&#125;//鞋子装饰类class ShoesDecorator extends Decorator&#123; @Override public void show() &#123; super.show(); System.out.println("装扮了鞋子!"); &#125;&#125;//裤子装饰类class TouserDecorator extends Decorator&#123; @Override public void show() &#123; super.show(); System.out.println("装扮了裤子!"); &#125;&#125; 测试类： 123456789101112131415161718public class DecoratorDemo&#123; public static void main(String[] args) &#123; Person man = new Man("张三"); //给man装饰上T恤 TshirtsDecorator tperson = new TshirtsDecorator(); tperson.setPerson(man); //给前面的装饰好的man 继续装饰裤子 TouserDecorator touserPerson = new TouserDecorator(); touserPerson.setPerson(tperson); //给前面的装饰好的man 继续装饰鞋子 ShoesDecorator sperson = new ShoesDecorator(); sperson.setPerson(touserPerson); //此时sperson装饰好了T恤、裤子、鞋子，显示全部的装扮 sperson.show(); &#125;&#125; 显示结果： 1234张三的装扮装扮了T恤!装扮了裤子!装扮了鞋子!]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>装饰器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——策略模式]]></title>
    <url>%2F2017%2F06%2F12%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式定义：它定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化不会影响到使用算法的客户 下图是策略模式的结构图： 使用场景： 某商场对不同会员实行不同的优惠策略： 初级会员，对于购买的所有商品全部98折 中级会员，对于购买的所有商品全部8折 高级会员，对于购买的所欲商品全部65折 抽象的折扣类： 1234interface MemberStrategy&#123; double calcPrice(double price);&#125; 初级、中级、高级会员的具体折扣类： 1234567891011121314151617181920212223242526class PrimaryMemberStrategy implements MemberStrategy&#123; public double calcPrice(double price) &#123; System.out.println("初级会员优惠:98折"); return price * 0.98; &#125;&#125;class IntermediateMemberStrategy implements MemberStrategy&#123; public double calcPrice(double price) &#123; System.out.println("中级会员优惠:8折"); return price * 0.8; &#125;&#125;class AdvanceMemberStrategy implements MemberStrategy&#123; public double calcPrice(double price) &#123; System.out.println("高级会员优惠:65折"); return price * 0.65; &#125;&#125; 价格环境类： 123456789101112131415class PriceContext&#123; //持有一个具体的策略对象 private MemberStrategy strategy; public PriceContext(MemberStrategy strategy) &#123; this.strategy = strategy; &#125; //计算对应策略后的价格 public double getMoney(double price) &#123; return strategy.calcPrice(price); &#125;&#125; 客户端测试类： 1234567891011public class StrategyDemo&#123; public static void main(String[] args) &#123; MemberStrategy strategy = new IntermediateMemberStrategy(); PriceContext context = new PriceContext(strategy); double money = 78.6; System.out.print("原价:" + money + " \n"); System.out.printf("会员折扣后优惠:%.2f", context.getMoney(money)); &#125;&#125; 策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。 策略模式的优点 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 策略模式的缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——单例模式]]></title>
    <url>%2F2017%2F06%2F11%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式是指在程序运行过程中，一个单例类只有有一个实例化对象，并且该类自己负责创建类的实例。 单例模式的实现方式有一下几种 饿汉式单例 它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 1234567891011class Singleton1&#123; private Singleton1() &#123; &#125; private static Singleton1 instance = new Singleton1(); public static Singleton1 getInstance() &#123; return instance; &#125;&#125; 非线程安全的 懒汉式单例 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 12345678910111213class Singleton2&#123; private Singleton2() &#123; &#125; private static Singleton2 instance; public static Singleton2 getInstance() &#123; if (instance == null) instance = new Singleton2(); return instance; &#125;&#125; 线程安全的懒汉式单例 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 12345678910111213class Singleton3&#123; private Singleton3() &#123; &#125; private static Singleton3 instance; public synchronized static Singleton3 getInstance() &#123; if (instance == null) instance = new Singleton3(); return instance; &#125;&#125; 双重检验线程安全的 懒汉式单例 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 12345678910111213141516171819class Singleton4&#123; private Singleton4() &#123; &#125; private static Singleton4 instance; public static Singleton4 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton4.class) &#123; if (instance == null) instance = new Singleton4(); &#125; &#125; return instance; &#125;&#125; 静态内部类 单例 1234567891011121314class Singleton5&#123; private static class SingletonHoder &#123; private static Singleton5 INSTANCE = new Singleton5(); &#125; private Singleton5() &#123; &#125; public static Singleton5 getInstance() &#123; return SingletonHoder.INSTANCE; &#125;&#125; 枚举类型单例 12345678enum Singleton6&#123; INSTANCE; public void method() &#123; System.out.println("test"); &#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——抽象工厂模式]]></title>
    <url>%2F2017%2F06%2F11%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[现实生活中一个工厂可能生产多个产品，而工厂方法模式中一个具体的工厂类只负责生产一种产品，随着产品的逐渐增多工厂类也会随之增多，这显然是不合理的。 抽象工厂模式是在工厂方法模式的基础之上增强了工厂类，一个工厂类可以生产多个产品。 抽象工厂模式组成： 抽象工厂：这是工厂方法模式的核心，是具体工厂必须实现的接口或继承的父类。 具体工厂：负责生产具体的产品实例，实现了抽象工厂接口。 抽象产品：具体产品的父类或必须实现的接口，定义了产品必须含有的方法或属性 具体产品类：这是具体工厂创建的实例。 产品类：Button 123456789101112131415161718interface Button&#123; void btnClick();&#125;class WinButton implements Button&#123; public void btnClick() &#123; System.out.println("Windos button clicked!"); &#125;&#125;class LinuxButton implements Button&#123; public void btnClick() &#123; System.out.println("Linux button clicked!"); &#125;&#125; 产品类：Text 123456789101112131415161718interface Text&#123; void textWrite();&#125;class WinText implements Text&#123; public void textWrite() &#123; System.out.println("windows text written!"); &#125;&#125;class LinuxText implements Text&#123; public void textWrite() &#123; System.out.println("Linux text written!"); &#125;&#125; 工厂类： 12345678910111213141516171819202122232425262728interface ComponentFactory&#123; Button createButton(); Text createText();&#125;//window组件制造工厂class WindowsFactory implements ComponentFactory&#123; public Button createButton() &#123; return new WinButton(); &#125; public Text createText() &#123; return new WinText(); &#125;&#125;//Linux组件制造工厂class LinuxFactory implements ComponentFactory&#123; public Button createButton() &#123; return new LinuxButton(); &#125; public Text createText() &#123; return new LinuxText(); &#125; 测试类： 12345678910111213141516public class AbstractFactoryDemo&#123; public static void main(String[] args) &#123; ComponentFactory linuxFactory = new LinuxFactory(); ComponentFactory windowsFactory = new WindowsFactory(); Button winButton = windowsFactory.createButton(); Button linuxButton = linuxFactory.createButton(); winButton.btnClick(); linuxButton.btnClick(); Text winText = windowsFactory.createText(); Text linuxText = linuxFactory.createText(); winText.textWrite(); linuxText.textWrite(); &#125;&#125; 工厂方法模式和抽象工厂模式对比 首先两者都有抽象的工厂类、具体的工厂类、抽象的产品类和具体的产品类 工厂方法模式只有一个产品类，而抽象工厂模式中有多个产品类 工厂方法模式中一个具体的工厂类只能生产一个具体产品类；而在抽象工厂模式中，一个共产类可以生产出多个具体的产品类。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——工厂方法模式]]></title>
    <url>%2F2017%2F06%2F11%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂方法模式将简单工厂模式中的工厂类抽取出来，用子工厂具体负责生产具体类产品。这样在产品生产的压力可以由工厂方法模式中的不同工厂子类来分担。 工厂方法模式组成： 抽象工厂：这是工厂方法模式的核心，是具体工厂必须实现的接口或继承的父类。 具体工厂：负责生产具体的产品实例，实现了抽象工厂接口。 抽象产品：具体产品的父类或必须实现的接口，定义了产品必须含有的方法或属性 具体产品类：这是具体工厂创建的实例。 产品类： 1234567891011121314151617181920//产品抽象接口interface Color&#123; void fill();&#125;//产品实例class Green implements Color&#123; //产品方法 public void fill() &#123; System.out.println("fill color Green!"); &#125;&#125;class Red implements Color&#123; public void fill() &#123; System.out.println("fill color Red!"); &#125;&#125; 工厂类： 123456789101112131415161718192021//工厂抽象接口interface ColorFactory&#123; Color createColor();&#125;// 子工厂类，负责生产具体的实例class GreenFactory implements ColorFactory&#123; public Color createColor() &#123; return new Green(); &#125;&#125;class RedFactory implements ColorFactory&#123; public Color createColor() &#123; return new Red(); &#125;&#125; 测试类： 123456789101112public class FactoryMethodDemo&#123; public static void main(String[] args) &#123; ColorFactory gFactory = new GreenFactory(); ColorFactory rFactory = new RedFactory(); Color green = gFactory.createColor(); Color red = rFactory.createColor(); green.fill(); red.fill(); &#125;&#125; 简单工厂模式 vs. 工厂方法模式 简单工厂模式：最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 工厂方法模式：客户端需要决定实例化哪个工厂来实现运算类，选择判断的问题还是存在的。工厂方法吧内部逻辑判断移到了客户端 代码进行，想要增加功能，原先是修改工厂类，现在是修改客户端。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——简单工厂模式]]></title>
    <url>%2F2017%2F06%2F10%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式是最常见的一种设计模式之一，这种类型的设计模式属于创建型模式，提供了一种创建对象的最佳方式 简单工厂模式又称静态工厂方法模式，构建一个创建对象实例的工厂方法，创建对象是不会向用户暴露创建逻辑，通过用户传入的具体参数创建不同的对象。 组成： 抽象产品类：它是具体产品类的父类或者实现接口 具体产品类：工厂类创建的对象就是这些具体的产品类 工厂类：负责具体产品的创建，是这个模式的核心。 具体实例： 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 Hibernate 换数据库只需换方言和驱动就可以。 产品类： 123456789101112131415161718192021//shape接口interface Shape&#123; void draw();&#125;//具体的shape实现类Rectangleclass Rectangle implements Shape&#123; public void draw() &#123; System.out.println(this.getClass().getName() + ": draw method!"); &#125;&#125;//具体的shape实现类Circleclass Circle implements Shape&#123; public void draw() &#123; System.out.println(this.getClass().getName() + ": draw method!"); &#125;&#125; 工厂类： 12345678910111213141516//工厂类class Factory&#123; //工厂类中负责创建shape的工厂方法 public Shape createShap(String tag) &#123; if (tag.equals("Rectangle")) &#123; return new Rectangle(); &#125; else if (tag.equals("Circle")) &#123; return new Circle(); &#125; return null; &#125;&#125; 测试类： 123456789101112public class FactoryDemo&#123; public static void main(String[] args) &#123; Factory factory = new Factory(); //通过工厂方法创建一个shape实例 Rectangle Shape rectangle = factory.createShap("Rectangle"); Shape circle = factory.createShap("Circle"); rectangle.draw(); circle.draw(); &#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm项目中问题]]></title>
    <url>%2F2017%2F06%2F04%2Fjava%2Fblog%2Fssm%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[mybatis 构造SQL语句参数传递mybatis参数传递通过paramType来限定参数类型，具体包括下面几种 基本数据类型 Java实体类、Map 通过注解方式传递多个参数 基本数据类型参数示例123&lt;select id="selectTeacher" parameterType="int" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#&#123;id&#125; &lt;/select&gt; 1List&lt;Teacher&gt; tList = teacherMapper.selectTeacher(2); Java实体类型参数示例123&lt;select id="selectTeacher" parameterType="com.myapp.domain.Teacher" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#&#123;id&#125; &lt;/select&gt; 123Teacher queryTeacher=new Teacher(); queryTeacher.setId(2); List&lt;Teacher&gt; tList = teacherMapper.selectTeacher(queryTeacher); Map参数示例123&lt;select id="selectTeacher" parameterType="map" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#&#123;id&#125; and sex=#&#123;sex&#125; &lt;/select&gt; 1234Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;(); map.put("id","2"); map.put("sex","男"); List&lt;Teacher&gt; tList = teacherMapper.selectTeacher(map); 通过注解方式传递多个参数接口方法 1public List&lt;Teacher&gt; selectTeacher(@Param(value="id") String id,@Param(value="sex") String sex); 123&lt;select id="selectTeacher" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#&#123;id&#125; and sex=#&#123;sex&#125; &lt;/select&gt; 1List&lt;Teacher&gt; tList = teacherMapper.selectTeacher("2","男"); springMVC中日期参数传递日期参数在springMVC中无法直接转换，需要添加额外的转换器。 首先controller中添加一个@initBiner方法 1234567891011public class GoodsAction extends BaseAction&#123; @InitBinder protected void initBinder(WebDataBinder binder) &#123; SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); dateFormat.setLenient(false); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false)); &#125; ……&#125; mybatis中日期插入1234567&lt;insert id="insertItem" parameterType="TimeLimitPurchase"&gt; insert into t_time_limit_purchase (goods_id,begin_time,end_time) values (#&#123;goods.goodsId,jdbcType=INTEGER&#125;, #&#123;beginTime,jdbcType=TIMESTAMP&#125;,#&#123;endTime,jdbcType=TIMESTAMP&#125;)&lt;/insert&gt;]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解Annotation]]></title>
    <url>%2F2017%2F05%2F21%2Fjava%2Fblog%2FJava-%E6%B3%A8%E8%A7%A3Annotation%2F</url>
    <content type="text"><![CDATA[从JDK5开始，Java增加了Annotation(注解)，Annotation是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。 注解作用 生成文档。这是最常见的，也是Java 最早提供的注解。常用的有@see @param @return 等 跟踪代码依赖性，实现代替配置文件的功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量。 在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。 注解Annotation定义定义新的注解类型时使用@interface，与接口定义很相似只是多了一个@符号 123public @interface FirstAnnotation&#123;&#125; 定义完Annotation之后就可以在程序中使用该Annotation。Annotation一般放在所有修饰符之前，并且单独一行 1234@FirstAnnotationpublic class Test&#123;&#125; Annotation成员变量​ Annotation只有成员变量，没有方法。Annotation的成员变量在Annotation定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 12345public @interface FirstAnnotation&#123; public String name(); public int age();&#125; ​ 一旦在Annotation中定义了成员变量之后，使用该Annotation时就应该为该Annotation的成员变量指定值。 1234@FirstAnnotation(name = "李四", age = 16)public class Test&#123;&#125; ​ Annotation定义成员变量时可以指定默认值，指定默认值之后。使用Annotation时，已经指定默认值得变量若没有指定值，则会直接使用默认值。 12345public @interface FirstAnnotation&#123; public String name() default "张三"; public int age();&#125; ​ 使用含有默认值的Annotation，如上面name指定了默认值，使用的时候就可以不再对其赋值；而age没有指定默认值，使用时必须对其赋值。 1234@FirstAnnotation(age = 16)public class Test&#123;&#125; 根据Annotation是否包含成员变量，可以把Annotation分为如下两类： 标记Annotation：没有成员变量的Annotation被称为标记。这种Annotation仅用自身的存在与否来为我们提供信息，例如@override等。 元数据Annotation：包含成员变量的Annotation。因为它们可以接受更多的元数据，因此被称为元数据Annotation。 元注解在定义Annotation时，也可以使用JDK提供的元注解来修饰Annotation定义。JDK提供了如下4个元注解（注解的注解，不是上述的”元数据Annotation“）： @Retention @Target @Documented @Inherited @Retention@Retention用于指定Annotation可以保留多长时间。 @Retention包含一个名为“value”的成员变量，该value成员变量是RetentionPolicy枚举类型。使用@Retention时，必须为其value指定值。 RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器编译时，直接丢弃这种Annotation。 RetentionPolicy.CLASS：编译器把Annotation记录在class文件中。当运行Java程序时，JVM中不再保留该Annotation。 RetentionPolicy.RUNTIME：编译器把Annotation记录在class文件中。当运行Java程序时，JVM会保留该Annotation，程序可以通过反射获取该Annotation的信息。 1234@Retention(RetentionPolicy.RUNTIME)public @interface FirstAnnotation&#123;&#125; @Target@Target指定Annotation用于修饰哪些程序元素。@Target也包含一个名为”value“的成员变量，该value成员变量类型为ElementType[ ]，ElementType为枚举类型，值有如下几个： ElementType.TYPE：能修饰类、接口或枚举类型 ElementType.FIELD：能修饰成员变量 ElementType.METHOD：能修饰方法 ElementType.PARAMETER：能修饰参数 ElementType.CONSTRUCTOR：能修饰构造器 ElementType.LOCAL_VARIABLE：能修饰局部变量 ElementType.ANNOTATION_TYPE：能修饰注解 ElementType.PACKAGE：能修饰包 @Documented如果定义注解A时，使用了@Documented修饰定义，则在用javadoc命令生成API文档后，所有使用注解A修饰的程序元素，将会包含注解A的说明。 @Inherited@Inherited指定Annotation具有继承性。 1234567891011121314package com.demo2;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface MyTag&#123;&#125; 123456package com.demo2;@MyTagpublic class Base &#123;&#125; 123456789package com.demo2;//SubClass只是继承了Base类//并未直接使用@MyTag注解修饰public class SubClass extends Base &#123; public static void main(String[] args) &#123; System.out.println(SubClass.class.isAnnotationPresent(MyTag.class)); &#125;&#125; 示例中Base使用@MyTag修饰，SubClass继承Base，而且没有直接使用@MyTag修饰，但是因为MyTag定义时，使用了@Inherited修饰，具有了继承性，所以运行结果为true。 如果MyTag注解没有被@Inherited修饰，则运行结果为：false。 基本AnnotationJDK默认提供了如下几个基本Annotation： @Override 限定重写父类方法。对于子类中被@Override 修饰的方法，如果存在对应的被重写的父类方法，则正确；如果不存在，则报错。@Override 只能作用于方法，不能作用于其他程序元素。 @Deprecated 用于表示某个程序元素（类、方法等）已过时。如果使用被@Deprecated修饰的类或方法等，编译器会发出警告。 @SuppressWarning 抑制编译器警告。指示被@SuppressWarning修饰的程序元素（以及该程序元素中的所有子元素，例如类以及该类中的方法…..）取消显示指定的编译器警告。例如，常见的@SuppressWarning（value=”unchecked”） @SafeVarargs @SafeVarargs是JDK 7 专门为抑制“堆污染”警告提供的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 强软弱虚引用]]></title>
    <url>%2F2017%2F05%2F21%2Fjava%2Fblog%2FJava-%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[强引用： 只要引用存在，垃圾回收器永远不会回收，JVM宁愿报OutOfMemoryError错误 12Object obj = new Object();//可直接通过obj取得对应的对象 如obj.equels(new Object()); 而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。 软引用： 非必须引用，内存溢出之前进行回收，可以通过以下代码实现 1234Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;sf.get();//有时候会返回null 这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。 弱引用： 弱引用生命周期是比软引用还更短的引用。只有弱引用的对象一旦被JVM垃圾回收器发现，便会被回收 12345Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;wf.get();//有时候会返回nullwf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾 在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。 虚引用： 垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现 12345Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj=null;pf.get();//永远返回nullpf.isEnQueued();//返回是否从内存中已经删除 “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。 参考地址：http://www.cnblogs.com/yw-ah/p/5830458.html]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的基本原则]]></title>
    <url>%2F2017%2F05%2F20%2Fjava%2Fblog%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[面向对象的六大基本原则 单一责任原则 其核心思想是：一个类最好只做一件事，专注于做一件事 开放封闭原则 其核心思想是：软件实体应该是可以扩展的而不可修改的，也就是对扩展开放，对修改封闭的 依赖倒置原则 其核心思想是：依赖于抽象，具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象； 抽象不依赖于具体，具体依赖于抽象 接口隔离原则 其核心思想是：使用多个小的专门的接口，而不要私用一个大的总接口 李氏替换原则 其核心思想是：子类必须能够替换其基类， 组合聚合复用原则 其核心思想是：优先使用组合或者聚合复用代码 ​]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock lock、unlock源码解读]]></title>
    <url>%2F2017%2F05%2F19%2Fjava%2Fblog%2FReentrantLock%20lock%E3%80%81unlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[ReentrantLock 对于公平锁和非公平锁的加锁过程不同。对于公平锁加锁，如果前面没有比当前线程等候更久的线程的话，则当前线程直接获得锁，否则直接将当前线程插入等候队列中；对于非公平锁的加锁和前面不一样，如果前一个线程刚好结束state=0，此时无论当前线程前面是否有线程等候，当前线程都能直接抢占锁。如果前一个线程还没执行完毕，则当前线程便插入等候队列中。ReentrantLock默认是非公平锁。 等候队列ReentrantLock实现是基于AbstractQueuedSynchronizer(AQS)，AQS实现是通过一个等候队列和CAS(Compare and swap)原子操作实现的。等候队列其实一个双向链表，链表中的每个元素都是一个Node结点。 Node中的每个变量都用volatile修饰保证内存的可见性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static final class Node &#123; /** Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null; /** waitStatus value to indicate thread has cancelled */ static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; //前一个结点 volatile Node prev; //下一个结点 volatile Node next; //结点中存放的线程 volatile Thread thread; Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; //获取当前结点的上一个结点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; 公平锁lock ReentrantLocak中的lock方法 123public void lock() &#123; sync.lock(); &#125; FairSync 中的lock 123final void lock() &#123; //尝试获取锁 acquire(1); &#125; AbstractQueuedSynchronizer中获取锁 12345678public final void acquire(int arg) &#123; //先判断能不能获取到锁，能获取到锁的话直接就结束了 if (!tryAcquire(arg) &amp;&amp; //如果上面不能获取到锁的话，就将当前线程插入等候队列中 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //阻塞当前线程 selfInterrupt(); &#125; FairSync 覆盖了AbstractQueuedSynchronizer中的tryAcquire方法 1234567891011121314151617181920212223242526protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //state==0 当前没有线程占用锁 if (c == 0) &#123; //如果队列中没有比当前线程等候时间更长的线程 if (!hasQueuedPredecessors() &amp;&amp; //修改锁的状态，表示锁被当前线程占用 compareAndSetState(0, acquires)) &#123; //设置当前线程是占用锁的线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果占用锁的线程就是当前线程 else if (current == getExclusiveOwnerThread()) &#123; //直接将state 加1 int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; //上面的情况都不满足，返回false，表示线程没有获取到锁 return false; &#125; 获取不到锁的话，直接插入等候队列的队尾 12345678910111213141516private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; //队尾元素不为空，插入队尾 node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //tail 为空，插入队列头 enq(node); return node; &#125; 非公平锁 ReentrantLock获取锁 123public void lock() &#123; sync.lock(); &#125; 调用NonfairSync的lock方法，先判断锁是否被占用，如果没有直接获取；否则，尝试获取 12345678910final void lock() &#123; //如果此时上一个线程刚执行完，state=0，则直接获取锁，这就是非公平锁， //无论此时等候队列中是否还有排队的线程，都直接占有锁 if (compareAndSetState(0, 1)) //设置当前线程为执行的线程 setExclusiveOwnerThread(Thread.currentThread()); else //尝试获取锁 acquire(1); &#125; 调用AbstractQueuedSynchronizer中的获取锁方法 12345678public final void acquire(int arg) &#123; //尝试去获取锁 if (!tryAcquire(arg) &amp;&amp; //如果上面获取锁失败，则加入等候队列中 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 如果成功加入等候队列中，则阻塞自身 selfInterrupt(); &#125; 调用NonfairSync重写的tryAcquire方法 123protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125; 调用Sync内部类中nonfairTryAcquire方法 123456789101112131415161718192021222324final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //如果此时没有线程占有锁，则当前线程直接占有，将state值改为1 if (c == 0) &#123; //设置锁的状态为1 if (compareAndSetState(0, acquires)) &#123; //设置当前线程为占有锁的线程 setExclusiveOwnerThread(current); return true; &#125; &#125; //如果当前线程已经占有锁 else if (current == getExclusiveOwnerThread()) &#123; //直接将锁的state值加1，表示当前线程有两个任务，可重入的实现 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); //更改state值 setState(nextc); return true; &#125; return false; &#125; addWaiter()方法，将当前线程加入等候队列队尾 1234567891011121314151617private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; //如果尾结点不为空，将当前结点插入尾结点的后面 if (pred != null) &#123; //设置当前结点前结点为尾结点，即当前结点变为尾结点 node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //如果尾结点为空，即当前队列是空队列。则插入队列中，并把当前结点设为头结点和尾结点 enq(node); return node; &#125; enq操作，队里为空时，则先添加头结点，然后再加入队尾，头结点不存储信息 1234567891011121314151617private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize //如果尾结点为空，即队列为空，则先生成头结点。然后再次循环，走下面的逻辑 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //如果队列不为空了，则加入队尾 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; acquireQueued方法 123456789101112131415161718192021222324252627282930final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); //如果当前线程是等候队列中的唯一线程(因为head里面是没有信息的) //则会再次尝试获取锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //如果获取到锁的话，修改当前结点为头结点，并将里面的信息清空，同时删除当前的头 //结点。返回当前结点没有被阻塞 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125;private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null; &#125; ​]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>lock</tag>
        <tag>unlock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CountDownLatch源码解读]]></title>
    <url>%2F2017%2F05%2F19%2Fjava%2Fblog%2FCountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[CountDownLatch的是干什么的当一项任务分给多个线程去完成，每个线程的完成时间不确定，当所有线程完成任务后需要对这些任务进行整合。这样就有一个问题，每个线程完成时间不固定，该何时进行任务的整合呢。这就可以通过CountDownLatch这个工具来实现 使用场景：多任务下载下载一般是将需要下载的文件分块，定义多个线程，每个线程负责去下载对应的数据块。当所有数据块都下载下来之后对所有数据块进行合并。 CountDownLatch实现原理CountDownLatch通过设定任务数即线程数count，当线程任务执行完毕后会将count减1。当count等于0时，调用CountDownLatch的线程才会接着继续执行。 CountDownLatch的简单使用样例12345678910111213141516171819202122232425262728293031323334353637383940414243class Worker extends Thread&#123; private CountDownLatch latch; public Worker(CountDownLatch latch) &#123; this.latch = latch; &#125; @Override public void run() &#123; super.run(); System.out.println(Thread.currentThread().getName() + " begin work!"); try &#123; sleep(new Random().nextInt(10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " work over!"); //线程任务执行完毕，count减1 latch.countDown(); &#125;&#125;public class CountDownLatchDemo&#123; public static void main(String[] args) throws InterruptedException &#123; //设定初始计算 CountDownLatch latch = new CountDownLatch(3); Worker worker1 = new Worker(latch); worker1.start(); Worker worker2 = new Worker(latch); worker2.start(); Worker worker3 = new Worker(latch); worker3.start(); latch.await(); System.out.println("works is over, begin Main Work!"); &#125;&#125; CountDownLatch源码解读CountDownLatch底层实现是通过AQS(AbstractQueuedSynchronizer)，实现方式和ReentrantLock很类似 通过构造函数传入count，即要开启的线程任务数。注意count值只能通过构造函数传入，其他时候不能对count进行修改，除了线程执行完毕。 1234public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count); &#125; 123Sync(int count) &#123; setState(count); &#125; 调用AQS的方法，设置state值 123protected final void setState(int newState) &#123; state = newState; &#125; await()方法，阻塞当前调用CountDownLatch的线程 123public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; AQS方法 123456789public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; //如果线程已经被阻塞，报出异常 if (Thread.interrupted()) throw new InterruptedException(); //尝试去获取锁，如果已经被占用，则阻塞自身线程 if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); &#125; 调用Aync内部类中的重写方法 1234protected int tryAcquireShared(int acquires) &#123; //如果当前锁已经被占用，则返回负值，如果没有被占用就返回正值 return (getState() == 0) ? 1 : -1; &#125; AQS中的方法 1234567891011121314151617181920212223242526272829private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; //将当前线程插入等候队列中 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); //如果队列中除了head结点外只有一个结点。 if (p == head) &#123; //尝试去获取锁 int r = tryAcquireShared(arg); // 锁未被占用 if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; ​]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>countDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal]]></title>
    <url>%2F2017%2F05%2F19%2Fjava%2Fblog%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal 为每个线程提供一个变量的独立副本，每个线程对ThreadLocal变量的修改不会相互影响。它为给每个线程提供一个获取存放变量的一个key。 ThreadLocal类中定义了一个内部数据结构ThreadLoalMap，ThreadLocalMap是用来存放每个线程的ThreadLocal变量值Value。但是ThreadLocal中并没有定义ThreadLocalMap变量，ThreadLocalMap是在线程中定义的，用来存放每个线程中的多个ThreadLocal所对应的Value值。下面是Thread类中定义的ThreadLocalMap成员变量 1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocaMap是一个Entry数组，Entry中包含key和Value，其中key就是threadLocal，并且key是弱引用的。Entry结构定义如下 123456789static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125; &#125; ​ 如上图是其中一个Thread中的ThreadLocalMap数据结构的示意图，其中key是ThreadLocal，Value是ThreadLocal变量在其中一个线程的值。 ​ 因为每个线程中都有这么一个ThreadLocalMap，所以当线程对ThreadLocal变量进行修改时，其实就是对Thread本身的ThreadLocalMap进行修改 ThreadLocal中的方法 set() 1234567891011public void set(T value) &#123; //获取当前线程 Thread t = Thread.currentThread(); //获取当前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); //如果Map不存在则创建 if (map != null) map.set(this, value); else createMap(t, value); &#125; getMap(t)是获取Thread中的ThreadLocalMap变量 1234ThreadLocalMap getMap(Thread t) &#123; //返回线程中的ThreadLocalMap变量 return t.threadLocals; &#125; createMap是给Thread创建一个ThreadLocalMap，并将值放入Map中 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; get() 123456789101112public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; //通过key ThreadLocal找到Map中的对应的Entry ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) //返回Entry中的值 return (T)e.value; &#125; return setInitialValue(); &#125; getEntry()查找方法和HashMap中查找有点类似，都是通过HashCode 来定位。但是两者计算hash值得方法不同，而且如果并命中的话接下来的查找过程也不同。 123456789private Entry getEntry(ThreadLocal key) &#123; //通过threadLocalHashCode计算在其在数组中的位置 int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else //如果对应的位置上不是要找的值，则会进行下一步操作 return getEntryAfterMiss(key, i, e); &#125; 如果计算的index不命中的话，会往下一直查找 1234567891011121314151617private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else // i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; nextIndex()会让下标值加1，如果大于len则变成0 123private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; ThreadLocal使用 123456789101112131415161718192021222324252627282930public class Test&#123; public static void main(String[] args) &#123; ThreadLocal&lt;Integer&gt; num = new ThreadLocal&lt;&gt;(); num.set(1); new Thread(new MyRunnable(num, 5)).start(); new Thread(new MyRunnable(num, 8)).start(); System.out.println(Thread.currentThread().getName() + " " + num.get()); &#125;&#125;class MyRunnable implements Runnable&#123; ThreadLocal&lt;Integer&gt; num; private int value; public MyRunnable(ThreadLocal&lt;Integer&gt; num, int value) &#123; this.num = num; this.value = value; &#125; @Override public void run() &#123; num.set(value); System.out.println(Thread.currentThread().getName() + " " + num.get()); &#125;&#125; 输出： 123main 1Thread-1 8Thread-0 5]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>threadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock简介]]></title>
    <url>%2F2017%2F05%2F18%2Fjava%2Fblog%2FReentrantLock%2F</url>
    <content type="text"><![CDATA[ReentrantLock是一个可重入的互斥锁定 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。ReentrantLock 将由最近成功获得锁定，并且还没有释放该锁定的线程所拥有。当锁定没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁定并返回。如果当前线程已经拥有该锁定，此方法将立即返回。可以使用 isHeldByCurrentThread() 和 getHoldCount() 方法来检查此情况是否发生。 重入锁： 如果当前占有锁的线程是Thread1，则当Tread1再次到来的时候不要要排队，直接将state加1，即运行次数加1。 ReentrantLock实现了Lock接口，提供了完整的Lock功能。它的一个内部类Sync类继承了AbstractQueuedSynchronizer（AQS）实现锁的功能，但是Sync并不提供公平和非公平锁机制，因此在Sync的基础之上，ReentrantLock内部又提供了两个内部类NonfairSync非公平锁、和FairSync公平锁，这两个类都是继承自Sync。 公平锁和非公平锁的区别： 公平锁：线程按照他们发出信号的先后来获取锁，采用先来先服务的原则。新来的线程直接放入等候队列中。 非公平锁：支持抢占方式，新来的线程首先会检查锁是否占用，如果被占用直接插入等候队列中，如果上一个线程刚好结束state=0时，系统会直接调用这个新来的线程执行，而不会去等候队列中唤醒阻塞的线程。这样做的好处是可以提高系统的吞吐量，因为从阻塞队列总唤醒线程需要耗费时间。 SyncSync继承自AbstractQueuedSynchronizer， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; //加锁功能 abstract void lock(); //非公平锁尝试获取锁 final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //如果没有锁定，则直接加上锁 if (c == 0) &#123; //直接 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //如果拥有资源的线程 和当前线程相同则state加1 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; //否则返回false return false; &#125; //尝试释放锁 protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; protected final boolean isHeldExclusively() &#123; return getExclusiveOwnerThread() == Thread.currentThread(); &#125; final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; //返回正在占用资源的线程 final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; //资源是否已经被占用(已经在锁) final boolean isLocked() &#123; return getState() != 0; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; NonfairSync非公平锁123456789101112131415161718static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; //加锁 final void lock() &#123; //比较并更改锁的状态，如果当前state是0，则将state修改成1，并将获取锁的线程设置成当前线程 //如果上一个线程刚好结束state=0，这时线程过来就直接获取锁，而排队等待中的线程需要继续等待， //这样可以提高系统的效率，因为要从阻塞队列中唤醒线程需要耗费时间 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else // 如果state！=0，即已经被占用，则调用获取锁的方法，acquire是AQS的方法 acquire(1); &#125; //尝试获取锁 protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125; &#125; FairSync公平锁123456789101112131415161718192021222324252627282930static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; //公平锁加锁，直接放入等候队里中 final void lock() &#123; acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //hasQueuedPredecessors ：查询是否还有线程比当前线程等候的时间更长， //即前面队列中是否还有等候吧的线程,如果没有则当前线程获取锁 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; //设置当前线程为获取资源的线程 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; &#125; ReentrantLock构造方法ReentrantLock默认是创建非公平锁 123public ReentrantLock() &#123; sync = new NonfairSync(); &#125; 可以通过参数创建公平锁，参数为true时创建公平锁，参数false时创建非公平锁 123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; ReentrantLock方法 加锁，如果已被占用则加入等候队列中 123public void lock() &#123; sync.lock();&#125; 尝试获取锁，如果获取不到就直接返回 123public boolean tryLock() &#123; return sync.nonfairTryAcquire(1); &#125; 尝试去获取锁，如果在timeout这段时间内没有获取到就直接返回 1234public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; 释放锁 123public void unlock() &#123; sync.release(1); &#125; 返回当前线程占有的数量即state值 123public int getHoldCount() &#123; return sync.getHoldCount(); &#125; 判断占有锁的线程是否是当前线程 123public boolean isHeldByCurrentThread() &#123; return sync.isHeldExclusively(); &#125; 判断资源是否加锁 123public boolean isLocked() &#123; return sync.isLocked(); &#125; 判断是否是公平锁 123public final boolean isFair() &#123; return sync instanceof FairSync; &#125; 返回占有该锁的线程 123protected Thread getOwner() &#123; return sync.getOwner(); &#125; 判断等候队列中是否还有线程 123public final boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; 判断该线程是否在等候队列中 123public final boolean hasQueuedThread(Thread thread) &#123; return sync.isQueued(thread); &#125; 返回等候队列的长度 123public final int getQueueLength() &#123; return sync.getQueueLength(); &#125; 返回所有的等候线程 123protected Collection&lt;Thread&gt; getQueuedThreads() &#123; return sync.getQueuedThreads(); &#125; ReentrantLock使用 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.locks.ReentrantLock;public class Test&#123; private static int num = 0; static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) new Thread(new MyRunnable()).start(); &#125; public static void lockBlock() &#123; try &#123; lock.lock(); for (int i = 0; i &lt; 3; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;class MyRunnable implements Runnable&#123; @Override public void run() &#123; Test.lockBlock(); &#125;&#125;]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>lock</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized]]></title>
    <url>%2F2017%2F05%2F17%2Fjava%2Fblog%2FSynchronized%2F</url>
    <content type="text"><![CDATA[Synchronized 是Java中的一种锁，主要用来给方法和代码块加锁。当某个方法或者代码块使用synchronized关键字时，那么同一时刻最多只能有一个线程执行该代码段。当多个线程同时访问时，只有一个线程执行，其他线程处于阻塞状态，当线程执行完毕后其他线程才能执行。 synchronized 是Java虚拟机底层实现的锁机制，当synchronized方法或者代码块中发生异常时，会系统会自动释放锁定资源。 Synchronized主要有两种用法，一种是synchronized方法，另一种是synchronized代码块 Synchronized方法类的成员方法在类的成员方法声明中加上Synchronized关键字，其锁定的是类的实例对象 1public synchronized void getNum()&#123;&#125; synchronized加在类的成员方法中，本质上锁定是this对象，它和下面的写法是等价的： 12345public void getNum()&#123; synchronized(this)&#123; …… &#125;&#125; 代码访问的同步性 当多个线程同时访问同一个synchronized方法时，一次只能一个线程执行 当多个线程同时访问类中不同的Synchronized方法时，一次也只能一个线程执行，其他线程阻塞 123public synchronized void getNum()&#123;&#125;public synchronized void getNum1()&#123;&#125; 即当两个线程同时一个调用getNum，另一个调用getNum1()，同一时间只能一个线程运行 当两个线程一个调用Synchronized方法，另一个线程调用普通方法，则两个线程可以同时进行，不会相互影响 类的静态方法static在类的静态方法中加上Synchronized关键字，其锁定的是class类对象 1public static synchronized void getNum()&#123;&#125; 其效果等同于下面的写法 12345public static void getNum()&#123; //我们假设这个静态方法在Main这个类中声明 synchronized(Main.class)&#123; …… &#125;&#125; 代码访问的同步性1234567public class Main&#123; public void method()&#123;&#125;; public synchronized void method1()&#123;&#125;; //锁定的是this public synchronized void method2()&#123;&#125;; public synchronized static void method3()&#123;&#125;; //锁定的是class public synchronized static void method4()&#123;&#125;;&#125; method() 和 method1() 能同时访问 method()和method3()能同时访问 method1()和method2()不能同时访问 method3()和method4()不能同时访问 method1()和method3()可以同时访问 Synchronized代码块Synchronized代码块把需要同步的代码加上锁，将那些对线程安全没有影响的代码移出Synchronized代码块，具体写法如下 12345678public void getNum()&#123; …… synchronized(obj) &#123; …… 线程同步代码块 &#125;&#125; 代码块中添加Synchronized可以减小锁的粒度，提高程序并发的效率。 线程访问的同步性 若多个线程同时访问一个Synchronized代码块，则一次只能有一个线程能够访问 若多个代码Synchronized代码块锁定的对象是同一obj，则当多个线程同时访问这些代码块时，一次只能有一个线程能够访问这些代码块。 测试用例用例1：多个线程同时访问一个Synchronized代码块 1234567891011121314151617181920212223242526public class Test implements Runnable&#123; private static Integer num = 0; private Object obj = new Object(); @Override public void run() &#123; getNum(); &#125; public static void main(String[] args) &#123; Test test = new Test(); for (int i = 0; i &lt; 3; i++) new Thread(test, "Thread_1_" + i).start(); &#125; public void getNum() &#123; synchronized (obj) &#123; for (int i = 0; i &lt; 5; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); &#125; &#125;&#125; 测试结果：一次只能一个线程可以运行 12345678Thread_1_0 0Thread_1_0 1Thread_1_2 2Thread_1_2 3Thread_1_1 4Thread_1_1 5 测试用例2：多个线程同时访问多个Synchronized代码块，且这些代码块的锁定对象相同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Test implements Runnable&#123; private static Integer num = 0; private Object obj = new Object(); @Override public void run() &#123; getNum(); &#125; private class MyRunnable implements Runnable &#123; @Override public void run() &#123; getNum1(); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); for (int i = 0; i &lt; 3; i++) new Thread(test, "Thread_1_" + i).start(); Runnable myRunnable = test.new MyRunnable(); for (int i = 0; i &lt; 3; i++) &#123; new Thread(myRunnable, "Thread_2_" + i).start(); &#125; &#125; public void getNum() &#123; synchronized (obj) &#123; for (int i = 0; i &lt; 2; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); &#125; &#125; public void getNum1() &#123; synchronized (obj) &#123; for (int i = 0; i &lt; 2; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); &#125; &#125;&#125; 测试结果：每次只能有一个线程可以访问Synchronized代码块 1234567891011121314151617Thread_1_0 0Thread_1_0 1Thread_1_2 2Thread_1_2 3Thread_1_1 4Thread_1_1 5Thread_2_0 6Thread_2_0 7Thread_2_1 8Thread_2_1 9Thread_2_2 10Thread_2_2 11]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合-Set介绍]]></title>
    <url>%2F2017%2F05%2F14%2Fjava%2Fblog%2Fjava%E9%9B%86%E5%90%88-Set%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前面介绍了一些关于List、Map的相关知识，下面我们继续来看下集合中的set。set作为容器主要存储不重复的元素。 HashSet HashSet底层实现是通过HashMap实现的，set中每个元素对应Map中的每个EntrySet结点。存储元素时只用Map的key值存储，value值统一设置为同一个new Object()。 HashSet底层存储数据的是map，所以Hashset允许null存在 HashSet存放的元素各不相同，当掉用add方法添加已存在的元素时会返回false. TreeSet TreeSet底层是通过TreeMap实现。存储元素只使用TreeMap中的key，Value同一设成相同的new Object(); TreeSet不允许插入null值 ​TreeSet元素是有序的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>HashSet</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 线程池]]></title>
    <url>%2F2017%2F05%2F14%2Fjava%2Fblog%2FJava%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[当处理大并发请求时，由于创建线程比较耗时，故引入线程池。线程池是存放线程的容器，用户请求到来前可以提前创建好线程，请求到来时便可以直接执行任务。 线程池示意图： 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; corePoolSize：线程池中保留的线程数（包括空线程），注意线程池中的线程数并不是一创建达到corePoolSize，而是在请求到达时逐步创建，最后数目达到corePoolSize。请求任务执行完毕后，若线程数&lt;corePoolSize，则会保持当前数目。 maximumPoolSize：线程池中可以容纳的最大线程数 keepAliveTime：当线程数据超过corePoolSize时，且线程任务执行完毕后，过keepAliveTime后剩余的线程将会注销 TimeUnit：keepAliveTime的时间单位 workQueue：阻塞队列(缓冲队列)，线程池中线程数目达到达到corePoolSize后，新来的任务请求会放到缓冲队列中，采用的是FIFO模式 常用的是：java.util.concurrent.ArrayBlockingQueue LinkedBlockingQueue SynchronousQueue ThreadFactory：制造线程的工厂 handler：饱和策略，当线程池中线程达到maximumPoolSize，且缓冲队列也满了之后，对新来的请求采取的策略。 请求任务执行策略 当请求任务数小于corePoolSize时，直接在线程池创建线程，并将任务放入线程中执行 当请求任务数大于corePoolSize，并且剩余的请求数小于阻塞队列长度时，将任务放入阻塞队列 若maximumPoolSize大于corePoolsize，当阻塞队列满了后还有请求任务到来，则在线程池中创建新的线程执行。 若线程池中的线程数等于maximum，且阻塞队列也满了还有任务到来，则用线程饱和策略处理。 线程池饱和策略当线程池中的缓冲队列满了，同时线程池中线程数量也达到了maximum，这时候如何还有请求过来，就会采用RejectedExecutionHandler饱和策略来应对。具体饱和策略包括下面几种： AbortPolicy：终止策略，抛出RejectedExecutionException异常，同时处理完线程池和缓冲队列中的请求 DiscardPolicy：抛弃策略，抛弃新来的请求，其他一切照常 DiscardOldestPolicy:抛弃旧任务策略，将队列头元素删除，然后将新来的请求放入队尾 CallerRunsPolicy：调用者运行策略，既不抛弃任务也不抛出异常，直接运行任务的run方法，即将任务退回给调用线程池的线程直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。 创建线程池的其他方法通过Executors类中的静态方法创建ExecutorSevice Executors.newFixedThreadPool(); Executors.newSingleThreadExecutor(); Executors.newCachedThreadPool(); Executors.newScheduledThreadPool(); newFixedThreadPool12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 阻塞队列使用的是LinkedBlockingQUeue，阻塞队列的最大长度默认是Integer.MAX_VALUE。其中corePoolSize和maximumPoolSize相等。 newSingleThreadExecutor123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 单个线程的线程池，同样调用LinkedBlockingQueue newCachedThreadPool12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 缓存线程池，缓存线程池里面并没有常驻的线程。 newSingleThreadScheduledExecutor1234public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1)); &#125; ##### ##### 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; ##### ##### 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; #####]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http和https的区别]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Fhttp%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Http和Https的区别http协议是未加密的传输，即采用明文的方式发送内容，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就很容易直接读取其中的信息。https就是在http的基础之上加入了SSL协议，SSL用于对http协议传输的数据进行加密。 https协议需要到ca申请证书，一般需要一定的费用 http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密协议 http和HTTPS使用不同的连接方式，用的端口也不同，前者是80端口，后者是443端口 http的连接是简单无状态的，HTTPS协议是由ssl+http协议构成的可进行加密传输、身份认证的网络协议，比http协议安全。 1.什么是HttpHttp中文叫做超文本传输协议, 它完成客户端到服务端等一系列运作流程 1.1 与http关系密切的协议: IP, TCP和DNS负责传输的IP协议IP协议数据网络层, IP协议的作用是把各类数据包传送给对方. 而要确保确实传送到对方那里, 则需要满足各类条件. 其中两个重要的条件是IP地址和MAC地址. IP地址指明了节点被分配到的地址, MAC地址是指网卡所指的固定地址. IP地址和MAC地址进行配对, IP地址可以变换, 但是MAC地址基本不会更改. 确保可靠性的TCP协议TCP位于传输层, 提供可靠的字节流服务 字节流服务: 为了方便传输, 将大块数据分割成以报文段为单位的数据包进行管理. 为了确保无误将数据送达目标处, TCP协议采用了三次握手策略.当然除了三次握手策略, 还有很多其他的手段保证通讯的可靠性 负责域名解析的DNS服务DNS服务是和HTTP协议一样位于应用层的协议. 他提供域名与IP地址之间的解析服务. 因为记住一组纯数字太难了, 而字母加数字才是人类习惯的方式,为了解决这个问题, DNS服务营运而生. 2. HTTP的缺点 通信使用明文(不加密), 内容可能会被窃听 不验证通信方的身份, 因此有可能遭遇伪装 无法证明报文的完整性, 所有有可能已遭篡改 3.HTTP+加密+认证+完整性保护 = HTTPSHTTPS并非是应用层的一种新协议. 只是HTTP通信接口部分用SLL(Secure Socket Layer)和TLS (Transport Layer Security) 协议替代而已. 通常, HTTP直接和TCP通信, 当使用SSL时, 演变成了先和SSL通信, 再由SSL和TCP通信了, 简而言之, 所谓HTTPS, 其实就是身披SSL协议的这层外壳的HTTP. 在采用SSL后, HTTP就拥有了HTTPS的加密, 证书和完整性的保护这些功能. SSL是独立于HTTP的协议, 所有不光是HTTP协议, 其他运行在应用层的SMTP(邮件协议)和Telnet等协议均可配合SSL协议使用. 可以说SSL是当今世界上应用最广泛的网络安全技术. 4.SSL是如何加密的SSL采用一种叫做公开密钥加密(Public-key cryptography)的加密方式. 近代的加密方法中, 加密算法是公开的, 而秘钥是保密的, 通过这种方式得以保持加密方法的安全性. 共享密钥加密的困境加密和解密同用一个密钥的方式称为共享密钥加密, 也被叫做对称密钥加密. 共享加密方式加密时必须将密钥也发给对方. 在互联网上转发密钥时, 如果通信被监听那么密钥就会落入攻击者之手, 同事也就失去了加密的意义, 怎么才能安全的转交? 使用两把密钥的公开密钥加密公开密钥加密方式很好地解决了共享密钥加密的困难 公开密钥加密使用一对非对称的密钥. 一把叫做私有密钥, 另一把叫做公开密钥 使用公开密钥加密方式, 发送密文的一方使用对方的公开密钥进行加密处理, 对方收到被加密的信息后, 在使用自己的私有密钥进行解密. 利用这种方式, 不需要发送用来解密的私有密钥, 也不用担心密钥被攻击者窃听而盗走. 另外, 要想根据密文和公开密钥, 恢复到信息原文是异常困难的, 因为解密过程就是在对离散对数进行求值, 这并非轻而易举就能办到的. 退一步讲, 如果能对一个非常大的整数做到快速地因式分解, 那么密码还是在存在希望的, 但就目前的技术来看是不太现实的. HTTPS采用混合加密机制HTTPS采用共享秘钥加密 和 公开秘钥加密两者并用的混合加密机制. 若密钥能够实现安全交换, 那么有可能会考虑仅适用公开密钥加密来通信. 但是公开密钥加密和共享密钥加密相比, 其处理速度要慢. 所以应充分利用两者各自优势, 将多种方法组合起来用于通信. 在交换密钥环节适用公开密钥加密方式, 之后的建立通信交换报文阶段则使用共享密钥加密方式. 5.证明公开密钥的正确性的证书遗憾的是, 公开密钥加密方式还是存在一些问题的, 那就是无法证明公开密钥本身就是货真价实的公开密钥. 比如, 正准备和某台服务器建立公开密钥加密方式下的通信时, 如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥. 或许在公开密钥传输途中, 真正的公开密钥已经被攻击者替换了. 为了解决上述问题, 可以使用有数字证书认证机构和其他相关机关颁发的公开密钥证书 基本流程为: 1.服务器把自己的公开密钥登录至数字证书认证机构 2.数字证书认证机构用自己的私有密钥向服务器的公开密钥署数字签名并颁发公钥证书 3.客户端拿到服务器的公钥证书后, 使用数字证书认证机构的公开密钥, 向数字证书认证机构验证公钥证书上的数字签名, 以确认服务器的公开密钥的真实性 4.使用服务器的公开密钥对报文加密后发送 5.服务器用私有密钥对报文解密 6.SSL速度慢吗?由于HTTPS还需要做服务器,客户端双方加密及解密处理, 因此会消耗CPU和内存等硬件资源, 和HTTP通信相比, SSL通信部分消耗网络资源. 而SSL通信部分, 有因为要对通信进行处理, 所有时间上又延长了. 针对速度慢这样一个问题, 并没有根本性的解决方案, 我们会使用SSL加速器这种(专用服务器)硬件来改善该问题. 相对软件来讲, 能够提高数倍SSL计算速度. 7.为什么不一直使用HTTPS既然HTTPS那么的可靠安全, 那为何不所有的Web网站不一直使用HTTPS? 其中的一个原因是, 因为与纯文本通信相比, 加密通信会消耗更多的CPU资源以及内存资源, 如果每次通信都加密, 会消耗相当多的资源, 平摊到一台计算机上时, 能够处理的请求数量必定会随之减少. 因此, 如果是非敏感信息则使用HTTP通信, 只有在包括个人信息等敏感数据时, 才利用HTTPS加密通信, 以节省资源. 除此之外, 想要节约购买证书的开销也原因之一. Https握手过程1. 客户端发起HTTPS请求 2. 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。 3. 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。 4. 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。 5. 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6. 服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7. 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 8. 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。 PS: 整个握手过程第三方即使监听到了数据，也束手无策。 HTTP1.0 与HTTP1.1的区别 引入持久化连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。 引入管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 增加了Host头域，使多个Server同时共享一个IP地址和端口号 增加状态码100，客户端先发送一个只有请求头的数据，测试地址是否可以访问，可以访问随后再发送含有包含body字段的请求 Http状态码： 1xx：指示信息，表示请求已经接收，继续处理 2xx：成功，表示请求已经被成功接收、理解、接受 3xx：重定向，表示完成请求必须进行更进一步的操作 4xx：客户端错误，请求有语法错误或者请求无法实现 5xx：服务器端错误，服务器未能实现合法的请求 常见的状态码： 100：Continue 请求继续，客户端应当继续发送请求的其余部分 200：OK——客户端请求成功 202：Accepted 请求已经接受，但尚未处理 300： Multiple Choices 客户端请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出 301：Moved Permanently 客户端请求的文档在其他地方，新的URL在location投中给出，浏览器应该自动访问新的URL 400：Bad request——客户端请求有语法错误，不能被服务器解析 401：unauthorized——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403：Forbidden——资源不可用，服务器收到请求，但是拒绝提供服务 404：Not found——请求资源不存在 如URL输入错误 500：Internal Server Error——服务器发生了不可预料的错误 502：网关错误 503：Server Unavailable——服务器当前不能处理客户端的请求，一段时间后可能恢复正常 Http Request请求头常见字段： Http请求方式 ​ Host：请求的web服务器域名地址 User-Agent：Http客户端浏览器类型的详细信息 Accept：指定客户端能够接收的内容类型 text/xml、text/html Accept-Language：指定客户端浏览器用来显示返回信息所优先选择的语言 Accept-Encoding：指定客户端浏览器可以支持服务器返回内容的压缩编码类型，表示客户端浏览器所能支持的返回压缩格式 Accept-CharSet：浏览器可以接受的字符编码集 Content-type：此请求提交的内容类型，一般只有post提交时才需要设置该属性 Connection：表示是否需要持久连接，如果值是keep-Alive或者协议版本是HTTP1.1，就会进行持久连接 Cookie：http请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器 Date：请求发送的日期时间 Http Response响应头字段： Cache-Control：缓存机制,no-cache,private,public, Connection:是否要保持持久连接 Content-Encoding：返回来数据的压缩格式 Content-Language：相应体的语言 Content-type：返回资源文件的类型 Date：服务器发送资源时的服务器时间 Expiers:告诉客户端在这个时间前可以直接访问缓冲副本，相应过期时间 Last-Modifed:请求资源的最后修改时间]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识点]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[因特网组成（一）边缘部分 客户-服务器方式 对等连接方式（P2P）:两个主机通信时不区分哪个是服务请求方还是服务提供方。 （二）核心部分 路由器：实现分组交换的关键构建，其任务是转发收到的分组。 电路交换：建立连接（占用通信资源）——&gt;通话（占用通信资源）——&gt;释放链接（归还通信资源） 分组交换：采用存储转发方式，把数据报文划分成等长的数据，每组数据前加上必要的控制信息组成的包头构成一组报文。单个分组传送到相邻结点，存储下来后查找转发表。转发到下一个结点。 报文交换：整个报文先传到相邻的结点，全部信息存储下来后查找转发表，转发到下一个结点。 计算机网络的分类（一）按网络的作用范围划分 广域网 城域网 局域网 （二）按使用者划分 公用网 专用网 ###计算机网络体系结构 ​ 应用层 表示层 应用层 应用层 回话层 运输层 运输层 运输层 网络层 网际层IP 网络层 数据链路层 网络接口层 数据链路层 物理层 物理层 OSI七层协议 TCP/IP四层协议 五层协议 物理层信道与电路信道一般表示某一个方向传送信息的媒体，而一条通信线路往往包含一条发送信道和一条接收信道。 通信的三种基本方式 单线通信（单工通信）：只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）：双方都可以发送信息，但不能双方同时发送（也不能同时接收）。 双向同时通信（全双工通信）：双方可以同时发送和接收消息。 信道复用技术 频分复用：频分复用的所有用户在同样的时间占用不同的带宽资源 时分复用：时分复用的所用用户是在不同的时间占用同样的频带宽度 数据链路层三个基本问题 封装成帧：在一段数据的前后分别添加首部和尾部构成数据帧。首部加SOH尾部加EOT 透明传输：表示无论什么样的比特组合的数据都能通过这个数据链路层。如果数据中出现SOH和EOT就在前面加上转义字符“ESC”，如果数据中出现转义字符，就再前面再加一个转义字符。接收端看到有转义字符就将前面的转义字符删掉。 差错检测：传输过程中容易发生错误，需要对数据进行检验。数据链路层广泛使用循环冗余检验（CRC） 循环冗余检验（CRC cyclic redundancy check） 数据M*2^n,即在数据M后面加上n个0。列如11001101，假设n=3 —》 11001101000。 对做乘法后的数据M除以事先商量的除数。除数长度是n+1.除数p(X)叫做生成多项式。常用的生成多项式有如下： CRC8=X^8+X^5+X^4+X^0 CRC-CCITT=X^16+X^12+X^5+X^0 CRC16=X^16+X^15+X^2+X^0 CRC12=X^12+X^11+X^3+X^2+X^0 CRC32=X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0 如果数据M=10101001，多项式选用CRC8，则除数p=110001。除数选定之后长度是6位，所以n=6-1=5,即数据M后面加上5个0。 用数据M除以P，除的过程中采用模2运算。模2运算中的加减法都不考虑借位和进位列如：1111+1010=0101. 得到的余数R就作为冗余码拼接到数据M的后面发送出去。这种为了检错而添加的冗余码称为帧检验序列(FCS) 12345678910111213141516171819202122232425262728 10001110 ----------------------110001) 1100110100000 110001 ------------ 000100 000000 ------------ 001001 000000 ------------ 010010 000000 ------------ 100100 110001 ------------ 101010 110001 ------------ 110110 110001 -------------- 001110 000000 -------------- 01110 &lt;---R(余数)，作为FCS 循环冗余检验（CRC）和帧检验序列（FCS）的区别CRC是一种检错方法，FCS是添加在数据后面的冗余码 数据链路层如果仅采用循环冗余检验CRC差错检验技术的话，可以这么认为凡是接收端在数据链路层接收到的数据帧均无差错。 点对点协议（PPP）透明传输问题 异步传输 将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E) 若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D) 若信息字段中出现 ASCII 码的控制字符(0x0a，即数值小于 0x20 的字符)，则将其转变成为 2 字节序列(0x7D, 0x2a)，如0x03 变为 (0x7D, 0x23) 同步传输 发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除 使用广播信道的数据链路层CSMA/CD（载波监听多点接入/碰撞检测） 多点接入：表示许多计算机以多点接入的方式连接在一根总线上 载波监听：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 碰撞检测：计算机边发送数据边检测信道上的信号电压大小 争用期​ 以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。经过争用期还没检测到碰撞，才能肯定这次发送不会发生碰撞 二进制指数类型退避算法 基本退避时间，2τ 重传所需时延从{0，1，……，2^k^ -1}中选择。其中k=min{重传次数，10}，当重传次数大于10的时候，k=10; 当重传次数达到16次仍然不能成功时，应丢弃该帧。 例如重传次数=3，{0，1，2，3，4，5，6，7} 从这些数字中选择一个。 争用期长度 以太网取51.2 μs 为争用期的长度 对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节 以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突 最短有效帧长以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧 强化碰撞当发送数据的站一旦发生碰撞，立即停止发送数据，再继续发送若干比特的人为干扰信号，强化碰撞 网络层（网际层IP）地址解析协议（ARP）、网际控制报文协议（ICMP）、网际组管理协议（IGMP） IP地址的分类A类地址：以0开头，第一个字节范围：0~127；网络号8位，主机号24位 子网掩码255.0.0.0 B类地址：以10开头，第一个字节范围：128~191；网络号16位，主机号16位 子网掩码255.255.0.0 C类地址：以110开头，第一个字节范围：192~223；网络号24位，主机号8位 子网掩码255.255.255.0 D类地址：以1110开头，第一个字节范围为224~239；多播地址 无分类编址192.168.34.256/16:表示前16位是网络前缀，后面16位是主机号。/后面表示网络前缀占的位数 IP={《网络前缀》,《主机号》} 子网掩码1的个数与网络前缀的个数相同。 IP数据报的格式 一个IP数据报有首部和数据两部分组成 首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 版本号4位，指IP协议的版本，目前是4（ipv4） 首部长度4位，可表示的最大值是15，1个单位是4字节，因此首部最长可以是60字节 区分服务8位，一般不使用 总长度16位，值首部和数据的总长度，单位字节。最大长度是65535，但是不能超过最大传送单元MTU 标识16位，用来产生数据报的标识 标志3位，第一位没用；第二位DF，DF=0时才允许有分片；第三位MF，MF=1后面有分片，MF=0后面没有分片 片偏移12位，该片在原数据段中的位置，以8字节为单位。 生存时间8位，数据报在网络中可通过的路由器数 地址解析协议（ARP）已知一个机器的IP地址，需要寻找其相应的硬件地址(Mac地址)。 ARP高速缓存：每一个主机都设有一个ARP高速缓存，里面存放了本局域网上的各个主机和路由器的IP地址到硬件地址的映射表。 注意：ARP是解决同一个局域网上的主机或路由的IP地址和硬件地址的映射问题。 子网划分IP地址原先分为网络号和主机号 子网划分就是将主机号划分为子网号和主机号。 IP地址={《网络号》,《子网号》,《主机号》}； 子网掩码作用：把子网掩码和IP地址做与(AND)运算就得出该IP的网络地址。网络地址就是该设备所在网络中的唯一确定地址。 例题：已知IP地址是141.14.72.24，子网掩码是255.255.192.0，求网络地址 12345141.1 4.01001000.24255.255.11000000.0------------------- 与运算141.1 4.01000000.24 --&gt;141.14.64.0(网络地址)这个IP是B类地址，网络号16位、子网号2位、主机号14位。 无分类编址CIDRIP地址={&lt;网络前缀&gt;，&lt;主机号&gt;} CIDR还使用斜线记法，在IP地址后面加上“/”，同时后面接上网络前缀的所占位数。 128.14.12.0/20—— 表示的地址块有2^12^个地址，斜线后面的20表示网络前缀的位数。 因特网路由选择协议内部网关协议RIP内部网关协议OSPFOSPF（open shortest path first）:开放最短路径优先 运输层用户数据报协议UDPTCP传输控制协议建立连接： 释放连接： linux下侦测主机到目的主机之前所经过的路由的命令。 traceroute ：命令用来探测路由经过.. ping ：命令用来检测两部主机之间的传输信道是否畅通，或远程主机是否正常.. route：命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录来进行相应的添加、删除或修改等操作。 ifconfig：命令用来来检测和设置本机的网络接口。 TCP和UDP的区别和应用场景 TCP UDP 连接性 面向连接的 无连接的 可靠性 可靠的 不可靠 报文 面向字节流 面向报文（保留报文边界） 效率 低 高 双工性 全双工 一对一、一对多、多对一、多对多 流量控制 有（滑动窗口） 无 拥塞控制 有（慢开始、拥塞避免、快重传、快恢复） 无 传输速度 慢 快 应用场合 对效率要求相对低的，但对准确性要求相对高；或者是要有连接的场景 对效率要求相对高，对准确性要求相对低的场景 应用示例 TCP一般用于文件传输（FTP、http对数据准确性要求高，速度可以相对慢）；发送接收邮件（pop，SMTP,IMAP 对数据准确性要求高，非紧急应用）；远程登录（Telnet，SSH 有连接）等等 UDP一般用于即时通信（QQ，对数据准确性和丢包要求比较低，但速度必须快）；在线视频（速度一定要快，保证视频的连续性，但是偶尔花了一个图像帧用户还是能接受的）；网络电话等]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo 文章中插入图片问题]]></title>
    <url>%2F2017%2F05%2F13%2Fhexo%2Fhexo-%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 12345本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg)就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为 12345public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; 而不是愚蠢的 &lt;img src=&quot;本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt;]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识点]]></title>
    <url>%2F2017%2F05%2F13%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1. 进程管理1.1 进程基本概念程序顺序执行的特征 顺序性：每一个操作必须在下一个操作开始之前结束 封闭性：程序运行时独占全机资源，资源的状态只有本程序才能改变 可在现性 前趋图有向无环图 作用：用于描述程序段或进程间执行的前后顺序。 结点：表示程序段或进程，或一条语句** 有向边：表示结点之间的偏序(前驱)关系 并发执行时的特征 间断性——“停停走走” 失去封闭性——原因：多个程序共享资源 不可再现性 进程的定义与特征 结构性（PCB） 进程实体 = 程序 + 进程控制块(PCB) 程序=数据段+程序段 动态性 进程实质是进程实体的一次执行过程 体现在 “由创建而生，由调度而执行，由撤销而亡” 并发性 独立性 异步性 进程的定义进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 进程和程序的区别与联系 区别 进程是动态概念，强调的是执行，有创建、有撤销，存在是暂时的。程序是一静态概念，程序是指令的有序集合，“永远”存在； 进程具有并发性，而程序没有； 进程是接受计算机资源的基本单位，程序不是。 联系 进程是程序在数据集上的一次执行 一个程序可对应多个进程，一个进程可包括多个程序。 进程的三种状态 就绪状态 执行状态 阻塞状态 1.2 进程控制进程控制是进程管理中最基本的功能 用于创建新进程 终止一个已完成的进程 终止一个无法运行下去的进程 (Kill) 负责进程的状态转换 (就绪执行) 1.3进程图描述一个进程家族关系的有向树 1.4 经典进程同步问题生产者消费者问题记录型信号量方法 生产者 1234567891011121314 var mutex,empty,full:semaphore:=1,n,0；// 定义信号量 buffer:array[0,…,n-1] of item; // 定义缓冲区 in, out : integer :=0,0; // 定义下标指示变量begin //生产者如何执行(如何往缓冲区放东西) repeat 产生一个商品放入nextp中; wait(empty); //等待缓冲区有地方 wait(mutex); //等待可以使用缓冲区 buffer[in] := nextp; in := (in + 1) mod n; signal(mutex); //告诉其他进程：缓冲区可以使用了 signal(full); //告诉其他进程：缓冲区中多了一个商品 until false; end 生产者 1234567891011begin //消费者如何执行(如何从缓冲区取东西) repeat wait(full); //等待缓冲区有商品 wait(mutex); //等待可以使用缓冲区 nextc := buffer[out]; out := (out + 1) mod n; signal(mutex); //告诉其他进程: 缓冲区可以使用了 signal(empty); //告诉其他进程: 缓冲区空出一个地方 消费商品 nextc; until false;end; 注意wait(mutex)和signal(mutex)必须成对出现empty、full的wait、signal也要成对出现注意多个wait的顺序不能颠倒。 利用and信号量解决123456789101112生产者: … Swait(empty,mutex); buffer[in] := nextp; in := (in + 1) mod n; Ssignal(mutex,full);消费者: Swait(full,mutex); nextc := buffer[out]; out := (out + 1) mod n; Ssignal(mutex,empty); … 哲学家进餐问题利用记录型信号量12345678910var chopstick:array[0,…,4] of semaphore; 所有信号量初始值为1； repeat //第i个哲学家的活动 wait(chopstick[i]); //拿左筷子 wait(chopstick[(i+1) mod 5]); //拿右筷子 吃饭; signal(chopstick[i]); //放左筷子 signal(chopstick[(i+1) mod 5]); //放右筷子 思考; until false; 缺点： 如果每个人开始都先拿自己左边的筷子，可能导致人手一根筷子，而拿不到第二根筷子，从而全部阻塞，引起死锁。 and信号量12345678var chopstick: array[0,…,4] of semaphore; 所有信号量全部初始化为1; repeat Swait(chopstick[i], chopstick[(i+1) mod 5]); 吃饭; Ssignal(chopstick[(i+1) mod 5], chopstick[i]); 思考； until false; 1.5 进程通信进程通信类型 共享存储系统 消息传递系统 管道通信系统 1.6 线程和进程的区别与联系 调度 线程是调度的基本单位 进程是资源拥有的基本单位 拥有资源 线程不拥有系统资源，但是可以访问其隶属进程的系统资源，从而获得系统资源 并发性 支持多进程的系统中，不仅不同进程之间可以并发，同一进程中的线程也支持多并发 系统开销 进程切换时的时空开销大 进程切换时，只需保存和设置少量信息，因此开销很小 ​ 2. 处理机调度和死锁2.1 调度算法 先来先服务（FIFS）调度算法 短作业优先调度算法（SJF、SPF） 高优先权调度算法（FPF） 静态优先权：创建进程时分配，保持不变 动态优先权：随进程的执行或等待时间的增加而改变（防止长进程长期霸占） 高响应比优先权调度算法 动态优先权 优先权=（等待时间+要求服务时间）/要求服务时间 响应比=响应时间/要求服务时间 基于时间片的轮转调度算法——分时系统 2.2 实时调度实时调度与其他系统的区别：处理和控制的正确性不仅取决于计算的结果，还取决于计算和处理结果产生的时间。 实时调度算法 最早截止时间优先（EDF） 最低松弛度优先算法（LLF） 松弛度=完成截止时间-剩余运行时间-当前时间 2.3 产生死锁的原因和必要条件死锁：多个进程在运行过程中，因争夺资源二造成的一种僵局。这种僵局若无外力作用无法再向前推进。 产生死锁的原因： 资源竞争 进程推进顺序非法 死锁产生的必要条件 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 2.4 预防死锁的方法 摒弃请求和保持条件，规定所有进程在开始之前，都必须一次性申请其在整个运行过程中所需的全部资源，只要有一种资源不够，便不分配。 摒弃不剥夺条件，进程可以逐个申请资源，一旦申请的资源无法满足，立即释放已经保持的所有资源 摈弃环路等待条件 银行家算法：避免死锁 资源有序分配法：预防死锁 资源分配图化简法：检测死锁 撤销进程法：解决死锁 3. 存储器管理3.1 程序的装入和链接程序装入 绝对装入方式 程序中使用绝对地址，可编译时给出也可以有程序员直接赋予 可重定位装入方式 在装入是对程序中的指令和数据进行修改 动态运行时装入方式 执行代码是再进行地址转换 程序的链接 静态链接 装入时动态链接 运行时动态链接 3.2 连续分配方式 单一连续分配 把内存分为系统区和用户区两部分 固定分区分配 把用户区划分成若干个大小固定的分区，每个分区只放一个进程 当一个分区空闲时，可以选择一个新的进程进入那里运行 动态分区分配：根据进程的实际需要，动态分配内存空间 首次适应算法（FF） 以地址递增次序链接空闲分区，从链首开始查找，找到第一个满足请求大小的分区，从中划出请求大小的空间，余下的仍留在链中。 循环首次适应算法 由FF算法演变而成的。 从上次找到的空闲分区的下一个空闲分区查找。 最佳适应算法 分区按容量大小递增顺序排列，找到能满足分配的最小空闲分区。 动态重定位分区分配 对换定义：吧暂时不用的程序及其数据的部分或全部从内存移到外存上，以便腾出必要的空间 整体对换（进程对换） 部分对换（页面对换、分段对换） 3.3 基本分页存储管理方式页面与页表页面与物理块 把进程的逻辑地址空间分成若干大小相等的片，称之为页面或页，编号从0开始。 把内存的存储空间也划分成与页相同大小的片，这些片称为物理块或页框，编号从0开始 3.4 基本分段存储管理方式分页和分段的主要区别 页是信息的物理单位，分页是为消减内存的碎片，提高内存的利用率。分页仅是由于系统管理的需要。 段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 页的大小固定，由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；段的长度不固定，决定于用户所编写的程序，由编译程序编译源程序时，根据信息的性质来划分。 3.5 页面置换算法抖动：系统一直忙于页面的调入/调出，以致大部分CPU时间都用于处理缺页中断和页面淘汰上，很少能顾及到用户进程的实际执行的现象称为“抖动” 注意：缺页中断不一定引起页面淘汰。只有内存中没有空闲块时，缺页中断才会引起页面淘汰 最佳置换算法从内存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面 先进先出置换算法（FIFO）总是选择进程中驻留时间最长的页淘汰，即先进入内存的页面先淘汰出内存。 最近最久未使用置换算法（LRU）选择最近一段时间内最久不用的页面进行淘汰 4. 设备管理4.1 I/O控制方式程序控制方式忙——等待方式。 中断驱动方式​ 中断时以字节为单位进行控制的 进程要启动I/O设备工作时，由CPU向该设备控制器发出一条I/O命令，然后便可立即返回继续执行原来的任务。 设备控制器按照命令要求去控制指定设备。此时，CPU与I/O设备并行操作。 设备处理完数据后，便产生一个中断信号。此时，CPU便转而处理该信号。 DMA方式传输的基本单位是数据块，CPU与I/O设备之间每次传送至少一个数据块。仅在传送一个或多个数据块的开始或结束时才需要CPU干涉。 DMA工作过程 以从磁盘读入数据为例： 从磁盘读入数据块时，CPU将一条读指令送至磁盘控制器的命令寄存器(CR)中。 将数据读入的内存起始目标地址送入内存地址寄存器（MAR）中；将读数据的字(节)数送入数据计数器(DC)中 将磁盘的源地址送至DMA控制器的I/O逻辑中。 然后，启动DMA控制器进行数据传送，以后，CPU便可去处理其它任务。 此后，整个数据传送过程便由DMA控制器进行控制。 当DMA控制器已从磁盘读入一个字(节)的数据并送入数据寄存器(DR)后，将该字(节)传送到指定的内存单元中。 接着便对MAR内容加1，将DC内容减1。 若减1后DC内容不为0，表示传送未完，便继续传送下一个字(节)； 否则，由DMA控制器发出中断请求。 DR：数据寄存器，用于暂存数据 MAR：内存地址寄存器，存放数据的源/起始目标地址 DC：数据计数器，存放本次CPU要读或写的字节数 CR：命令/状态寄存器，接收从CPU发来的I/O命令或有关控制信息或设备状态 I/O通道控制方式 指令类型单一，主要局限于对I/O操作 没有自己的内存，通道程序放在内存里 在设置了通道后，CPU只需向通道发送一条I/O指令。通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成了规定的I/O任务后，才向CPU发中断信号 4.2 缓冲管理引入缓冲 缓和CPU与I/O设备间速度不匹配的矛盾 减少对CPU的中断频率 提高CPU和I/O设备之间的并行性 单缓冲和双缓冲单缓冲每当用户进程发出一个I/O请求时，OS便在内存总位置分配一个缓冲区 max(磁盘到缓冲区，CPU处理) + 缓冲区到用户区 双缓冲区设备输入时，先将数据送入缓冲区1，装满后转向缓冲区2 循环缓冲在循环缓冲中包括多个缓冲区，每个缓冲区的大小相同 作为输入的多缓冲区可分为三种类型： 空缓冲区R 已装满数据的缓冲区G 计算进程正在使用的工作缓冲区C 缓冲池公用缓冲池，池中设立多个缓冲区，为多个进程共享，以提高利用率 4.3 设备分配SPOOLing技术 脱机输入/输出技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反。 SPOOLing技术的实质是模拟脱机输入、输出 基本方法 用一个进程将设备输入的数据暂存到磁盘上 用另一个进程把暂存在磁盘上的数据传送到设备上 spooling 系统组成部分 输入井、输出井 磁盘上的两块大存储区，用于暂存输入、输出的数据 输入缓冲区、输出缓冲区 位于内存中，作用是缓和CPU和设备之间的速度差异 输入进程、输出进程 输入进程：利用输入缓冲区为中介，吧输入设备的数据存入输入井 输出进程：将用户数据存入输出井，设备空闲时再将输出井中的数据利用输出缓冲区送入设备 ​ 4.4 磁盘存储器管理磁盘调度算法 先来先服务（FCFS） 根据进程请求访问磁盘的先后次序进行调度 最短寻道时间优先（SSTF） 首先满足访问的磁道与当前所在磁道之间距离最短的进程。但是这种算法不能保证平均寻道时间最短 进程饥饿现象 因为只要不断有新进程的请求到达，且其所要访问的磁道与当前磁道之间的距离较近，新进程的I/O请求必然优先满足。致使老进程的请求长期无法得到满足 扫描算法（SCAN） 当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对象，应是要访问的磁道既在当前磁道之外，又是距离最近的。 这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁头换向为自外向里移动 循环扫描算法（CSCAN） 磁头只做单向移动。例如总是自里向外，当磁头移到最外的磁道并访问完后，磁头立即返回最里要访问的磁道。 5. 文件管理5.1 文件逻辑结构文件逻辑结构的类型 有结构文件 无结构文件（流式文件） Unix系统吧所有文件都看做流式文件 顺序文件记录可以任意顺序排列 索引文件顺序索引文件直接文件和hash文件外存分配方式连续分配方式文件存储于连续的盘块上 链接分配通过盘块上的链接指针，把保存在不同盘块上的各文件部分链接起来]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-theme-indigo-card主题安装及常见问题解决]]></title>
    <url>%2F2017%2F05%2F13%2Fhexo%2Fhexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令。 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 切换主题执行 git branch 显示所有本地分支，如果只存在一个分支，可以执行下面的命令获取另一分支的主题。 12345# 获取远程 card 分支，并切换$ git checkout -b card origin/card# 获取远程 master 分支，并切换$ git checkout -b master origin/master 此命令只需执行一次，之后使用 git checkout [branch] 命令在两个主题之间切换。 依赖安装还是在 Hexo 根目录，如果以下插件已安装过，无需再次安装。 Less主题默认使用 less 作为 css 预处理工具。 1$ npm install hexo-renderer-less --save Feed用于生成 rss。 1$ npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。 1$ npm install hexo-generator-json-content --save QRCode用于生成微信分享二维码。 可选，不安装时会请求 jiathis Api 生成二维码。 1$ npm install hexo-helper-qrcode --save 开启标签页1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 开启分类页仅 card theme 支持。 1hexo new page categories 修改 hexo/source/categories/index.md 的元数据 123layout: categoriescomments: false--- 常见问题如何设置文章摘要在 Markdown 中加 &lt;!-- more --&gt; 文章如何添加多个标签有两种多标签格式 1tags: [a, b, c] 或 1234tags: - a - b - c 修改 brand 图片（菜单上方背景图）替换 themes\indigo\source\img\brand.jpg，保持原文件名不变。 如何在文章中使用图标先到 fontawesome 找到你需要的图标名，比如：book，按以下格式使用： 1&lt;i class=&quot;icon icon-book&quot;&gt;&lt;/i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 1234567891011121314&lt;!-- 1.3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-lg&quot;&gt;&lt;/i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-2x&quot;&gt;&lt;/i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-3x&quot;&gt;&lt;/i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-4x&quot;&gt;&lt;/i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-5x&quot;&gt;&lt;/i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class=&quot;icon icon-book icon-pr&quot;&gt;&lt;/i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class=&quot;icon icon-book icon-pl&quot;&gt;&lt;/i&gt; 个别图标无法显示如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。 解决办法：可配置 ADBlock 不在你的站点运行。 生成站点后没有样式安装less 更改样式后网站没有生效确认非缓存问题后，执行 hexo clean 再进行生成上传。 更改站点配色编辑 themes\indigo\source\css\_partial\variable.less，更改对应的颜色变量。 配色参考：Material Design Color Palette Generator 添加404页面在 hexo/source 目录内新建 404.html。 设置元数据信息，如果不想套用主题布局可设置 layout 为 false。 123layout: false title: &quot;My Blog Name | 404&quot;--- 在博客中使用 Emoji参考 Can i use emoji in mypage? 多说 多说配置，取你的多说后台网址二级域名。比如我的是：http://ysblog.duoshuo.com/admin/中的 ysblog。 评论中如果显示 HTML 标签，你需要 进入多说设置 -&gt; 评论解析 -&gt; 解析HTML代码 勾选上。 已本地化多说脚本和样式，有个人需求的可以自行修改相关样式 source/css/_duoshuo/* 和脚本 source/css/js/embed.js。 配置站点配置编辑站点配置文件，hexo/_config.yml。 启用主题1theme: indigo 基本配置为了得到更好的使用体验，以下内容请务必填写完整，因为这些内容会在主题中得到展示。更多 1234567title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url feed配置参考 hexo-generator-feed 1234feed: type: atom path: atom.xml limit: 0 jsonContent配置为了节约资源，可以对 jsonContent 插件生成的数据字段进行配置，减少数据文件大小。参考 hexo-generator-json-content 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 主题配置编辑主题配置文件，themes/indigo/_config.yml。 左侧菜单默认配置如下 1234567891011121314151617menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下： 12345menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 fontawesome 图标已集成到主题中，你可以到 这个页面 挑选合适的图标。 rss1rss: /atom.xml favicon站点 logo，显示在浏览器当前标签页左上角。 1favicon: /favicon.ico 头像位于左侧菜单上方 1avatar: /img/logo.jpg email头像下方 1email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。 1color: &apos;#3F51B5&apos; 标签页 (old)配置标签页标题 12tags: title: 标签 页面标题 (card theme)自定义归档、标签、分类页的大标题。 123tags_title: Tagsarchives_title: Archivescategories_title: Categories 文章摘要可以在 Markdown 文件中加 &lt;!--more--&gt;以分割摘要与文章正文。未设置时，按 excerpt_length设置截取。 123456# 文章摘要渲染方式: 为 true 时将渲染为 html，否则为文本excerpt_render: false# 截断长度excerpt_length: 200# 文字正文页链接文字excerpt_link: 阅读全文... mathjax开启后，使你的站点支持公式渲染，by mathjax。 请按需开启，因为此项需要加载额外的 js 文件。 1mathjax: false 分享文章分享开关，by jiathis-api。 1share: true 文章打赏默认开启 1234reward: title: 谢谢大爷~ #显示的文字 wechat: /img/wechat.jpg #微信，关闭设为 false alipay: /img/alipay.jpg #支付宝，关闭设为 false 此外在 crad theme 中，可以通过在 markdown 头部添加 reward: false 来控制某些不想开启打赏的页面。 关闭 1reward: false 二维码请自行从微信、支付宝中下载。当两个二维码同时存在时，为保持显示效果的一致性，注意截图时的边框留白保持一致。必要时可借助PS等图片处理工具进行图片大小裁剪、压缩等。 站内搜索是否开启搜索 1search: true 布局开启后，文章页在大屏下会隐藏左侧菜单，专注阅读。 1hideMenu: true Toc开启文章内容导航。 123#toc: false #关闭toc: list_number: false # 决定导航使用的标签， true 为 ol， false 为 ul。 copyright (card theme)文章页版权声明内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io。 1copyright: 这里写留言或版权声明：&lt;a href=&quot;&lt;%- url_for(page.path) %&gt;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;%- url %&gt;&lt;/a&gt; less设置 less 编译时的入口文件路径，hexo-renderer-less。 1234less: compress: true # 是否压缩css paths: - source/css/style.less 评论集成了多说和 disqus，开启其一即可。 duoshuo-key 即多说创建站点时的二级域名。如：abc.duoshuo.com，就填 abc。 1duoshuo: duoshuo-key 或 1disqus_shortname: disqus_shortname 数据统计集成的有谷歌和 CNZZ，请填写你的站点标识。 12google_analytics: keycnzz: 站点id 谷歌站点验证 (card theme)1google_site_verification: false 规范网址 (card theme)让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径。使用规范网址 1canonical: http://imys.net 版权起始年份1since_year: 2006 自定义页面关于用户页面中作者相关的描述性文字，如不需要设为 false 1about: 用户页面中作者相关的描述性文字，如不需要设为 false]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布隆过滤器]]></title>
    <url>%2F2017%2F05%2F13%2F%E6%9E%B6%E6%9E%84%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介 布隆过滤器主要用于判断一个元素是否在集合中，常见的如垃圾邮件过滤的黑白名单方法、爬虫的网址判重模块等。 Hash表也可以用于判断元素是否在集合中，但是布隆过滤器只要Hash表的1/4或1/8甚至更少的空间复杂度就能完成同样的问题。 布隆过滤器存在一定的误报率，通过设计bitArray的大小可以将误报率控制在极低水平。使用布隆过滤器一定是在有一定容错概率的情况下。 布隆过滤器的设计假设数据查询的数据量为n，允许的失误率p 长度为m的BitArray，二进制数组，里面存放的数据都是0和1 k个相互独立的hash函数 添加元素 初始时将BitArray中的元素全部置为0 将单条数据str，分别用k个hash函数计算出对应的hash值，将这k个hash值再对m进行取模运算，得到数据h1,h2,……hk. 将BitArray h1、h2、……hk位置上的值置为1 每条数据都重复2、3步骤。 查询元素是否在集合中 将要查询的数据分别用k个hash函数计算出对应的hash值，然后对m进行取模运算，得到数据h1 h2 …… hk. 判断BitArray h1、h2、……、hk位置上的值是否全部都是1，如果全为1则表示数据已经在集合中，如果不全为1则表示数据不在集合中。 n k m p 之间的关系 样本个数n和允许失误概率p可以求出m $$m= - \frac{n*lnp}{(ln)^2}$$ 根据m可以求出k，hash函数的个数 ​$$k =ln2 \frac{m}{n} = 0.7 \frac{m}{n}$$ 由于在计算m和k的过程中都是向上取整的，失误率会降低，可以根据下面的公式计算出具体的失误率：$$p=(1- e ^-(\frac{nk}{m}))^k$$求出真实的失误率p]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F05%2F10%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9B%B4%E9%80%9Abat%E7%AE%97%E6%B3%95%2F7.%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[7.二叉树1. 二叉树遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216import java.util.LinkedList;import java.util.Stack;/** * * @author huzhiming * @遍历二叉树 * */class TreeNode&#123; int val; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class VisitTree&#123; public static void main(String[] args) &#123; String str = "1,2,3,4,5,6,7,#,8,#,#,9,#"; TreeNode root = deserialize(str); preOrder(root); System.out.println(); preOrder1(root); System.out.println(); inOrder(root); System.out.println(); inOrder1(root); System.out.println(); postOrder(root); System.out.println(); postOrder1(root); System.out.println(); levelOrder(root); &#125; // 递归前序遍历 public static void preOrder(TreeNode root) &#123; if (root != null) &#123; System.out.print(root.val + " "); preOrder(root.left); preOrder(root.right); &#125; &#125; // 非递归前序遍历 public static void preOrder1(TreeNode node) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (!stack.isEmpty() || node != null) &#123; while (node != null) &#123; System.out.print(node.val + " "); stack.add(node); node = node.left; &#125; if (!stack.isEmpty()) &#123; node = stack.pop(); node = node.right; &#125; &#125; &#125; // 递归中序遍历 public static void inOrder(TreeNode root) &#123; if (root != null) &#123; inOrder(root.left); System.out.print(root.val + " "); inOrder(root.right); &#125; &#125; // 非递归中序遍历 public static void inOrder1(TreeNode node) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (!stack.isEmpty() || node != null) &#123; while (node != null) &#123; stack.push(node); node = node.left; &#125; if (!stack.isEmpty()) &#123; node = stack.pop(); System.out.print(node.val + " "); node = node.right; &#125; &#125; &#125; // 递归后序遍历 public static void postOrder(TreeNode root) &#123; if (root != null) &#123; postOrder(root.left); postOrder(root.right); System.out.print(root.val + " "); &#125; &#125; // 非递归后序遍历 public static void postOrder1(TreeNode node) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode h = null; stack.add(node); while (!stack.isEmpty()) &#123; node = stack.peek(); // 左子树未访问 if (node.left != null &amp;&amp; h != node.left &amp;&amp; h != node.right) stack.add(node.left); // 右子树未访问 else if (node.right != null &amp;&amp; h != node.right) stack.add(node.right); else &#123; h = stack.pop(); System.out.print(h.val + " "); &#125; &#125; &#125; // 二叉树层次遍历 public static void levelOrder(TreeNode node) &#123; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(node); int current = 1; int next = 1; while (!queue.isEmpty()) &#123; current = next; next = 0; while (current &gt; 0) &#123; node = queue.poll(); System.out.print(node.val + " "); if (node.left != null) &#123; next++; queue.add(node.left); &#125; if (node.right != null) &#123; next++; queue.add(node.right); &#125; current--; &#125; System.out.println(); &#125; &#125; // 将序列化string转化成二叉树 public static TreeNode deserialize(String str) &#123; TreeNode head = null; String[] el = str.split(","); if ("".equals(str) || el.length == 0) return head; if (!el[0].equals("#")) &#123; head = new TreeNode(new Integer(el[0])); &#125; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(head); for (int i = 1; i &lt; el.length; i++) &#123; TreeNode parent = queue.peek(); if (el[i].equals("#")) &#123; if (i % 2 == 1) parent.left = null; else &#123; parent.right = null; queue.poll(); &#125; &#125; else &#123; int value = new Integer(el[i]); TreeNode node = new TreeNode(value); if (i % 2 == 1) parent.left = node; else &#123; parent.right = node; queue.poll(); &#125; queue.add(node); &#125; &#125; return head; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合_Map介绍]]></title>
    <url>%2F2017%2F05%2F10%2Fjava%2Fblog%2FJava%E9%9B%86%E5%90%88-Map%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[HashMap（非线程安全） HashMap底层由一个EntrySet数组构成，每个EntrySet都是一个链表 12345678910111213static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; ……&#125; loadFactor，加载因子，默认值是0.75。当map中的元素个数size&gt;=table.length*loadFactor时，hashMap 会进行扩容。如果loadFactor过小，则空间浪费比较严重；若loadFactor过大，则hashmap冲突的概率会加大，造成一些EntrySet链表过长。 创建hashMap时可以指定初始容量和加载因子，默认初始容量为16，加载因子为0.75 计算元素o 在table数组中的下标，其中h是根据o.key计算的hash值，length是指数组的长度 123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; hashMap中的key和value都可以为null，当key==null时，该元素会放在table下标为0的位置上。 12if (key == null) return putForNullKey(value); 123456789101112131415private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; //如果map中原来已经存在key值为null的元素，则更新value值 if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // hash值为0，key=null value=value 在table中位置index=0 addEntry(0, null, value, 0); return null;&#125; map中添加新元素时，是将元素添加在链表头。 123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; //threshold = table.length * loadFactor 判断是否需要扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125; 1234567//创建一个新的结点，插入链表头。即创建新元素时是插入链表头的。void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; //table[bucketIndex]表示的是链表头，链表头指向了新建的结点，同时新节点的next指针指向 了原来的链表头结点。 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++; &#125; map扩容是原来table长度的2倍。扩容时，需要遍历原来的map，将每个元素重新计算hash值和在新table的中位置，再放入新的table中。 1234567891011121314151617void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; //计算元素在新table中的位置 int i = indexFor(e.hash, newCapacity); //newTable[i]是其中一个链表的链表头 e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125; &#125; LinkedHashMap(非线程安全)继承自HashMap，在HashMap的基础之上维护着一条双向链表。LinkedHashMap中每个元素Entry中包含一个before和一个after指针。同时LinkedHashMap中还有一hearder指针。LinkedhashMap中还有一个标志位accessOrder，当这个位false时，链表是按节点的插入顺序排列的，当为true时，是按访问顺序排序的。 LinkedHashMap可以实现LRU（latest recently used）算法，将最近使用的放入表头 Hashtable(线程安全) HashTable是线程安全的容器，而HashMap是非线程安全的 HashTable 继承自Dictionary类，该类自Java1.0就已经存在；HashMap继承自AbstractMap,这个抽象类是是在1.2才加入的 Hashtable 不允许key和value为空值null；HashMap允许key和value为空值null。 Hashtable的hash函数不同 1234private int hash(Object k) &#123; // hashSeed will be zero if alternative hashing is disabled. return hashSeed ^ k.hashCode(); &#125; HashTable 默认初始容量是11，加载因子默认是0.75 HashTable计算index方法与HashTable不同 1234//hashtable 计算indexint index = (hash &amp; 0x7FFFFFFF) % tab.length;// HashMap 计算下标return h &amp; (length-1); HashTable扩容时原来table数组长度的两倍加1 1int newCapacity = (oldCapacity &lt;&lt; 1) + 1; TreeMap(非线程安全) Treemap 底层是通过红黑树算法实现的，想要了解TreeMap的实现必须先对红黑树有一定了解，下面先介绍一下红黑树的相关概念 红黑树简介红黑树是一种自平衡的二叉查找树，具有二叉树的所有特性。红黑树具有如下五点性质 结点要么是红色要么是黑色 根节点是黑色 每个叶子结点是黑色 从根节点到叶子结点的所有路径上不能有两个连续的红色结点 从任一结点到其每个叶子结点的所有路径都包含相同数目的黑色结点 ​ 红黑树 ​ 普通二叉树，根节点的左右子树不平衡 TreeMap介绍TreeMap相关定义TreeMap中包含信息中比较重要的有如下这些 12345678//比较器，用于比较结点的大小private final Comparator&lt;? super K&gt; comparator;//根节点private transient Entry&lt;K,V&gt; root = null;//元素的个数private transient int size = 0;//map修改次数private transient int modCount = 0; 对叶子结点的定义如下： 123456789101112131415static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left = null; Entry&lt;K,V&gt; right = null; Entry&lt;K,V&gt; parent; //新生成的结点都是黑色的 boolean color = BLACK; Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125;&#125; TreeMap添加元素方法put添加元素的时候首先判断root结点是否为空，如果是空直接创建新的结点作为map的根节点；如果不为空，则根据比较器（若创建TreeMap时未指定比价器，则以key的字典序作为比较器）找到元素的位置。寻找元素位置时是对二叉搜索树进行查找，key&gt;node 则查找右子树，key&lt;node查找左子树，key==node 直接更新node的value值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; //根节点为空 if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; //创建TreeMap时已经指定比较器 if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); //父节点大于新加的结点，则遍历左子树 if (cmp &lt; 0) t = t.left; //父节点小于新加结点，则遍历右子树 else if (cmp &gt; 0) t = t.right; else //父节点等于新加结点，则直接更新父节点的value值 return t.setValue(value); &#125; while (t != null); //循环结束还没找到结点key和新节点key相等，此时parent指向了叶子结点 &#125; else &#123; if (key == null) throw new NullPointerException(); //未指定比较器，则比较器设为字典序 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; //结点位置查找过程和上面一样 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; //如果遍历后还未找到key,则创建新节点，新节点的parent指向前面遍历后的最后一个叶子结点 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); //如果新节点的key小于parent的key,则新节点作为parent的左孩子，反之作为右孩子 if (cmp &lt; 0) parent.left = e; else parent.right = e; // 添加完新节点后 需要对这棵树进行调整平衡 fixAfterInsertion(e); size++; modCount++; return null; &#125; 上面的put方法只是将新节点插入了适当的位置，保证了此时的二叉树是二叉搜树，但它不一是平衡二叉树。所以在插入新节点后有一个修正操作fixAfterInsertion(e)，修正操作就是保证二叉树是平衡二叉树。 修改后 修改后 最后修改成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; //将新插入的结点设为红色 x.color = RED; // 循环直到 x不是根结点，且x的父节点不为红色 while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; //如果结点x的父节点P 是P的父节点G的左子树 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; //否则结点x的父节点P 是P父节点G的右子树 G &#125; else &#123; // y P // x x可能是左子树也可能是右子树 Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; //如果x是P的左孩子 if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; TreeMap 查找复杂度是O(logN)，HashMap的查找复杂度是O(1)，查找效率来说HashMap 效率更高。但是TreeMap存储的数据是有序的，而HashMap存储的数据是无序的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>TreeMap</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F05%2F09%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9B%B4%E9%80%9Abat%E7%AE%97%E6%B3%95%2F4.%E7%AB%99%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[4.栈和队列1.求滑动窗口内最大值一个数组，设置一个滑动窗口从左往右滑动，求出滑动过程中，滑动窗口中的最大值。 例如：数组{2，3，1，5，6，3，8}，滑动窗口的大小是3，则滑动过程中的每个滑动窗口最大值分别是： {2，3，1} 最大值是3； {3，1，5}最大值是5； {1，5，6}最大值是6； {5，6，3}最大值是6； {6，3，8}最大值是8； 所以滑动过程中最大值是{3，5，6，6，8} 思路：定义一个双向队列qmax，然后遍历数组，遍历过程中数组下标为i， 如果qmax为空，直接将i加入队列中，否则获取队列中最后一个元素j， 如果arr[j]>arr[i]，则直接将元素i加入队列中， 否则一直从队列移除末尾元素，直到arr[j]&lt;=arr[i]或者数组为空时，将元素i加入队列中，即保证队列中的存储的下标所对应数组元素是递减的。 每次遍历的是时候判断，是否已经达到滑动窗口的大小，达到则进一步判断队列头的下标是否在滑动窗口内，如果不在，则移除队列头，此时将队列头加入最大值列表中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.ArrayList;import java.util.LinkedList;/** * * @author huzhiming 求数组中每个滑动窗口中的最大值 * */public class MaxNumInSlideArr&#123; public static void main(String[] args) &#123; int[] arr = &#123; 2, 3, 4, 2, 6, 2, 5, 1 &#125;; findMaxNumInSlideArr(arr, 3); &#125; public static void findMaxNumInSlideArr(int[] num, int size) &#123; LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (size == 0) return; for (int i = 0; i &lt; num.length; i++) &#123; if (qmax.isEmpty()) qmax.add(i); else &#123; // 找到队列中第一个大于当前值得元素 while (!qmax.isEmpty() &amp;&amp; num[qmax.getLast()] &lt;= num[i]) qmax.removeLast(); qmax.add(i); &#125; if (i &gt;= size - 1) &#123; int head = qmax.getFirst(); //判断下标是否在滑动窗口内 if (i - head &gt; size - 1) qmax.removeFirst(); head = qmax.getFirst(); res.add(num[head]); &#125; &#125; System.out.println(res); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合_List介绍]]></title>
    <url>%2F2017%2F05%2F08%2Fjava%2Fblog%2FJava%E9%9B%86%E5%90%88-List%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[集合类介绍 ArrayList（非线程安全） ArrayList底层采用数组存放数据 创建时可以指定初始容量的大小，若不指定则默认是10. ArrayList扩容是1.5倍的增长 123int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//将数组内容拷贝到新创建的数组中，并返回新创建数组的引用elementData = Arrays.copyOf(elementData, newCapacity); arrayList不是线程安全的容器 当数组元素已经达到数组容量时才会发生扩容 Vector（线程安全） Vector与ArrayList实现基本相同，当时Vector是线程安全的，每个操作方法中加了synchronized关键字，属于线程安全的容器 创建Vector时可以指定初始容量，也可以指定发生扩容时扩容的大小。若没指定初始容量大小默认是10；若没有指定扩容的大小，默认是两倍增长，否则 12int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); LinkedList（非线程安全） LinkedList底层实现是通过链表，每个元素是一个Node结点 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 定义两个变量first、last分别指向链表的头结点和尾结点 实现了Queue 接口 offer(E e) 操作调用add方法，将元素插入队列的尾部 添加元素e之后 poll操作删除队列头元素，删除的是first结点 element操作返回队列头结点，即first结点，如果first==null 抛出异常 peek操作返回队列头结点，即first结点，如果first==null 则返回null 实现了Stack功能 push添加元素，注意是在链表的头结点处插入元素 pop 操作是删除链表的头结点 peek 操作返回链表的头结点]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>vector</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F05%2F07%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9B%B4%E9%80%9Abat%E7%AE%97%E6%B3%95%2F3.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[3. 字符串问题1.判断一棵树是否包含另一个数的拓扑结构给定两棵树的头结点t1、t2，判断t1中是否有与t2树拓扑结构完全相同的子树。 思路：对两棵树分别进行遍历（前、中、后任选一种），得到两个序列字符串str1,str2。判断str1中是否包含str2即可。 2.判断字符串是否是旋转词给定两个字符串str1、str2，判断str1和str2是否互为旋转词。旋转词：将字符串前面任意长的字符移动到字符串的末尾。 思路：首先判断str1和str2的长度是否相等，相等在进行下一步。str1+str1生成一个新的字符串str,检测str2是否是str的子串即可。 3.字符串逆序调整将str字符串中0到i的字符移动到末尾，要求空间复杂度O(1). 4.判断左括号和右括号配对问题()(())()()) 左括号和右括号匹配 (()()() 不匹配 思路：用一个变量num记录左括号的个数，当遇到左括号时num++,遇到右括号时num—，如果遍历过程中出现num\0 返回false. 5.求字符串中最长无重复子串问题如字符串abcddab，最长无重复子串是abcd 12345678910111213141516171819202122232425public static int getMaxNoneRepeatStringLength(String str)&#123; if (str == null || str.equals("")) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put(str.charAt(0), 0); // pre 表示以str[i-1]字符串结尾的最长无重复子串 int pre = 1; int max = 1; for (int i = 1; i &lt; str.length(); i++) &#123; char c = str.charAt(i); int temp = 0; if (map.containsKey(c)) &#123; temp = i - map.get(c); temp = temp &gt; pre + 1 ? pre + 1 : temp; &#125; else temp = pre + 1; pre = temp; max = max &gt; temp ? max : temp; map.put(c, i); &#125; return max;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F05%2F07%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9B%B4%E9%80%9Abat%E7%AE%97%E6%B3%95%2F2.%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2.排序问题计数排序例题： 员工身高：165、168、170、169、182、178、169、170、175、185 将员工的身高从小到大排列。 思路：成年人的升高一般是从150——250，我们可以从150到250分别建立桶，桶的编号分别为150到250，然后依次将员工身高放入桶中，最后将桶中的数据依次倒出即可。 1234567891011121314151617181920212223242526272829// 计数排序public static void countingSort()&#123; int[] arr = &#123; 165, 168, 170, 169, 182, 178, 169, 170, 175, 185 &#125;; //计数桶 int[] countArr = new int[100]; //桶的下标从base开始 int base = 150; for (int i = 0; i &lt; arr.length; i++) &#123; //计数每个数所在桶的下标 int temp = arr[i] - base; //对应桶中数量增加1 countArr[temp] = countArr[temp] + 1; &#125; int index = 0; //将桶中的数倒出 for (int i = 0; i &lt; countArr.length; i++) &#123; int num = countArr[i]; for (int j = 0; j &lt; num; j++) &#123; arr[index] = i + base; index++; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 基数排序假设排序的数是十进制的数，建立10个桶，桶的编号依次是0——9， 将每个数按个位数中值放入对应的桶中，然后依次将0到9号桶中的数倒出； 将每个数按十位数中值依次放入桶中，然后依次将0到9号桶中的数倒出； 将每个数按十位数中值依次放入桶中，然后依次将0到9号桶中的数倒出； …… 123456789101112131415161718192021222324252627282930313233343536373839// 基数排序public static void basicNumSort()&#123; int[] arr = &#123; 34, 16, 39, 490, 356, 258, 12, 8, 166, 9, 48945 &#125;; ArrayList&lt;Integer&gt;[] bucket = new ArrayList[10]; for (int i = 0; i &lt; 10; i++) bucket[i] = new ArrayList&lt;&gt;(); boolean flag = true; //num 表示要计算的位数，1：表示计算个位数的值， 10：表示计算10位数上的值 int num = 1; while (flag) &#123; flag = false; for (int i = 0; i &lt; arr.length; i++) &#123; int temp = arr[i] / num; //只要还有一个数除以num不为0则循环继续 if (temp != 0) flag = true; //求得对应位数上的值 temp = temp % 10; //将数据放入对应的桶中 bucket[temp].add(arr[i]); &#125; num *= 10; int index = 0; //从0-9号桶中倒出数值 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; bucket[i].size(); j++) &#123; arr[index] = bucket[i].get(j); index++; &#125; bucket[i].clear(); &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 排序相关的经典案例1. 荷兰国旗问题数组中 只包含0、1、2，要求将0移动左边，2移动到右边，最终结果是 0、0、0…… 1、1、…… 2、2、…… 定义两个指针low和high，low指向0位置，high指向最高位置，从左向右遍历，遇到0则和low位置数据交换，low++；遇到1直接跳过，遇到2则和high位置交换，high—。 {1、0、1、2、1、0、1、2、0} 12345678910111213141516171819202122public static void case1()&#123; int[] arr = &#123; 1, 0, 2, 1, 0, 2, 1, 0, 1, 2, 2, 1, 1, 0 &#125;; int low = 0; int high = arr.length - 1; int index = 0; while (index &lt;= high) &#123; if (arr[index] == 0) &#123; arr[index] = arr[low]; arr[low++] = 0; index++; &#125; else if (arr[index] == 2) &#123; arr[index] = arr[high]; arr[high--] = 2; &#125; else index++; &#125; System.out.println(Arrays.toString(arr));&#125; 2. 有序矩阵中寻找指定值问题矩阵中每一行递增，每一列递增，寻找是否存在指定值k。 思路：从左下角出发，当矩阵中的值小于k时，向右移动；当矩阵中的值大于k时，向上移动。 12345678910111213141516171819public static boolean case2(int k) &#123; int[][] arr = &#123; &#123; 1, 3, 5, 7 &#125;, &#123; 4, 6, 8, 10 &#125;, &#123; 7, 9, 11, 13 &#125;, &#123; 10, 12, 14, 16 &#125; &#125;; int x = 0; int y = arr.length - 1; while (x &lt; arr[0].length &amp;&amp; y &gt;= 0) &#123; if (arr[x][y] == k) return true; else if (arr[x][y] &gt; k) y--; else x++; &#125; return false; &#125; 3. 寻找数组中需要排序的数组长度例如数组{1，2，4，5，6，3，7，8，9}，需要重新排列的子数组是{4，5，6，3}，求这个子数组的长度。 思路：分两次遍历， 第一次从左往右遍历，定义max 表示从0-i以前的最大值，定义pos1记录当max&gt;arr[i]时，i的位置。 第二次从右往左遍历，定义min表示从i-len以后的最小值，定义pos2记录当min&lt;arr[i]时，i的位置。 最后求出pos1和pos2之间的差值。 pos1和pos2的意义： pos1:表示数组中下标从pos1+1到N，这些数是有序的，不用交换位置。 pos2:表示数组中下标从0到pos2-1,这些数是有序的，不用交换位置。 12345678910111213141516171819202122232425262728293031public static void case3()&#123; int[] arr = &#123; 2, 1, 3, 3, 6, 5, 8, 7, 9 &#125;; int max = arr[0]; int pos1 = 0; //从左到右遍历 for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt;= max) max = arr[i]; else pos1 = i; &#125; int min = arr[arr.length - 1]; int pos2 = 0; //从右到左遍历 for (int i = arr.length - 2; i &gt;= 0; i--) &#123; if (arr[i] &lt;= min) min = arr[i]; else pos2 = i; &#125; int res = 0; if (pos1 == pos2) res = 0; else res = pos1 - pos2 + 1; System.out.println(res);&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F05%2F06%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9B%B4%E9%80%9Abat%E7%AE%97%E6%B3%95%2F1.2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[二叉树层次遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.*;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class TreePrinter &#123; public int[][] printTree(TreeNode root) &#123; // write code here if(root == null)&#123; return null; &#125; //存放所有行的列表 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); //存放一行数据的数组 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); //辅助的队列 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); //辅助变量last 当前行最右节点,nlast 下一行的最右节点 TreeNode last = root; TreeNode nlast = null; //1:首先将头节点入队 queue.offer(root); //只要辅助队列不为空，就一直进行遍历操作 while(!queue.isEmpty())&#123; //换行前的操作，将出队的每个节点值放入行数组中 //每换行一次，将行数组加入大数组中，行数组清空 //2:弹出队首节点，并将节点值放入数组 TreeNode popNode = queue.poll(); array.add(popNode.val); //3：当前弹出节点的左右节点如果存在，就分别入队;同时令nlast跟踪每个入队的节点 if(popNode.left != null)&#123; queue.offer(popNode.left); nlast = popNode.left; &#125; if(popNode.right != null)&#123; queue.offer(popNode.right); nlast = popNode.right; &#125; //4:[什么时候换行]如果当前出队节点等于last节点，说明遍历到了一行的行尾，该换行了 if(popNode == last)&#123; last = nlast; arrayList.add(array); array = new ArrayList&lt;Integer&gt;(); &#125; &#125; //遍历完后，将链表转换为二位数组形式 int[][] result = new int[arrayList.size()][]; for(int i =0;i&lt;arrayList.size();i++)&#123; //二维数组第i行的数组 result[i] = new int[arrayList.get(i).size()]; for(int j = 0;j&lt;result[i].length;j++)&#123; result[i][j] = arrayList.get(i).get(j); &#125; &#125; return result; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合-继承关系和常用API]]></title>
    <url>%2F2017%2F05%2F05%2Fjava%2Fblog%2FJava%E9%9B%86%E5%90%88-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[集合继承关系Collection集合的类继承关系图： Map集合继承关系图： 常用的APIArrayList：123456789101112131415161718//List尾部添加元素boolean add(E e);//在index位置添加元素public void add(int index,E element);//移除元素oboolean remove(Object o);//移除下标index的元素public E remove(int index);//清空列表public void clear();//添加集合中的全部元素public boolean addAll(Collection&lt;? extends E&gt; c);//返回list的遍历public Iterator&lt;E&gt; iterator();//是否包含元素public boolean contains(Object o);//将下标为index元素替换public E set(int index,E element) Queue：12345678910//添加元素boolean add(E e);//获取并移除队列头,此队列为空时将抛出一个异常。E remove();//获取并移除此队列的头，如果此队列为空，则返回 null。E poll();//获取，但是不移除此队列的头。此方法与 peek 唯一的不同在于：此队列为空时将抛出一个异常。E element();//获取但不移除此队列的头；如果此队列为空，则返回 null。E peek(); Set:12345678910//添加元素boolean add(E e);//移除元素boolean remove(Object o);//添加所有集合元素boolean addAll(Collection&lt;? extends E&gt; c);//清空集合void clear();//返回set的迭代器Iterator&lt;E&gt; iterator(); Stack: 继承自vector，是线程安全的12345678910//把项压入堆栈顶部。public E push(E item);//移除栈顶元素public E pop();//返回栈顶元素，但是不删除public E peek();//测试栈是否为空public boolean empty();//返回元素在栈中的位置，以1为基数，-1表示不存在public int search(Object o);]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F04%2F26%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%2F2.2%E6%B1%82%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[layout:false二、求子数组和为k的最大长度题目： 给定一个数组 arr，该数组无序，但每个值均为正数，再给定一个正数 k。求 arr的所有子数组中所有元素相加和为 k 的最长子数组长度。例如，arr=[1,2,1,1,1]，k=3。累加和为 3 的最长子数组为[1,1,1]，所以结果返回 3。 【要求】 时间复杂度 O(N)，额外空间复杂度 O(1) 思路：定义两个指针left和right，初始时left和right都指向0位置。sum记录left和right之间元素之和，初始sum=0。len记录当前最长子数组长度，初始时len=0 当sum&lt;k时，sum+=arr[right]，然后right往右移动 当sum&gt;k时，sum-=arr[left]，然后left向右移动 当sum=k时，计算这时数组的长度temp=right-left。比较len与temp的长度大小。然后再计算sum+=arr[right]，right向右滑动。 123456789101112131415161718192021222324public static int getMaxSubArrayLength(int[] arr, int k)&#123; if (arr == null || arr.length &lt; 1) return 0; int left = 0, right = 0; int sum = 0; int len = 0; while (right &lt; arr.length) &#123; if (sum &lt; k) &#123; sum += arr[right++]; &#125; else if (sum &gt; k) &#123; sum -= arr[left++]; &#125; else &#123; int temp = right - left; len = len &lt; temp ? temp : len; sum += arr[right++]; &#125; &#125; return len;&#125; ​]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F04%2F26%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%2F2.1%E6%B1%82%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[二、求子数组的最大累加和 题目：求一个数组的子数组最大累加和，数组元素可正可负。 如{3、-2、1、-6、3、2、-1、3} 思路：从前往后遍历，cur记录当前累加和，res记录当前遍历的最大和。当cur&lt;0时，则将cur置为0，每遍历一个数对cur与res进行比较，cur大则更新res。 初始时 cur=3、res=3 {3、-2、1、-6、3、2、-1、3} -2，cur=3+(-2)=1, cur&lt;res 故res=3 1，cur=1+1=2 , cur&lt;res 故res=3 -6，cur=2+(-6)， cur&lt;res 故res=3，又cur&lt;0 故 cur=0. 3，cur=0+3=3 cur&lt;=res 故res=3 2，cur=3+2=5 cur&gt;res 故 res=5 -1，cur=5+(-1)=4 cur&lt;res 故 res=5 3，cur=4+3=7 cur&gt;res 故res=7 123456789101112131415161718public static int getMaxSubArraySum(int[] arr)&#123; if (arr == null || arr.length == 0) return 0; int len = arr.length; // 记录从0到位置的最大和 int res = arr[0]; int cur = arr[0]; for (int i = 1; i &lt; len; i++) &#123; // 如果cur小于0 则立刻更新成0； cur = cur &lt; 0 ? 0 : cur; // 将arr[i]加入前缀和中 cur += arr[i]; res = res &lt; cur ? cur : res; &#125; return res;&#125; 变形题 求一个数组中两个子数组的最大累加和 { 3, -2, 1, -6, 3, 2, -4, 3 }; 两个子数组的最大累加和 是3+5=8. 思路：从前往后求出从0到i的最大累加和 LMax；求出从后往前n到i的最大累加和RMax。最后以i最为遍历，计算sum=LMax[i]+RMax[i+1]，求出sum的最大值即可。LMax和RMax的求法和上面题目一样 3, -2, 1, -6, 3, 2, -4, 3 LMax={3,3,3,3,3,5,5,5} RMax={5,5,5,5,5,3,3,3} 123456789101112131415161718192021222324252627282930313233public static int getMaxTwoSubArraySum(int[] arr)&#123; // 如果length&lt;2则不能不划分出两个子数组 if (arr == null || arr.length &lt; 2) return 0; int len = arr.length; int[] lMax = new int[len]; int[] rMax = new int[len]; lMax[0] = arr[0]; int cur = arr[0]; for (int i = 1; i &lt; len; i++) &#123; // 求从0到i子数组最大和 cur = cur &lt; 0 ? 0 : cur; cur += arr[i]; lMax[i] = cur &gt; lMax[i - 1] ? cur : lMax[i - 1]; &#125; rMax[len - 1] = arr[len - 1]; cur = arr[len - 1]; for (int i = len - 2; i &gt;= 0; i--) &#123; // 从后往前遍历，计算从n 到 i 子数组最大和 cur = cur &lt; 0 ? 0 : cur; cur += arr[i]; rMax[i] = cur &gt; rMax[i + 1] ? cur : rMax[i + 1]; &#125; int res = arr[0] + arr[1]; for (int i = 1; i &lt; len - 1; i++) &#123; int sum = lMax[i] + rMax[i + 1]; res = sum &gt; res ? sum : res; &#125; return res;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F04%2F25%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%2F%E4%B8%80%E3%80%81%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%9F%B1%E5%AD%90%E5%9B%B4%E5%9F%8E%E7%9A%84%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[求两个柱子围城的面积题目： ​ 给定一个非负数的数组，数组中的每个值代表一个柱子的高度，柱子的宽度是 1。两个柱子之间可以围成一个面积，规定:面积=两根柱子的最小值*两根柱子之间的距离。比如数组[3,4,2,5]。3 和 4 之间围成的面积为 0，因为两个柱子是相邻的，中间没有距离。3 和2 之间围成的面积为 2，因为两个柱子的距离为 1，且 2 是最短的柱子，所以面积=1*2。3 和 5 之间围成的面积为 6，因为两个柱子的距离为 2，且 3 是最短的柱子，所以面积=3*2。求在一个数组中，哪两个柱子围成的面积最大，并返回值。要求:实现时间复杂度 O(N)，额外空间复杂度 O(1)的解法 思路：定义两个指针head、tail，分别指向头和尾，面积S = min(head,tail)*(head 到tail的距离)。计算完成之后，当head&lt;tail则head向前移动，反之tail 向中间移动。循环计算最大值 ​ head=3 tail=5 {3、4、2、5} s=3*2=6 ​ head=4 tail=5 {3、4、2、5} s=4*1=4 ………… 12345678910111213141516171819202122public static int getMaxValue(int[] arr)&#123; int res = 0; int head = 0; int tail = arr.length - 1; while (head &lt; tail) &#123; int min = 0; if (arr[head] &lt; arr[tail]) &#123; min = arr[head]; head++; &#125; else &#123; min = arr[tail]; tail--; &#125; int s = min * (tail - head); res = s &gt; res ? s : res; &#125; return res;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F04%2F25%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%2F%E4%B8%80%E3%80%81%E6%B1%82%E6%95%B0%E7%BB%84%E5%AE%B9%E5%99%A8%E8%A3%85%E6%B0%B4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[求数组容器装水问题 给定一个非负数的数组，代表一个容器。例如数组[0,1,0,2,1,0,1,3,2,1,2,1]，就是以下图形中黑色的部分。如果用这个容器接水的话，请问可以接多少水?还以这个数组为例，可以接 6 格水，就是以下图形中蓝色的部分。要求:实现时间复杂度 O(N)，额外空间复杂度 O(1)的解法 思路：对每一格装水量进行计算，第i格能装水的量 : ​ value[i]=Min{max{arr[0],arr[1],……arr[i-1]}, max{arr[i+1],arr[i+2],……arr[n]}} - arr[i]; 即value[i] 就是找i左边最大值和i右边的最大值，取这两个最大值得较小值最为瓶颈，最后减去arr[i]，就是它的装水量。 解法一123456789101112131415161718192021222324252627public static int getWater(int[] arr)&#123; int res = 0; //用数组leftMax 记录从0到i-1中最大的数 int[] leftMax = new int[arr.length]; //用数组rightMax 记录从i+1到n中的最大值 int[] rightMax = new int[arr.length]; int max = 0; for (int i = 0; i &lt; arr.length; i++) &#123; leftMax[i] = max = max &lt; arr[i] ? arr[i] : max; &#125; max = 0; for (int i = arr.length - 1; i &gt;= 0; i--) &#123; rightMax[i] = max = max &lt; arr[i] ? arr[i] : max; &#125; for (int i = 1; i &lt; arr.length - 1; i++) &#123; //求两个最大值中的较小值 int min = leftMax[i - 1] &gt; rightMax[i + 1] ? rightMax[i + 1] : leftMax[i - 1]; //如果较小值小于当前值，则不进行计算 res += min &gt; arr[i] ? (min - arr[i]) : 0; &#125; return res;&#125; 解法二1234567891011121314151617181920public static int getWater1(int[] arr)&#123; int res = 0; int[] rightMax = new int[arr.length]; int max = 0; for (int i = arr.length - 1; i &gt;= 0; i--) &#123; //计算从i+1 到n 最大值 rightMax[i] = max = arr[i] &gt; max ? arr[i] : max; &#125; //max 存放从0到 i-1中的最大值 max = arr[0]; for (int i = 1; i &lt; arr.length - 1; i++) &#123; //求出左侧和右侧两遍最大值中的较小值 int min = max &gt; rightMax[i + 1] ? rightMax[i + 1] : max; res += min &gt; arr[i] ? (min - arr[i]) : 0; // 更新左侧的最大值 max = arr[i] &gt; max ? arr[i] : max; &#125; return res;&#125; 解法三：思路：用leftMax记录当前左侧访问到的的最大值，用rightMax记录当前访问到的右侧最大值。 ​ leftMax=6 rightMax=7 6、5、7、4、3……5、7、3、9、8、7 left=5 right=8 当leftMax&lt;rightMax时，左侧的成为瓶颈，计算left=5所能盛水的量 value= leftMax-5=1，left向前移动 ​ leftMax=6 rightMax=7 6、5、10、4、3……5、7、3、9、8、7 left=10 right=8 leftMax还是大于rightMax，还是左侧的是瓶颈，计算left=10所能盛水的量，由于leftMax&lt;left，所以不能盛水，更新leftMax=10，left向前移动 ​ leftMax=10 rightMax=7 6、5、10、4、3……5、7、3、9、8、7 left=4 right=8 leftMax大于rightMax，右侧成为瓶颈,计算right=8的盛水量，rightMax&lt;right,所以不能盛水，更新rightMax=8，right向前移动 ……………… 12345678910111213141516171819202122232425public static int getWater2(int[] arr)&#123; int res = 0; int leftMax = arr[0], rightMax = arr[arr.length - 1]; int left = 1, right = arr.length - 2; while (left &lt; right) &#123; if (leftMax &lt;= rightMax) &#123; //左侧最大值小于右侧最大值，计算left的盛水量 if (leftMax &gt; arr[left]) res += leftMax - arr[left]; else //leftMax小于left 则更新最大值 leftMax = arr[left]; left++; &#125; else &#123; if (rightMax &gt; arr[right]) res += rightMax - arr[right]; else rightMax = arr[right]; right--; &#125; &#125; return res;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F04%2F22%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2FMac%20redis%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Mac redis 安装教程redis环境搭建 到官网下载最新版本的redis，本次下载的版本是redis-3.2.8 下载之后解压redis-3.2.8.tar.gz 进入解压后的文件夹redis-3.2.8 编译测试：sudo make test 编译成功！ redis安装：sudo make install redis默认安装在usr/local/bin 目录下，可以进入usr/local/bin目录下查看这些工具 主要包含以下几个工具： ./redis-benchmark //用于进行redis性能测试的工具 ./redis-check-dump //用于修复出问题的dump.rdb文件 ./redis-cli //redis的客户端 ./redis-server //redis的服务端 ./redis-check-aof //用于修复出问题的AOF文件 ./redis-sentinel //用于集群管理 将文件夹中redis.conf配置文件复制到/etc/目录下面，对配置文件进行修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#修改为守护模式 daemonize yes #设置进程锁文件 pidfile /usr/local/redis/redis.pid #端口 port 6379 #客户端超时时间 timeout 300 #日志级别 loglevel debug #日志文件位置 logfile /usr/local/redis/log-redis.log #设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id databases 8 ##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 #save &lt;seconds&gt; &lt;changes&gt; #Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 #指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间， #可以关闭该#选项，但会导致数据库文件变的巨大 rdbcompression yes #指定本地数据库文件名 dbfilename dump.rdb #指定本地数据库路径 dir /usr/local/redis/db/ #指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能 #会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有 #的数据会在一段时间内只存在于内存中 appendonly no #指定更新日志条件，共有3个可选值： #no：表示等操作系统进行数据缓存同步到磁盘（快） #always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） #everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 启动redis：redis-server ,如果要加载我们修改后的配置文件则在后面加上配置文件路径 redis-server /etc/redis.conf 启动后如图所示： 启动redis客户端。另外打开一个终端，输入 redis-cli 关闭redis服务器，在客户端中输入 127.0.0.1:6379&gt; shutdown redis卸载删除进入redis安装目录usr/local/bin。只需将redis安装文件删除即可。删除该目录下所有redis开头的文件 sudo rm -f redis.*]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F04%2F21%2Fjava%2FJava%E6%BA%90%E7%A0%81%2FArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList本文ArrayList源码是JDK1.7版本。 ArrayList简介ArrayList底层是通过Object数组实现的，可实现动态扩容，ArrayList不是线程安全的。可通过Collections.SynchronizedList()方法将List转换成线程安全的容器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; //默认初始化的容量 private static final int DEFAULT_CAPACITY = 10; //未存放数据时的空数组 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //存放数据的数组 private transient Object[] elementData; //arrayList真正存放的数据个数 private int size; //带数组容量的构造函数 public ArrayList(int initialCapacity) &#123; super(); //如果初始化容量小于0，则抛出异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); //创建容量是initialCapacity的Object数组 this.elementData = new Object[initialCapacity]; &#125; //无参构造函数 public ArrayList() &#123; super(); //存放数据的数组指向默认的空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; //构造函数中带集合参数，即将集合中的元素放入新创建的ArrayList中 public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将集合中的元素转换成数组，并将这个数组作为ArrayList存放数据的数组 elementData = c.toArray(); size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; //将数组的大小调整为实际元素个数 public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; public void ensureCapacity(int minCapacity) &#123; //当数组还是空时minExpand=DEFAULT_CAPACITY,否则minExpand=0 int minExpand = (elementData != EMPTY_ELEMENTDATA)? 0: DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; // minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; //数组修改次数加1 modCount++; //扩容数组大小大于数组实际大小，则进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; //最大的数组大小 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //数组扩容 private void grow(int minCapacity) &#123; //原先数组大小 int oldCapacity = elementData.length; //新数组的大小=(1+0.5)*oldCapcity int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果1.5倍扩容机制小于指定minCapacity，就将新数组大小设为minCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果newCapacity大于最大数组大小，则newCapacity=Integer.MAX_VALUE if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; //数组的最大长度Integer.MAX_VALUE private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; //返回实际元素的个数 public int size() &#123; return size; &#125; //返回数组是否为空 public boolean isEmpty() &#123; return size == 0; &#125; //判断数组中是否包含某个元素 public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; //返回元素在数组中的位置，若不存在返回-1 public int indexOf(Object o) &#123; if (o == null) &#123; //如果O是null，则顺序查找数组第一个为空的元素，并返回下标 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; //如果O不为空，则顺序查找数组第一个和O相等的元素，并返回下标 for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; //若数组中不存在元素O，则返回-1 return -1; &#125; //返回从数组尾部开始查找第一个和O相等的元素的位置,若不存在返回-1 public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; //返回对数组的备份/克隆 public Object clone() &#123; try &#123; @SuppressWarnings("unchecked") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; //将ArrayList 转换成Object数组 public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; //将List装换成指定类型的数组，并放入数组a中 @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; //如果数组a的大小小于List的实际长度，则新建数组a，并将List拷贝进数组a中 if (a.length &lt; size) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; //获取数组中指定位置的元素 @SuppressWarnings("unchecked") E elementData(int index) &#123; return (E) elementData[index]; &#125; //获取List指定位置的元素 public E get(int index) &#123; //确保位置index是否合法，没有越界 rangeCheck(index); return elementData(index); &#125; //将元素放入list指定位置中 public E set(int index, E element) &#123; //检查下标是否合法 rangeCheck(index); //记录list中index位置原先的值 E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; //在list数组末尾添加新元素 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); elementData[size++] = e; return true; &#125; //在指定位置添加新元素 public void add(int index, E element) &#123; //检查下标index是否合法 rangeCheckForAdd(index); // ensureCapacityInternal(size + 1); // Increments modCount!! //将index以后的元素全部向后移动一位 System.arraycopy(elementData, index, elementData, index + 1,size - index); //将元素放入index位置 elementData[index] = element; size++; &#125; //移除指定位置的元素 public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) //将index以后的数组元素全部往前移动一位 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将数组最后一位置空 elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; //移除指定元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; //内部移除元素操作 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //将最后一个元素置空 elementData[--size] = null; &#125; //清空数组 public void clear() &#123; modCount++; for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; //在List末尾添加集合元素 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount //在elementData数组的末尾添加数组a System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; //在指定位置添加集合元素 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; //确保数组容量大于size + numNew，如果小于则扩容 ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) //将elementData数组index后面的元素全部向后移动 numNew System.arraycopy(elementData, index, elementData, index + numNew, numMoved); //将集合中的元素复制到elementData中，从位置index开始放入元素 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; //移除List中从fromIndex到toIndex的元素 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; //将toIndex以后的元素向前移动拷贝 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); //数组的新容量 int newSize = size - (toIndex-fromIndex); //将数组后面元素清空，否则容易造成内存泄漏 for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; //检查数组下标是否大于数组容量 private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; //添加元素时候检查添加位置是否合法 private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+size; &#125; //移除List中包含集合C中的所有元素 public boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false); &#125; //移除List中所有不在集合C中的元素 public boolean retainAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; // r代表读的位置，w代表是写的位置 int r = 0, w = 0; boolean modified = false; try &#123; //List从前向后遍历 for (; r &lt; size; r++) //根据标志位判断要保留的元素在不在集合c中 if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; //如果遍历过程中发生异常，没有遍历完List，则把未遍历过的元素添加在w位置后面 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; //将数组中出来要保留的元素外其余的全部清除 for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; //序列化写方法，JavaList中的信息写入输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence), starting at the specified position in the list. * The specified index indicates the first element that would be * returned by an initial call to &#123;@link ListIterator#next next&#125;. * An initial call to &#123;@link ListIterator#previous previous&#125; would * return the element with the specified index minus one. * * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index); &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence). * * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings("unchecked") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException("fromIndex = " + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException("toIndex = " + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException("fromIndex(" + fromIndex + ") &gt; toIndex(" + toIndex + ")"); &#125; private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return this.size; &#125; public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings("unchecked") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+this.size; &#125; private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F04%2F20%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%2F%E4%B8%80%E3%80%81%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[求数组中最长递增子序列求数组中最长递增子序列长度 题目：求数组中最长的递增子序列。如组数arr{3，2，5，4，7，8，1，9}，这个数组中最长递增子序列是{2，4，7，8，9}，它的长度是5。 解法一：算法复杂度O(N^2^)定义一个数组记录h，h[i]记录以数组arr[i]结尾的最长子序列。 arr：{3，2，5，4，7，8，1，9} h：{1} 元素3 h：{1，1} 元素2 h：{1，1，2} 元素5 h：{1，1，2，2} 元素4 h：{1，1，2，2，3} 元素7 h：{1，1，2，2，3，4} 元素8 h：{1，1，2，2，3，4，1} 元素1 h：{1，1，2，2，3，4，1，5} 元素9 求以arr[i]结尾的最长子序列长度，从h数组中第i-1位置往前找到值小于arr[i]但是h[j]最大的值。最后从h中找到最大值。 12345678910111213141516171819202122232425public int maxArr()&#123; int[] arr = &#123; 3, 1, 5, 4, 7, 8, 1, 6, 10 &#125;; int[] h = new int[arr.length]; h[0] = 1; for (int i = 1; i &lt; arr.length; i++) &#123; int max = 0; //从第i-1为开始查找小于arr[i]的最大h值 for (int j = i - 1; j &gt;= 0; j--) &#123; if (arr[i] &gt; arr[j] &amp;&amp; max &lt; h[j]) max = h[j]; &#125; h[i] = max + 1; &#125; //求h中的最大值 int max = 0; for (int i = 0; i &lt; h.length; i++) &#123; if (max &lt; h[i]) max = h[i]; &#125; return max;&#125; 解法二：复杂度O(NlogN)同样定义一个数组ends,end[0]——end[i] 表示以end[i]结尾的最长子序列 arr: {3，2，5，4，7，8，1，9} ends: {3} 3 ends: {2} 2 如果ends中最后一个元素值大于arr[i],则在ends找到第一个大于arr[i]的元素将其替换 ends: {2,5} 5 如果ends中最后一个元素值小于arr[i],则在ends数组后面直接添加新元素 ends: {2,4} 4 ends: {2,4,7} 7 ends: {2,4,7,8} 8 ends: {1,4,7,8} 1 ends: {1,4,7,8,9} 9 123456789101112131415161718192021222324252627282930313233public int maxArr1(int[] arr)&#123; int[] ends = new int[arr.length]; ends[0] = arr[0]; int max = 1; for (int i = 1; i &lt; arr.length; i++) &#123; if (ends[max - 1] &lt; arr[i]) &#123; ends[max] = arr[i]; max++; &#125; else &#123; int low = 0; int high = max - 1; int pos = high; while (low &lt;= high) &#123; int middle = low + (high - low) / 2; if (ends[middle] &gt; arr[i]) &#123; high = middle-1; pos = middle; &#125; else low = middle + 1; &#125; ends[pos] = arr[i]; &#125; &#125; return max;&#125; 求点数组中最长子序列 给定一个 N*2 的二维数组，看作是一个个二元组，例如[[a1,b1],[a2,b2],[a3,b3]]，规定:一个如果想把二元组甲放在二元组乙上，甲中的 a 值必须大于乙中的 a 值，甲中的 b 值必须大于乙中的 b 值。如果在二维数组中随意选择二元组，请问二元组最多可以往上摞几个? 例如:[[5,4],[6,4],[6,7],[2,3]], 最大数量可以摞 3 个，[2,3] =&gt; [5,4] =&gt; [6,7]要求:实现时间复杂度 O(N*logN)的解法 思路：将二维数组按a值升序排列，当a相等的时候，再按b值降序排列。之后将二维数组中的b值提取出来，按一维数组求最长子序列的解法进行求解。 注意： a相等时按b值降序排列是为了解决a值相等的冲突。 1234567891011121314151617181920212223242526272829303132333435363738public void maxPoint()&#123; Point[] points = &#123; new Point(3, 6), new Point(3, 5), new Point(3, 9), new Point(2, 8), new Point(4, 2),new Point(6, 10), new Point(5, 6), new Point(9, 12), new Point(8, 2), new Point(10, 8) &#125;; Arrays.sort(points, new PointComparator()); int arr[] = new int[points.length]; //System.out.println(Arrays.toString(points)); for (int i = 0; i &lt; points.length; i++) &#123; arr[i] = points[i].y; &#125; //调用上面介绍的一维数组求最长子序列函数 System.out.println(maxArr1(arr));&#125;//对象比较接口class PointComparator implements Comparator&lt;Point&gt;&#123; //按x大小排序，x相等时，按y值降序排列 @Override public int compare(Point o1, Point o2) &#123; if (o1.x &gt; o2.x) return 1; else if (o1.x == o2.x) &#123; if (o1.y &lt;= o2.y) return 1; else return -1; &#125; else &#123; return -1; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F04%2F17%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E6%B1%82%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[求素数判断一个数是否是素数只需判断2— $\sqrt{N}$ 中是否能被N整除即可 123456789101112131415public boolean isPrime(int num)&#123; boolean flag = true; int border = (int) Math.sqrt(num); for (int i = 2; i &lt;= border; i++) &#123; if (num % i == 0) &#123; flag = false; return flag; &#125; &#125; return flag;&#125; 找出小于N的所有素数埃氏素数筛选法其基本原理是每找到一个素数，将其倍数的数从素数表中删除，不断重复此过程，最终表中所剩数据全部为素数。下面的gif图片展示了该方法的相应步骤: 12345678910111213141516171819202122232425262728293031public class Prime&#123; public static void main(String[] args) &#123; int n = 101; boolean[] arr = new boolean[n]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = true; &#125; //下标即表示当前的数 arr[0] = arr[1] = false; int border = (int) Math.sqrt(n); for (int i = 2; i &lt;= border; i++) &#123; if (arr[i]==false) continue; //如果是素数，则其翻倍都不是素数 for (int j = i * i; j &lt; n; j += i) arr[j] = false; &#125; //打印小于N的所有素数 for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i]) System.out.println(i + " "); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[多线程的实现方式]]></title>
    <url>%2F2017%2F04%2F15%2Fjava%2Fblog%2FJava%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Thread.join()方法作用：也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。 继承Thread,实现run方法 12345678910111213141516171819202122public class ExtendThread extends Thread&#123; private int value; @Override public void run() &#123; // TODO Auto-generated method stub super.run(); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(hashCode() + " " + value); value++; &#125; &#125; public static void main(String[] args) &#123; ExtendThread main = new ExtendThread(); ExtendThread main2 = new ExtendThread(); main.start(); main2.start(); &#125;&#125; 实现Runnable接口 1234567891011121314151617181920public class ImplementRunnable implements Runnable&#123; private int value; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(hashCode() + " " + value); value++; &#125; &#125; public static void main(String[] args) &#123; ImplementRunnable runnable = new ImplementRunnable(); ImplementRunnable runnable2 = new ImplementRunnable(); new Thread(runnable).start(); new Thread(runnable2).start(); &#125;&#125; 通过Callable和FutureTask实现 FutureTask 继承自RunableFuture接口,RunableFuture继承了Runnable接口。即FutureTask间接继承了Runnable接口，FutureTask类中的run方法调用了Callable类中的call方法。 1234567891011121314151617181920212223public class CallAble implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(hashCode() + " " + i); &#125; return 111; &#125; public static void main(String[] args) &#123; CallAble callAble1 = new CallAble(); FutureTask&lt;Integer&gt;futureTask1 = new FutureTask&lt;&gt;(callAble1); new Thread(futureTask1).start(); CallAble callAble2 = new CallAble(); FutureTask&lt;Integer&gt;futureTask2 = new FutureTask&lt;&gt;(callAble2); new Thread(futureTask2).start(); &#125;&#125; Executor线程池 线程池可以预设容纳线程的个数，也可以动态分配。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Executor&#123; private static void run(ExecutorService threadPool) &#123; for (int i = 1; i &lt; 5; i++) &#123; final int taskID = i; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt; 5; i++) &#123; try &#123; Thread.sleep(20);// 为了测试出效果，让每次任务执行都需要一定时间 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("第" + taskID + "次任务的第" + i + "次执行"); &#125; &#125; &#125;); &#125; threadPool.shutdown();// 任务执行完毕，关闭线程池 &#125; public static void main(String[] args) &#123; // 创建可以容纳3个线程的线程池 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2); // 线程池的大小会根据执行的任务数动态分配 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); // 创建单个线程的线程池，如果当前线程在执行任务时突然中断，则会创建一个新的线程替代它继续执行任务 ExecutorService singleThreadPool = Executors.newSingleThreadExecutor(); // 效果类似于Timer定时器 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3); run(fixedThreadPool); //run(cachedThreadPool); // run(singleThreadPool); // run(scheduledThreadPool); &#125;&#125;]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F03%2F27%2Fjava%2Fnote%2Fstruts2%20%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[struts2 知识点Struts2工作流程 客户端创建一个指向servlet容器（Tomcat）的请求 这个请求会经过一系列的过滤器，如ActionContextCleanUp 接着会调用FilterDispatcher，FilterDispatcher询问ActionMapper是否要调用某个Action。FilterDispatcher是控制器的核心。 如果ActionMapper决定需要调用某个action，则FilterDispatcher就把请求的处理交给ActionProxy ActionProxy同ConfigurationManager询问框架的配置文件，一般是从Struts.xml配置文件中读取，找到需要调用的类。 ActionProxy创建一个ActionInvocation实例 ActionInvocation实例使用命名模式来调用，在调用Action过程中，会涉及到相关的拦截器的调用。 一旦Action执行完毕，ActionInvocation负责根据Struts.xml中的配置找到对应的返回结果，返回结果通常是jsp或者其他模板，但是也可能是指向其他Action的链。 相应返回的结果通过我们的web.xml配置中的过滤器 如果ActionContextCleanUp是当前使用的，则FilterDispatecher将不会清理sreadlocal ActionContext;如果ActionContextCleanUp不使用，则将会去清理sreadlocals。 Interceptor拦截器interceptor拦截器在容器启动时候完成初始化。注意：必须是Action引用了的interceptor才会被初始化，只定义但是Action没有引用的Interceptor是不会被初始化的。 拦截器的配置： 123456789101112131415161718192021&lt;package name="front" namespace="/" extends="struts-default,json-default"&gt; &lt;interceptors&gt; &lt;interceptor name="testInterceptor" class="com.hzm.bbs.interceptor.TestInterceptor"&gt;&lt;/interceptor&gt; &lt;interceptor name="loginInterceptor" class="com.hzm.bbs.interceptor.LoginInterceptor"&gt;&lt;/interceptor&gt; &lt;/interceptors&gt; &lt;action name="User_*" class="com.hzm.bbs.action.UserAction" method="&#123;1&#125;"&gt; &lt;result type="json"&gt; &lt;param name="root"&gt;jsonResult&lt;/param&gt; &lt;/result&gt; &lt;!-- 自定义拦截器 --&gt; &lt;interceptor-ref name="testInterceptor"&gt; &lt;!--拦截器中定义参数--&gt; &lt;param name="site"&gt;localhost:8080/test&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="loginInterceptor"&gt;&lt;/interceptor-ref&gt; &lt;!--注意，每一个action都有一个默认的拦截器，如果指定了自定义的拦截器，那么默认的拦截器就失去作用了，所以这里要再加上默认的拦截器--&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt;&lt;/package&gt; 拦截器在包package下面声明拦截器，在action的result标签下面引用。 Interceptor样例 12345678910111213141516171819202122232425262728293031323334353637383940package com.hzm.bbs.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;@SuppressWarnings("serial")public class LoginInterceptor implements Interceptor&#123; private String site;//拦截器中定义的参数 public String getSite() &#123; return site; &#125; public void setSite(String site) &#123; this.site = site; &#125; @Override public void destroy() &#123; System.out.println("LoginInterceptor destory!"); &#125; @Override public void init() &#123; //容器初始化的时候调用 System.out.println("LoginInterceptor init!"); System.out.println("site:" + getSite());//调用拦截器中定义的参数 &#125; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; // TODO Auto-generated method stub System.out.println("before Action!"); String reString=invocation.invoke();//要执行的action System.out.println("after Action!"); return reString; &#125;&#125; Filter过滤器在请求web.xml时，检测URL是否符合某个过滤器，当符合时会先执行过滤器器中的doFilter()方法，在doFilter()方法中可以对用户信息进行校验，或者对请求参数等进行修改校验等。 注意：过滤器是在拦截器之前执行，过滤器执行完毕后才进入拦截器中 在web.xml文件中配置过滤器 123456789&lt;!--自定义过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.hzm.bbs.interceptor.LoginFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 自定义Filter： 123456789101112131415161718192021222324252627282930313233343536373839package com.hzm.bbs.interceptor;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;public class LoginFilter implements Filter&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request2 = (HttpServletRequest) request; HttpSession session = request2.getSession(); //判断用户是否登录 if (session.getAttribute("user") == null) System.out.println("用户还未登录"); else //已登录则放行 chain.doFilter(request, response); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; chain.doFilter(request,response):作用是将请求转发给过滤器链上下一个对象,这里的下一个对象指的是下一个filter，如果没有filter那就是你请求的资源。 一般filter都是一个链,web.xml 里面配置了几个就有几个。一个一个的连在一起 request -&gt; filter1 -&gt; filter2 -&gt;filter3 -&gt; …. -&gt; request resource. 拦截器与过滤器的区别 拦截器是基于Java反射机制，而过滤器只是函数回调 拦截器只有在请求action的时候才会调用，而过滤器任何请求都可以调用 拦截器不依赖于servlet容器，而过滤器依赖于servlet容器 拦截器可以访问action上下文、值栈里的对象，而过滤器不能]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java内存管理]]></title>
    <url>%2F2017%2F03%2F22%2Fjava%2Fblog%2FJava%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java虚拟机在运行的过程中会把他管理的内存划分为不同的数据区域，每个区域都有自己用途，而且创建和销毁的时间都不同。主要包括以下几大块内容 程序计数器 ​ 程序计数器是一块比较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。Java虚拟机的多线程是通过为每个线程轮流分配处理器的时间片实现的，在任何时刻一个处理器（单核的）只能执行一条程序指令。因此为了线程切换后能回到原来的执行位置，每条线程都需要一个独立的线程计数器，每个线程之间的计数器互不影响。 虚拟机栈 ​ Java虚拟机栈也是线程私有的，它的生命中周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法执行的时候都会同时创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈道出栈的过程。 ​ 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 本地方法栈 本地方法栈和虚拟机栈很类似，区别就是虚拟机栈是为Java方法服务，而本地方法栈是为虚拟机使用的Native方法服务。 java 堆 ​ 对于大多数的应用来说，Java堆是Java虚拟机锁管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。所有对象和数组都要在堆上分配。 方法区 方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 ​ ​ JVM 配置： -Xms:初始堆的大小 默认：物理内存的1/64 -Xmx:最大堆的大小 默认：物理内存的1/4 -Xmn:新生代大小 默认：物理内存的1/64 -Xss :每个线程的堆栈大小 默认：1.5之后默认是1M 之前是256K -XX:PermSize: 永久代的大小 默认：物理内存1/64 -XX:MaxPermSize：永久代的最大值 默认：物理内存的1/4 -XX:SurvivorRadio：Eden和survivor的比例 默认：8：1]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java垃圾回收机制]]></title>
    <url>%2F2017%2F03%2F22%2Fjava%2Fblog%2FJava%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、如何确定对象已过期（垃圾） 引用计数法 当对象创建的时候就给对象创建一个对象引用计数器。每当有一个地方引用到这个对象的时候计数加1，当引用失效的时候计数器减1；任何时候只要计数器的值为0，则表明这个对象是不可能被使用的，即该对象已经过期，成为死亡对象。 缺点：无法解决循环引用的问题。 123456Object obj1 = new Object();Object obj2 = new Object();obj1 = obj2;obj2 = obj1;obj1=null;obj2=null; obj1和obj2最后都指向了null，说明这两个对象引用都失效了。但是由于obj1和obj2相互引用，两者的引用计数不为0，所以obj1和obj2不会被回收。 Java虚拟机中一般都没有使用这种方法来进行内存管理。 可达性分析 目前主流的编程语言(java,C#等)的主流实现中,都是称通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。如下图所示，对象object 5、object 6、object 7虽然互相有关联,但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象。 在Java语言中,可作为GC Roots的对象包括下面几种: 虚拟机栈(栈帧中的本地变量表)中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI(即一般说的Native方法)引用的对象。 二.被GC判断为”垃圾”的对象一定会回收吗即使在可达性分析算法中不可达的对象,也并非是“非死不可”的,这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收) 如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。 finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。 1234567891011121314151617181920212223242526272829303132333435363738public class FinalizeEscapeGC &#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() &#123; System.out.println("yes,i am still alive:)"); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("finalize mehtod executed!"); FinalizeEscapeGC.SAVE_HOOK = this; &#125; public static void main(String[] args) throws Throwable &#123; SAVE_HOOK = new FinalizeEscapeGC(); // 对象第一次成功拯救自己 SAVE_HOOK = null; System.gc(); // 因为finalize方法优先级很低,所以暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println("no,i am dead:("); &#125; // 下面这段代码与上面的完全相同,但是这次自救却失败了 SAVE_HOOK = null; System.gc(); // 因为finalize方法优先级很低,所以暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println("no,i am dead:("); &#125; &#125;&#125; finalize mehtod executed!yes,i am still alive:)no,i am dead:( SAVE_HOOK对象的finalize()方法确实被GC收集器触发过,并且在被收集前成功逃脱了。另外一个值得注意的地方是,代码中有两段完全一样的代码片段,执行结果却是一次逃脱成功,一次失败,这是因为任何一个对象的finalize()方法都只会被系统自动调用一次,如果对象面临下一次回收,它的finalize()方法不会被再次执行,因此第二段代码的自救行动失败了。因为finalize()方法已经被虚拟机调用过,虚拟机都视为“没有必要执行”。(即意味着直接回收) 三、典型垃圾回收算法 标记清除算法（Mark-sweep） 当堆中的有效内存耗尽时，就会停止整个系统，调用标记清除算法，主要是做两件事： 遍历所有GC Roots 把可达的对象标记为存活对象。 把未标记存货的对象清除 缺点： 效率相对比较低，造成stop-the-world时间过长 因为无用对象内存空间不是连续的，清除之后内存也不是连续的，容易造成内存碎片。 复制算法（copying）（一般适用于新生代GC） 复制算法是为了改进标记清除算法。将内存分为两块，每次只用其中的一块，在垃圾回收的时候，通过GCRoots标记存活对象，并将存活对象复制到另一块空间，同时将原先的内存空间全部清除。与上述算法相比，复制算法消除了内存碎片，提高了回收效率。 缺点 复制算法每次只用到了一块内存空间，造成了内存的浪费。尤其是在存活对象非常低的情况小，将内存分为两份，浪费很严重。 标记清除算法不适合存活对象较多的情况（如老年代） ​ 标记整理算法（Mark-Compact）(适用于老年代GC) 标记整理算法是考虑了标记清除算法效率低和复制算法内存空间浪费提出的改进算法。标记整理算法是在GC的时候，用GCRoots标记存活的对象，并将这些对象压缩到内存一段安装内存地址次序依次排序，使存活的对象在内存空间连续存放，然后末端的内存全部清除。 标记整理算法可以解决内存碎片和内存利用率问题，但是标记整理算法效率不高。 ​ Generational Collection（分代收集）算法 现在的Java虚拟机并不是只采用一种垃圾回收机制，而是采用分代收集算法。Java虚拟机将内存根据对象存活的周期划分为几块，一般是把堆内存分为新生代、老年代。短命对象放在新生代中，长命对象放在年老代中。对于不同的代，采用不同的收集算法： 新生代：存活对象较少，采用复制算法 老年代：存活对象较多，采用标记-清除算法 或者标记-整理算法 ​ 一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。 Eden：Survivor：Survivor=8：1：1；三块空间比例一般按8：1：1 ​ 在堆区之外（方法区）还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。 四、典型的垃圾收集器新生代收集器： Serial(串行GC)收集器 Serial收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是Jvm client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 ​ ParNew(并行GC)收集器 ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。 ​ Parallel Scavenge(并行回收GC)收集器 Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。 ​ 老年代收集器： Serial Old(串行GC)收集器 Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。 ​ Parallel Old(并行GC)收集器 Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 ​ CMS(Concurrent Mark Sweep，并发GC)收集器 CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。大致分为4步： ①.初始标记(CMS initial mark) ②.并发标记(CMS concurrenr mark) ③.重新标记(CMS remark) ④.并发清除(CMS concurrent sweep) 其中初始标记、重新标记这两个步骤任然需要停顿其他用户线程。初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快，并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记阶段要短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以整体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS收集器的优点：并发收集、低停顿，但是CMS还远远达不到完美，器主要有三个显著缺点： CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(CPU数量+3) / 4。 CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。这一部分垃圾称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分内存空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提供触发百分比，以降低内存回收次数提高性能。要是CMS运行期间预留的内存无法满足程序其他线程需要，就会出现“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的过高将会很容易导致“Concurrent Mode Failure”失败，性能反而降低。 最后一个缺点，CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full GC之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full GC之后，跟着来一次碎片整理过程。 收集新生代和老年代 G1收集器（Garbage First)） G1(Garbage First)收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。还有一个特点之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆(包括新生代，老年代)。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql优化策略]]></title>
    <url>%2F2017%2F03%2F16%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[尽量少用IN操作，基本上所有的IN操作都可以用Exists代替 不用Not IN操作，可以用Not Exists代替 不用“!=”、或者“&lt;&gt;”操作符，不等操作会造成全表扫面，可以用&gt;或者&lt;代替 尽量不使用IS NULL或者IS NOT NULL操作，数据表设计时，对索引列设置为NOT NULL，查找的时候就可以避免使用IS NULL操作 通配符“%”、“_”作为第一个字符时索引会失效，因此一般不要作为第一个字符出现 where子句中避免在索引列上使用计算，否则将导致索引失效而进行权标扫描 MySQL SQL基本原则 尽量少使用join 尽量少排序 尽量避免select* 尽量用join代替子查询 尽量少使用or 尽量用union all 代替union 尽早的过滤 避免类型转换 尽量优化高并发的sql，而不是执行频率低的某些”大“SQL 从全局出发优化，而不是片面调整]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F03%2F04%2Fjava%2Fnote%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1. 小知识点1.1 数字前加0表示八进制数，加0x表示16进制。1234567891011package com.object;public class StaticTest&#123; public static void main(String[] args) &#123; int a = 0123; int b=123; System.out.println(a+" "+b); &#125;&#125; 输入：83 123 1.2 Java类的成员函数名可以和构造函数名相同1234567891011public class TestConStructor&#123; public TestConStructor() &#123; System.out.println("constructor"); &#125; public void TestConStructor() &#123; System.out.println("not constructor"); &#125;&#125; 1.3 JVM 内存配置参数Xmx10240m：代表最大堆 -Xms10240m：代表最小堆 -Xmn5120m：代表新生代 -XXSurvivorRatio=3：代表Eden:Survivor = 3 根据Generation-Collection算法(目前大部分JVM采用的算法)，一般根据对象的生存周期将堆内存分为若干不同的区域，一般情况将新生代分为Eden ，两块Survivor； 计算Survivor大小， Eden:Survivor = 3，总大小为5120,3x+x+x=5120 x=1024 1.4 自动拆装箱的考题(自动拆装箱JDK需在1.5上） 基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true 基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。 12345678910int a=257;Integer b=257;Integer c=257;Integer b2=57;Integer c2=57;System.out.println(a==b);//System.out.println(a.equals(b)); 编译出错，基本型不能调用equals()System.out.println(b.equals(257.0));System.out.println(b==c);System.out.println(b2==c2); 因此上面的代码的结果因此为 true, false, false, true 2. Java的类成员访问权限 修饰词 本类 同一个包中的类 继承类 其他 private √ × × × 无修饰 √ √ × × protected √ √ √ × public √ √ √ √ 无修饰词的类成员具有”包访问权限”，即位于同一个包中的类可以访问。 protected 为“继承权限”，即该类的子类和位于同一个包中的类具有访问权限。 类的实例对象可以访问除了private 修饰的成员方法和变量 12345678910111213141516class Test&#123; private int c; int a; protected int b;&#125;public class StaticTest&#123; public static void main(String[] args) &#123; Test test = new Test(); System.out.println(test.a); System.out.println(test.b); System.out.println(test.c);//报错 &#125;&#125; 子类继承父类的方法是，控制符必须大于或等于父类的访问控制符 3. sleep与wait区别 sleep：sleep是正在执行的线程告诉CPU去执行其他线程，当过了sleep指定的时间后再回到这个线程继续执行。但是如果sleep加上了同步锁，它并不会释放同步锁。即使其他线程获得了CPU，但是被同步锁挡住也无法执行 wait：就是进入同步锁的线程，调用wait函数先释放同步锁供其他线程使用。当其他线程调用notify函数时，就告诉原先调用wait函数的线程可以参与获取同步锁的资源竞争了，但并不是马上得到锁，因为同步锁还在其他线程的手上，必须等那个占用锁的线程执行完毕，或者调用wait()函数才能获得同步锁。 4. Vector与ArrayList的区别Vector和arrayList都实现了List接口，是有序集合，集合内的数据元素都是有序的，可通过位置索引号取出相应的元素值。同时集合内的数据允许重复 区别： vector是线程同步的，也就是线程安全的。二ArrayList是线程不同步的，是线程不安全的。如果只有一个线程会访问到集合，那最好还是使用ArrayList，因为不考虑线程安全所以效率会更高。如果是多线程同时访问到集合，最好用Vector，因为不需要我们自己去考虑和编写线程安全代码。 vector和Hashtable是Java一诞生就提供的，他们是线程安全的。ArrayList和hashMap是Java2才提供的是线程不安全的。 数据增长，vector默认是增加2倍，也可以自己设置增长的空间大小。而arrayList默认是1.5倍增长，且没有提供设置增长空间的方法。 5. HashMap 与 HashTable的区别 历史原因:Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2引进的 Map接口的一个实现 同步性:Hashtable 是线程安全的，也就是说是同步的，而 HashMap 是线程序不安全的，不是同步的 值:只有 HashMap 可以让你将空值作为一个表的条目的 key 或 value Hashtable和HashMap类有三个重要的不同之处。第一个不同主要是历史原因。Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。 也许最重要的不同是Hashtable的方法是同步的，而HashMap的方法不是。这就意味着，虽然你可以不用采取任何特殊的行为就可以在一个多线程的应用程序中用一个Hashtable，但你必须同样地为一个HashMap提供外同步。一个方便的方法就是利用Collections类的静态的synchronizedMap()方法，它创建一个线程安全的Map对象，并把它作为一个封装的对象来返回。这个对象的方法可以让你同步访问潜在的HashMap。这么做的结果就是当你不需要同步时，你不能切断Hashtable中的同步（比如在一个单线程的应用程序中），而且同步增加了很多处理费用。 第三点不同是，只有HashMap可以让你将空值作为一个表的条目的key或value。HashMap中只有一条记录可以是一个空的key，但任意数量的条目可以是空的value。这就是说，如果在表中没有发现搜索键，或者如果发现了搜索键，但它是一个空的值，那么get()将返回null。如果有必要，用containKey()方法来区别这两种情况。 6. java 接口123456789package com.object;public interface Test&#123; void name1(); public void name2(); abstract void name3(); final static int a=0; static int b=0;&#125; 接口中方法默认修饰符 public abstract，默认的修饰符可以省略 接口中的变量 默认修饰符 public static final 默认的修饰符可以省略 接口不能再继承接口，一个类可以继承多个接口，但是只能继承一个类（包括抽象类） 7. String、StringBuffer、StringBuilderstring 是public final class String 无法继承。 三者执行的效率：String&lt;StringBuffer&lt;StringBuilder String：字符串常量 StringBuffer：字符串变量，线程安全的 StringBuilder：字符串变量，线程不安全 123String str1="abcd"+"efg"+"hijkl";//上面这句话其实等价于下面这个代码String str2="abcdefghijkl"; 12345String str2 = “This is only a”;String str3 = “ simple”;String str4 = “ test”;String str1 = str2 +str3 + str4;//这种方式Java虚拟机就会按原来的方式进行，故这种方式效率很低 8. 方法重写和重载方法重载（overload）： 必须是同一个类 方法名（也可以叫函数）一样 参数类型不一样或参数数量不一样 方法的重写（override）两同两小一大原则： 方法名相同，参数类型相同 子类返回类型小于等于父类方法返回类型， 子类抛出异常小于等于父类方法抛出异常， 子类访问权限大于等于父类方法访问权限。 9.volatile内存可见性：通俗来说就是，线程A对一个volatile变量的修改，对于其它线程来说是可见的，即线程每次获取volatile变量的值都是最新的。 10.staticJava静态内部类：static一般是不能修饰类的，只能修饰内部类。 一般情况下，如果一个内部类不是被定义成静态内部类，那么在定义成员变量或者成员方法的时候，是不能够被定义成静态成员变量与静态成员方法的。也就是说，在非静态内部类中不可以声明静态成员。 一般的非静态内部类，可以随意的访问外部类中的成员变量与成员方法。即使这些成员方法被修饰为private(私有的成员变量或者方法)，其非静态内部类都可以随意的访问。这是非静态内部类的特权。但是如果一个内部类被定义为静态的，那么在银用外部类的成员方法或则成员变量的时候，就会有诸多的限制。如不能够从静态内部类的对象中访问外部类的非静态成员(包括成员变量与成员方法)。如果在外部类中定义了两个变量，一个是非静态的变量，一个是静态的变量。那么在静态内部类中，无论在成员方法内部还是在其他地方，都只能够引用外部类中的静态的变量，而不能够访问非静态的变量。在静态内部类中，可以定义静态的方法(也只有在静态的内部类中可以定义静态的方法)，在静态方法中引用外部类的成员。但是无论在内部类的什么地方引用，有一个共同点，即都只能够引用外部类中的静态成员方法或者成员变量。对于那些非静态的成员变量与成员方法，在静态内部类中是无法访问的。 在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F03%2F03%2Fjava%2FJava%E6%BA%90%E7%A0%81%2FJava%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94Object%2F</url>
    <content type="text"><![CDATA[Java源码——ObjectObject类位于Java.lang核心包中，是所有类的祖先。Java.lang包含了Java最基础最核心的类，编译时会自动导入。 1.构造函数 Object()Java源码中并没有Object构造函数的定义，但其实Object类中其实应该是有这个构造函数的。Java中规定，若一个类没有声明构造函数，则系统会自动为其添加一个没有带参数的构造函数。 2.private static native void registerNatives();在Java中native修饰的方法表明该方法的实现并不在Java源码中，其实现是由C/C++完成。用native修饰，表示系统需要提供此方法供Java本身使用。 registerNatives()方法本身主要的作用是将C/C++中的方法映射到Java中的native方法中，实现方法名的解耦。 3.protected native Object clone() throws CloneNotSupportedException克隆方法，该方法返回一个一模一样的对象引用，但是返回的对象和原对象是两个不同的对象。Java术语表述:clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。 由于clone()函数是protected，因此只能被同一包中的类和子类访问。同时子类还必须实现了Cloneable接口。 Cloneable接口仅是一个表示接口，接口本身不包含任何方法，用来指示Object.clone()可以合法的被子类引用所调用。 12345678910111213141516171819package com.object;public class MainTest implements Cloneable&#123; public static void main(String[] args) &#123; MainTest mainTest = new MainTest(); try &#123; MainTest clone = (MainTest) mainTest.clone(); System.out.println(mainTest.toString()); System.out.println(clone.toString()); &#125; catch (CloneNotSupportedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 4.public final native Class&lt;?&gt; getClass();返回此Object对象的类对象（Class）/运行时对象。Class对象用于描述类的所有属性方法等信息。 5.public boolean equals(Object obj);==表示的是变量值完成相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址）； equals：equals表示的是对象的内容完全相同，此处的内容多指对象的特征/属性。 object中equals方法定义如下，即判断两个值是否相等： 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 在object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。但要注意，重新定义equals方法时，必须重新定义Hashcode方法。 6.public native int hashCode();Hashcode返回一个整形值，表示该对象的hash码值。 hashCode()具有如下约定： 1).在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致； 2).如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等； 3).反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。 Hashcode方法主要是增强hash表的性能。 以集合类中，以Set为例，当新加一个对象时，需要判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可。（注：Set的底层用的是Map的原理实现） 7.public String toString();toString放回对象的字符串表示。 123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; wait(……)/notify()/notifiyAll()wait()：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。 wait(long timeout)/wait(long timeout, int nanos)：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notisfy()/notisfyAll()方法，或超过指定的超时时间量。 notify()/notifyAll()：唤醒在此对象监视器上等待的单个线程/所有线程。 1、wait(…)方法调用后当前线程将立即阻塞，且适当其所持有的同步代码块中的锁，直到被唤醒或超时或打断后且重新获取到锁后才能继续执行； 2、notify()/notifyAll()方法调用后，其所在线程不会立即释放所持有的锁，直到其所在同步代码块中的代码执行完毕，此时释放锁，因此，如果其同步代码块后还有代码，其执行则依赖于JVM的线程调度。 13.protected void finalize();1protected void finalize() throws Throwable &#123; &#125; Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对形象所占用的内存空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是由我们主动去调用的（虽然可以主动去调用，此时与其他自定义方法无异）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库相关知识点]]></title>
    <url>%2F2017%2F02%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[数据库相关概念：​ 数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库数据具有永久存储、有组织和可共享三个基本特点。 候选码若关系中的某一属性组的值能唯一的标识一个元组，则该属性组成为候选码 主码若一个关系中有多个候选码，选其中一个作为主码。 主属性候选码的诸属性成为主属性 外码若F是基本关系R中的属性（不是R的码），K是基本关系S的主码，如果F和K相对应，则陈F是R的外码 完整性约束 实体完整性： 若属性A是基本关系R的主属性，则A取值不能为空。 参照完整性： 若F是基本关系R的外码，F与基本关系S中的K相对应，则其取值要么为空要么是基本关系S中的主码值 用户定义完整性： 关系数据库标准语言SQL模式创建与删除 创建模式 create schema test authorization wang 删除模式 drop schema test cascade|restrict cascade:级联删除（默认） restrict:限制删除，如果有数据的话不能删除 基本表的创建、删除、修改 创建表 1234567create table Student( Sno char(16) primary key , /* Sno 是主码*/ name char(32) unique, /* 姓名唯一*/ age smallint default 0, /*默认值是0*/ Cpno int, foreign key (Cpno) references Coures(Cno)/* 外键 */); 12345678create table SC( Sno char(16), Cno char(16) default null, grade smallint, primary key (Sno,Cno), /*sno和cno 两个属性作为主码*/ foreign key (Sno) references Student(Sno), foreign key (Cno) references course(Cno)) 12345678create table sc( sno char(16), cno char(16), grade smallint, primary key (sno,cno), foreign key (sno) references student(sno) on delete cascade on update cascade, foreign key (cno) references course(cno) on delete cascade on update cascade) 修改表属性 1alter table Student add sex char(2) /*添加字段*/ 1alter table Student drop sex /*删除字段*/ 1alter table Student modify sex int; /*字段sex修改为int 类型*/ 1alter table student change sex ses int;/*修改字段名称和类型*/ 删除表 1drop table se cascade;/*删除表*/ cascade：级联删除 restrict：限制删除 索引的创建于删除 创建索引 1create unique index Sname on Student (name); unique:唯一索引 cluster:聚簇索引 删除索引 1alter table student drop index Sname; 数据查询单表查询查询指定列1select Sno,name from student; /*查询某些属性列*/ 查询全部1select * from student; /*查询全部内容*/ 查询计算值1select name,2004-age from student; 消除重复的行1select distinct Sno from SC 查询满足条件的元组 比较大小(=、&gt; 、&lt;、&gt;=、&lt;=、!=、!&gt;不大于、!&lt;、不小于) 1select name from student where Sdept='CS';/*比较大小*/ 确定范围(between…… and……、not between…… and……) 1select name,age from student where age between 20 and 23; 确定集合 1select name,age from student where Sdept in ('CS','MA','IS'); 1select * from student where sdept not in ('CS','IS','MA'); 字符匹配like %：任意长度的字符串 1select * from student where name like '张%';/*查找名字是张的学生*/ ：代表任意单个字符(其中汉字占两个字符，需要两个 ) 1select * from student where name like '张_ _'；/*查询姓张的名字只有一个字的学生*/ /:转换字符，如果查询的字符中含有% 、_ 就需要用/进行转义 1select * from student where sdept like '*/_IS';/*查询sdept 以'_IS'结尾的元组 */ 空值查询 1select* from student where name is null; 多重条件查询(and |or) 1select* from student where age=22 and name like '张%'； order by 排序asc:查询结果升序排列（默认） desc:查询结果将序排列 1select* from student where age=22 order by name desc; 聚合函数distinct:表示去除重复的数据 all:表示全部数据，可以重复（默认） count(distinct|all *):统计元组个数 count(distinct|all 列名):统计一列中值得个数（即一列中为空值得个数） sum(distinct|all 列名)：计算一列中值得总和（该列只能是数值型） avg(distinct|all 列名)：计算一列的平均值（该列只能是数值型） max(distinct|all 列名)：求一列中的最大值 min(distinct|all 列名)：求一列中的最小值 1select count(distinct age)from student; 1select sum(distinct age)from student; group by查询结果分组，值相等的为一组1select Cno count(Sno) from Sc group by Cno;/*按Cno分组*/ 对分组进行筛选 1select Sno from SC group by Sno having count(*)&gt;3;/*查询选修3门课以上的学生学号*/ where：作用于基本表或试图，从中选中满足条件的元组 having：作用于组，从中选择满足条件的组。 连接查询等值与非等值连接查询=、&gt;、&lt;、&gt;=、&lt;=、!= 1select student.*,sc.*from student,sc where student.sno = sc.sno 自身连接查询先修课程cpno是指先修课 1select first.cno,second.cno from course first,course second where first.cpno=second.cno 外连接1select student.sno,student.name,sc.cno,sc.grade from student left outer join sc on(student.sno=sc.sno)；/*左外连接*/ 1select student.sno,student.name,sc.cno,sc.grade from student right outer join sc on(student.sno=sc.sno)；/*右外连接查询*/ 复合条件连接1select student.sno,student.name,sc.grade,course.cno,course.cname from student,sc,course where student.sno=sc.sno and sc.cno = course.cno; 嵌套查询不相关子查询：子查询条件不依赖于父查询，称为不相关子查询 相关子查询：子查询条件依赖于父查询，称为相关子查询 带有in谓词的查询123select student.* from student where sdept in ( select sdept from student where name="张三");/*查询和张三同一个系的学生*/ 带有比较运算符的子查询123456select sno,cno from sc xwhere grade&gt;(select avg(grade) from sc y where x.sno = y.sno );/*子查询一定要跟在比较符之后*/ 带有any|all谓词的子查询>any :大于子查询中的某个值 >all :大于子查询中的全部值 \&lt;any :小于子查询中的某个值 \&lt;all :小于子查询中的全部值 带有exists谓语的子查询带有exists谓语的子查询不返回任何数据，只产生逻辑真值true 或逻辑假值false 1234567select namefrom studentwhere exists( select * from sc /*子查询子产生true或false*/ where sno=student.sno and cno ='1');/*查询选了1号课程学生的姓名*/ 集合查询注意：参与集合操作的个查询结果列数必须相同，对应项的数据类型也必须相同，MySQL数据库中只有union union:并操作，默认是去掉重复数据，union all 保留重复数据 1234/*查询计算机系的学生或年纪不大于19岁的学生信息*/select * from student where sdept='cs'unionselect * from student where age&lt;='19'; 1234/*查询选了1号或2号课程的学生*/select sno from sc where cno ='1';unionselect sno rom sc where cno='2'; intersect:交集 1234/*查询选了1号和2号课程的学生*/select sno from sc where cno ='1';intersectselect sno from sc where cno='2'; except:差操作 1234/*查询计算机系的学生和年龄不大于19岁的学生的差集*/select * from student where sdept='cs'expectselect * from student where age&lt;='19'; 数据更新插入数据插入元组12insert into student (sno,name,age,sdept)values ('123','bob',12,'cs'); 若未指定任何属性名，则插入的元组必须在每个属性上均有值 12insert into student values ('345','nick',12,'in'); 插入子查询数据123/*插入每个系学生的平均年龄*/insert into sdept_age(dept,age)select sdept,avg(age) from student group by sdept; 修改数据修改一个元组的值123update studentset age =23where sno ='244'; 修改多个元组的值123/*所有学生年龄加1*/update studentset age =age+1; 删除数据1delete from student where sno ='123' 视图操作创建视图12345create view is_student asselect sno,name,age from student where sdept='is'; 1234567create view cs_student (cs_no,cs_name,cs_age)asselect sno,name,age from student where sdept='cs'with check option;/*表示以后对视图进行插入删除修改时，自动加上sdpet='cs'*/ with check option:表示对视图进行修改插入和删除时，要保证更新的行满足视图定义中的谓词条件.就是当对视图进行插入和修改时，操作后该数据还能满足视图查询条件。 删除视图1drop view is_student 数据库安全性授权与回收grant1234grant 权限1，权限2，……on 对象1，对象2，……to user1，user2,……with grant option 123grant selecton table studentto u1;/*给u1赋予查询student表的权限*/ 123grant all privilegeson table student，courseto user1,user2；/*赋予全部权限*/ 123grant selecton table student，courseto public;/*查询权限赋予所有人*/ 1234grant inserton table studentto user1with grant option;/*将插入权限赋予user1，并且user1还可以将这个权限赋予其他人*/ revoke123revoke 权限1，权限2……on 对象1，对象2……from user1，user2； 123revoke inserton table studentfrom user1 cascade;/*级联回收插入权限*/ 关系数据库理论规范化函数依赖定义：对于R(U)的任意一个可能的关系r,r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X—&gt;Y. X—&gt;Y,但Y不是X的子集，则称X—&gt;Y是非平凡的函数依赖。列如：（sno,cno）—&gt;grade X—&gt;Y,但Y是X的子集，则称X—&gt;Y是平凡的函数依赖。列如：（sno,cno）—&gt;sno 完全函数依赖如果X—&gt;Y,并且对于X的任意一个真子集X‘，都有Y不函数依赖于X’，则称Y对X是完全函数依赖。(sno,cno)—&gt;grade 若果X—&gt;Y,但是Y不完全依赖于X，则称Y对于X部分函数依赖。(sno,cno)—&gt;sdept，sno—&gt;sdept 传递函数依赖如果X—&gt;Y，X不函数依赖于Y，Y—&gt;Z,则称Z 对于X传递函数依赖。X—&gt;Y,Y—&gt;Z ==&gt; X—&gt;Z 范式1NF（第一范式）每一个分量必须是不可分的数据项。 2NF(第二范式)若R属于第一范式，且每一个非主属性完全函数依赖于码，则R属于2NF。即消除了部分函数依赖。 S-L-C(sno,sdept,sloc,cno,grade); sno:学号 sdept:所属院系 sloc:院系住的位置 cno:课程号 grade:成绩 (sno,cno)—&gt;grade :完全函数依赖 sno—&gt;sdept, (sno,cno)—&gt;sdept:部分函数依赖 sno—&gt;sloc,(sno,cno)—&gt;sloc:部分函数依赖。 拆分： SC（sno,cno,grade） SL（sno,sdept,sloc） 3NF(第三范式)关系模式R\ 中若不存在这样的码X，属性组Y，及非主属性Z，使得X–&gt;Y,Y—&gt;Z成立，则称R属于3NF。 即消除了部分函数依赖和传递依赖。 SL(sno,sdept,sloc)：每个院系学生住同一个位置 sno—&gt;sdept,sdept—&gt;sloc ==&gt; sno—&gt;sloc :属于传递函数依赖 拆分 SD(sno,sdept) SL(sdept,sloc) BCNF关系R属于第一范式，若X—&gt;Y且Y不属于X时，X必然含有码，则称R属于BCNF。 即每个决定因素都包含码。 数据库恢复技术事务定义：事务就是用户定义的数据库操作序列，这些操作要么全都做要么全都不做，是一个不可分割的工作单位 事务的特性 原子性：事务中的操作要么全都做要么全都不做 一致性：事务执行结果必须是使数据库从一个一致性状态变到另一个一致性状态 隔离性：一个事务的执行不能被其他事务干扰 持续性：一个事务一旦提交，他对数据库中的数据的改变就应该是永久性的。 ​ 并发控制数据不一致性 丢失修改 两个事务T1和T2读入同一个数据并修改，T2提交的结果破坏了T1提交的结果，导致了T1的修改丢失 不可重复读 指事务T1读取数据后，事务T2对数据执行了更新操作，使T1无法再现第一次读取的结果 读“脏”数据 指事务T1修改数据后并将其写回数据库，同时事务T2读出修改后的数据，但T1因为某些原因被撤销，这时候T1修改的数据恢复原先的值，这时T2读取的数据就和数据库中的数据不一致，则T2读到的数据就是“脏”数据，即不正确的数据。 R(X):表示读取数据 W(X):表示写入数据 T1 T2 T1 T2 T1 T2 R(A)=16 R(A)=50 R(B)=100 求和=150 R(C)=100 C=C*2 W(C)=200 R(A)=16 R(B)=100 B=B*2 W(B)=200 R(C)=200 A=A-1 W(A)=15 R(A)=50 R(B)=200 和=250 (验算不正确) ROLLBACK C恢复为100 A=A-1 W(A)=15 丢失修改 不可重复读 读脏数据 事务的隔离级别 Read uncommitted(未授权读取、读未提交) 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。 Read committed（授权读取、读提交） 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。 该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。 Repeatable read（可重复读取） 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 避免了不可重复读取和脏读，但是有时可能出现幻读。这可以通过“共享读锁”和“排他写锁”实现。 Serializable（序列化） 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。 序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 封锁排它锁（写锁）​ 若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他的任何事务都不能再对A加任何类型的锁，直到T 释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A 共享锁（读锁）​ 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能在对A加S锁，而不能加X锁，直到T释放A上的S锁，这就保证了其他事务可以读取A，但在T释放A上的S锁之前不能对A做任何修改。 活锁与死锁活锁​ 如果事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的请求后，系统又批准了T4的请求，这样有可能T2永远处于等待状态，这就是活锁。 ​ 避免活锁的方法就是采用先来先服务的策略。 死锁​ 如果事务T1封锁了数据R1，事务T2封锁了数据R2，然后事务T1又请求封锁数据R2，因为T2已经封锁了R2，所以T1等事务T2释放数据R2上的锁。接着T2又请求封锁数据R1，由于T1已经封锁了R1，所以T2又等T1释放R1上的锁。这样就出现了T1等待T2，而T2有等待T1的现象，T1和T2两个事务永远无法结束，形成死锁。 死锁的预防 一次封锁法 要求每个事务一次性将所有要使用的数据全部加锁，否则不能继续进行。 顺序封锁法 死锁的诊断和预防 超时法 如果事务的等待时间超过了规定的时限，就认为发生了死锁。 等待图法 若T1等待T2，则T1T2之间画一条有向边，从T1指向T2。如果发现图中存在回路，则表示系统中出现了死锁。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法]]></title>
    <url>%2F2017%2F01%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、冒泡排序3, 1, 8, -4, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, 8, -4, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, 8, -4, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 9, 20, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 9, 2, 20, 0, 12, 4, 7, 6 1, 3, -4, 8, 9, 2, 0,20, 12, 4, 7, 6 1, 3, -4, 8, 9, 2, 0, 12,20, 4, 7, 6 1, 3, -4, 8, 9, 2, 0, 12, 4,20, 7, 6 1, 3, -4, 8, 9, 2, 0, 12, 4, 7,20, 6 1, 3, -4, 8, 9, 2, 0, 12, 4, 7, 6,20 这是一趟比较，每次比较两个前后两个数，前面的大则向后移动 1234567891011121314151617public static void bubbleSort(int[] arr)&#123; int len = arr.length; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 2、插入排序方法一：从第二个元素开始，将元素arr[i]插入前面排好序的数组中。首先找到arr[i]在0——(i-1)这些元素中的位置j，然后将(j+1)到(i-1)中的元素往后移动一位，最后将arr[i]插入arr[j]中。 123456789101112131415161718public static void insertSort(int[] arr)&#123; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; int j = 0; //找到元素arr[i]要插入的位置j while (j &lt; i &amp;&amp; arr[j] &lt; arr[i]) j++; int temp = arr[i]; //将数组元素 j到 i-1 的元素向后移动一位 for (int n = i - 1; n &gt;= j; n--) arr[n + 1] = arr[n]; //将arr[i]元素插入位置j arr[j] = temp; &#125; System.out.println(Arrays.toString(arr));&#125; 方法二：从第二元素开始，将元素arr[i]插入前面已经排好序的序列中。定义下标j,j 从(i-1)出发，如果arr[j] 大于arr[i],则将arr[j]向后移动一位，否则跳出循环 12345678910111213141516public static void insertSort(int[] arr)&#123; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; int temp = arr[i]; int j = i - 1; //从i-1开始，把大于arr[i]的元素全部向后移动一位 while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + 1] = arr[j]; j--; &#125; arr[++j] = temp; &#125;&#125; 3. 希尔排序将数组分成dk个增量序列(i,i+dk*1,i+dk*2,i+dk*3,……i+dk*n)，将这dk个序列排序，每个增量序列中用插入排序方法将其进行排序。 12345678910111213141516171819202122232425262728public static void shellSort(int[] arr)&#123; int[] dk = &#123; 7, 5, 3, 1 &#125;; for (int i = 0; i &lt; dk.length; i++) &#123; if (dk[i] &lt; arr.length) shellInsert(arr, dk[i]); &#125;&#125;public static void shellInsert(int[] arr, int dk)&#123; //对dk个序列进行排序 for (int n = 0; n &lt; dk; n++) &#123; //对其中的一个序列进行插入排序 for (int i = dk + n; i &lt; arr.length; i += dk) &#123; int temp = arr[i]; int j = i - dk; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + dk] = arr[j]; j -= dk; &#125; arr[j + dk] = temp; &#125; &#125;&#125; 4. 简单选择排序假设数组长度为n，对数组进行n-1趟操作，每次在i到n元素中选择最小的元素与arr[i]进行交换 1234567891011121314151617181920public static void simpleSelectSort(int[] arr)&#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 从i到n中选择最小的元素 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) min = j; &#125; //如果最小元素下标不是i则进行交换 if (min != i) &#123; int temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 5. 快速排序1234567891011121314151617181920212223242526272829303132//递归方法public static void quickSort(int[] arr, int low, int high)&#123; if (low &lt; high) &#123; int index = partition(arr, low, high); quickSort(arr, low, index - 1); quickSort(arr, index + 1, high); &#125;&#125;public static int partition(int[] arr, int low, int high)&#123; //以第一个元素作为轴 int key = low; int value = arr[low]; while (low &lt; high) &#123; //从高位开始找第一个比key小的数 while (high &gt; low &amp;&amp; arr[high] &gt;= value) high--; //将高位第一个比key小的数与low位置交换 arr[low] = arr[high]; //从低位开始找第一个比key大的数 while (low &lt; high &amp;&amp; arr[low] &lt;= value) low++; //将低位第一个比key大的数与high位置交换 arr[high] = arr[low]; &#125; arr[low] = value; return low;&#125; 快速排序非递归方法1234567891011121314151617181920public static void quickSort1(int[] arr)&#123; LinkedList&lt;Integer&gt; lowQueue = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; highQueue = new LinkedList&lt;&gt;(); lowQueue.add(0); highQueue.add(arr.length - 1); while (!lowQueue.isEmpty()) &#123; int low = lowQueue.pop(); int high = highQueue.pop(); if (low &lt; high) &#123; int index = partition(arr, low, high); lowQueue.add(low); highQueue.add(index - 1); lowQueue.add(index + 1); highQueue.add(high); &#125; &#125;&#125; 6. 堆排序12345678910111213141516171819202122232425262728293031323334353637public static void heapAdjust(int[] arr, int s, int end)&#123; //以结点rc作为堆顶构造极大堆 int rc = arr[s]; for (int j = 2 * s + 1; j &lt;= end; j = j * 2 + 1) &#123; //判断两个叶子结点哪个大，j表示下标大的结点 if (j + 1 &lt;= end &amp;&amp; arr[j] &lt; arr[j + 1]) j++; //如果父节点大于两个叶子结点则直接跳出 if (rc &gt;= arr[j]) break; //将大的叶子结点上移到父节点 arr[s] = arr[j]; //接下来以j为父节点，构造极大堆 s = j; &#125; //初始结点要插入的位置 arr[s] = rc;&#125;public static void heapSort(int[] arr)&#123; int len = arr.length; // 构建极大堆 for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; //从最后一个非叶子结点开始一直往前，以这些非叶子结点构造极大堆 heapAdjust(arr, i, arr.length - 1); &#125; //将堆顶的最大元素放到队列尾部 for (int i = 0; i &lt; len; i++) &#123; int temp = arr[0]; arr[0] = arr[len - 1 - i]; arr[len - 1 - i] = temp; heapAdjust(arr, 0, len - i - 2); &#125;&#125; 7.2路 归并排序1234567891011121314151617181920212223242526272829303132333435363738public static void mergeSort(int[] arr, int start, int end) &#123; if (start &lt; end) &#123; int middle = (start + end) / 2; mergeSort(arr, start, middle); mergeSort(arr, middle + 1, end); merge(arr, start, middle, end); &#125; &#125; //合并两个有序的数组 数组1：start——middle 数组2：middle+1——end public static void merge(int[] arr, int start, int middle, int end) &#123; int low = start; int high = middle + 1; int[] tempArr = new int[end - start + 1]; int index = 0; while (low &lt;= middle &amp;&amp; high &lt;= end) &#123; //两个数组中较小的元素放入tempArr中 if (arr[low] &lt; arr[high]) tempArr[index] = arr[low++]; else tempArr[index] = arr[high++]; index++; &#125; //如果数组1中元素未放入完全，则将数组1剩余元素放入tempArr中 if (low &lt;= middle) for (; low &lt;= middle; low++, index++) tempArr[index] = arr[low]; else for (; high &lt;= end; high++, index++) tempArr[index] = arr[high]; //将两个排好序的数组元素放入 原先数组中 for (int i = 0; i &lt; tempArr.length; i++) arr[start + i] = tempArr[i]; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构知识点]]></title>
    <url>%2F2017%2F01%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[9.查找折半查找(已排好序)平均查找长度ASL=log2(n+1)-1 顺序表查找平均查找长度（n+1）/2 二叉排序树（二叉搜索树、二叉查找树） 若它的左子树不为空，则左子树上的所用结点的值都小于它的根节点的值 若它的又子数不为空，则又子树上的所有结点的值都大于他的根节点的值 他的左右子树也分别为二叉排序树。 按中序遍历二叉排序树得到的一定是一个递增序列。 平衡二叉树（AVL数）（查找时间复杂度O(logn)） 要么是空树 它的左子树和右子树都是平衡二叉树，且左子树和右 子树的深度之差的绝对值不超过1 平衡因子：该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上的所有结点的平衡因子只能是-1、1、0 B-树主要用作文件的索引 一棵 m 阶的B-树，或为空树，或为满足下列特性的m叉树： 所有非叶结点均至少含有⎡m/2⎤棵子树，至多含有 m 棵子树； 根结点或为叶子结点，或至少含有两棵子树； 所有非终端结点含有下列信息数据： （n，A0，K1，A1，K2，A2，…Kn，An） 其中：K**i为关键字，且均自小至大有序排列，即：K1&lt; K2&lt; … &lt; Kn ； Ai为指向子树根结点的指针，且指针Ai-1所指子树上所有关键字均小于Ki ； An 所指子树上所有关键字均大于Kn ； 树中所有叶子结点均不带信息，且在树中的同一层次上； B+树适用于文件系统，适合顺序查找和随机查找。 哈希表处理冲突的方法 开放地址法 Hi=(H(key)+di)mod m 线性探测再散列：di=1,2,3,4…… 二次探测再散列：di=1^2,-1^2,2^2,-2^2 …… 伪随机探测在散列：di=伪随机数 再哈希法 链接地址法 建立一个公共溢出区 10.排序 插入排序12345678910void InsertionSort ( SqList &amp;L ) &#123; // 对顺序表 L 作直接插入排序。 for ( i=2; i&lt;=L.length; ++i ) if (L.r[i].key &lt; L.r[i-1].key) &#123; L.r[0] = L.r[i]; // 复制为监视哨 for ( j=i-1; L.r[0].key &lt; L.r[j].key; -- j ) L.r[j+1] = L.r[j]; // 记录后移 L.r[j+1] = L.r[0]; // 插入到正确位置 &#125;&#125; // InsertSort 希尔排序 1234567891011121314151617void ShellInsert ( SqList &amp;L, int dk ) &#123;//对顺序表L作一//趟希尔插入排序，dk 为增量 for ( i=dk+1; i&lt;=n; ++i ) if ( L.r[i].key&lt; L.r[i-dk].key) &#123; L.r[0] = L.r[i]; // 暂存在L.r[0] for (j=i-dk; j&gt;0&amp;&amp;(L.r[0].key&lt;L.r[j].key); j-=dk) L.r[j+dk] = L.r[j]; // 记录后移，查找插入位置 L.r[j+dk] = L.r[0]; // 插入 &#125; // if&#125; // ShellInsertvoid ShellSort (SqList &amp;L, int dlta[], int t)&#123; // 按增量序列dlta[0..t-1]对顺序表L作希尔排序 for (k=0; k&lt;t; ++t) ShellInsert(L, dlta[k]); //一趟增量为dlta[k]的插入排序&#125; // ShellSort 堆排序堆： 根都大于等于左右子树 或者 根都小于等于左右子树 ki&lt;=K(2i) and Ki&lt;=K(2i+1) ===&gt;小顶堆 ki&gt;=K(2i) and Ki&gt;=K(2i+1) ===&gt;大顶堆 ​ 样例输入：{49，38，65，97，76，13，27，49} ​ 创建初始堆 ​ 输出堆顶后创建新堆的过程 6.树和二叉树定义结点:数据元素及若干指向其子树的分支 结点的度:结点拥有的子树的数目 树的度:树中所有结点的度的最大值 叶子结点:度为零的结点 分支结点:度不为零的结点 孩子：结点子树的根节点称为该节点的孩子结点 双亲：该节点称为子树孩子的双亲 双亲：同一个双亲的孩子之间称为兄弟 祖先：从根节点到该节点所经分支上的所有结点 层次：从根开始定义，根为第一层，根的孩子为第二层 堂兄弟：其双亲在同一层的结点互为堂兄弟 树的深度：树中结点的最大层次称为树的深度或高度 二叉树定义：二叉树或为空树，或是由一个根结点加上两棵分别称为左子树和右子树的、互不交的二叉树组成。 二叉树的性质 在二叉树的第i层上最多有2^(i-1)个结点 深度为k的二叉树上最多含2^k - 1个结点 对任何一棵二叉树，若它含有n0 个叶子结点、n2 个度为 2的结点，则必存在关系式：n0 = n2+1。 二叉树的度数+1=二叉树的结点树 满二叉树：指的是深度为k且含有2^k-1个结点的二叉树。 完全二叉树：树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应。 ​ 完全二叉树 ​ 满二叉树 二叉树遍历 先根遍历：根左右 中序遍历：左根右 后续遍历：左右根 已知先序遍历和中序遍历可求出后序遍历，已知后序遍历和中序遍历可求出先序遍历 已知先序遍历和后序遍历不能求出先序遍历 二叉树遍历算法12345678910111213Status PreOrderTraverse( BiTreee T, Status ( * Visit)(TElemType e) ) &#123; //采用二叉链表存储结构， Visit是对数据元素操作的应用//函数，先序遍历二叉树T的递归算法，对每个数据元素调用//函数Visit。最简单的Visit函数是： // Status PrintElement(TElemType e)&#123; //输出元素e的值 // printf( e ); //实用时，加上格式串 // return OK; // &#125; //调用实例： PreOrderTraverse( T, PrintElement);if (T) &#123; if (Visit(T-&gt;data )) if (PreOrderTraverse(T-&gt;lchild, Visit)) if (PreOrderTraverse(T-&gt;rchild, Visit)) return OK; return ERROR; &#125;else return OK;&#125;// PreOrderTraverse 统计叶子结点个数12345678void CountLeaf (BiTree T, int&amp; count)&#123; if ( T ) &#123; if ((!T-&gt;lchild)&amp;&amp; (!T-&gt;rchild)) count++; // 对叶子结点计数 CountLeaf( T-&gt;lchild, count); CountLeaf( T-&gt;rchild, count); &#125; // if&#125; // CountLeaf 计算二叉树的深度12345678910int Depth (BiTree T )&#123; // 返回二叉树的深度 if ( !T ) depthval = 0; else &#123; depthLeft = Depth( T-&gt;lchild ); depthRight= Depth( T-&gt;rchild ); depthval = 1 + (depthLeft &gt; depthRight ? depthLeft : depthRight); &#125; return depthval;&#125; 表达式与二叉树之间的关系 线索二叉树定义：线索二叉树就是在二叉树链表结构中添加两个标志位，LTag、RTag. LTag=0时，Lchild指针指向其左孩子，LTag=1时，Lchild指针指向其前驱 RTag=0时，Rchild指针指向其右孩子 RTag=1时，Rchild指针指向其后继 线索化：以某种次序遍历使其变为线索二叉树的过程称为线索话。 树和森林树的存储结构孩子兄弟表示法：以二叉链表作为树的存储结构，链表中的两个链域分别指向该节点的第一个孩子结点和下一个兄弟结点。 森林和二叉树的转化 ​ 森林和二叉树转换采用孩子兄弟表示法，每棵树的根节点看作是兄弟。 ​ 二叉树转换成森林，从根节点出发，每个右结点分支断开，即做分支变成树。即AE之间断开，EG之间断开 哈夫曼树（最优二叉树）定义路径长度：从树中的一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称为路径长度。 树的路径长度：是指从树的根到每一个结点的路径长度之和。 结点的带权路径长度：是该结点到树根之间的路径长度与结点上权的乘积。 树的带权路径长度：是树中所有叶子结点的带权路径长度之和 哈夫曼树：带权路径长度最小的二叉树称为哈夫曼树 ​ 带权路径介绍 构造哈夫曼树 结点带权值和编号集合依次排开，选取权值最小的两个结点构造一颗二叉树，根节点为两个结点权值之和。两个结点分别为左右子树，并且子树权值大于右子树权值或者相反，但是每次得保持一致。 将上面两个结点和放入集合中，并且将两个结点从集合中移除。 重复第一个步骤。当集合中只剩一个结点时结束。 7、图定义图：图是由一个顶点集 V 和一个弧集 R构成的数据结构 \表示从 v 到 w 的一条弧，并称 v 为弧尾，w 为弧头。 假设图中有 n 个顶点，e 条边，则 含有 e=n(n-1)/2 条边的无向图称作完全图； 含有 e=n(n-1) 条弧的有向图称作 有向完全图； 若边或弧的个数 e&lt;nlogn，则称作稀疏图，否则称作稠密图。 假若顶点v 和顶点w 之间存在一条边，则称顶点v 和w 互为邻接点， 边(v,w)** 和顶点v 和w 相关联**。 度：和顶点v 关联的边的数目定义为顶点v的度。 有向图中： 顶点的出度：以顶点v为弧尾的弧的数目； 顶点的入度：以顶点v为弧头的弧的数目。 顶点的度(TD)=出度(OD)+入度(ID)。 路径长度：路径长度是指路径上的边或弧的数目 回路或环：第一个顶点和最后一个顶点相同的路径称为环或回路 简单路劲：序列顶点不重复出现的路径称为简单路径 简单环或简单回路：除了第一个和最后一个顶点外，其余的顶点不重复出现的回路称为简单回路或简单环 无向图中 连通图：对于图中的任意两个顶点都是连通的，称这个图是连通图 连通分量：无向图中的极大连通子图 有向图中 强连通图 ：对于图中每一对顶点vi和vj,从vi到vj和从vj到vi都存在路径，则称图是强连通图 强连通分量：有向图中的极大强连通子图 图的存储数组表示法（邻接矩阵法） 无向图的邻接矩阵一定是对称矩阵，而有向图的邻接矩阵则不一定为非对称矩阵 . 邻接表 ​ 无向图的邻接矩阵 ​ 有向图的邻接矩阵 图的遍历深度优先搜索​ 从图中某个顶点V0 出发，访问此顶点，然后依次从V0的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和V0有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直到图中所有顶点都被访问到为止。 ​ 访问次序：v1—&gt;v2—&gt;v4—&gt;v8—&gt;v5—&gt;v3—&gt;v6—&gt;v7 深度优先算法：定义一个数组存放顶点是否被访问 12345678910111213141516void DFSTraverse(Graph G, Status (*Visit)(int v)) &#123; // 对图 G 作深度优先遍历。 VisitFunc = Visit; for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; // 访问标志数组初始化 for (v=0; v&lt;G.vexnum; ++v) if (!visited[v]) DFS(G, v); // 对尚未访问的顶点调用DFS&#125;void DFS(Graph G, int v) &#123; // 从顶点v出发，深度优先遍历图 G visited[v] = TRUE; VisitFunc(v);//访问第v个顶点 for(w=FirstAdjVex(G, v); w&gt;=0; w=NextAdjVex(G,v,w)) if (!visited[w]) DFS(G, w); // 对v的尚未访问的邻接顶点w， 递归调用DFS&#125; // DFS 广度优先搜索遍历类似于树的层次遍历 从图中的某个顶点V0出发，并在访问此顶点之后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访到。 若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 ​ 广度优先搜索：V1—&gt;V2—&gt;V3—&gt;V4—&gt;V5—&gt;V6—&gt;V7—&gt;V8. 123456789101112131415161718192021222324void BFSTraverse(Graph G, Status (*Visit)(int v))&#123; //按广度优先非递归遍历图G，使用辅助队列Q和//访问标志数组visited for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; //初始化访问标志 InitQueue(Q); // 置空的辅助队列Q for ( v=0; v&lt;G.vexnum; ++v ) if ( !visited[v]) // v 尚未访问 &#123; visited[v] = TRUE; Visit(v); // 访问v EnQueue(Q, v); // v入队列 while (!QueueEmpty(Q)) &#123; DeQueue(Q, u); // 队头元素出队并置为u for(w=FirstAdjVex(G, u); w&gt;=0;w=NextAdjVex(G,u,w)) if ( ! visited[w]) &#123; //W为u的尚未访问的邻接顶点 visited[w]=TRUE; Visit(w); EnQueue(Q, w); // 访问的顶点w入队列 &#125; // if &#125; // while &#125; &#125; // BFSTraverse 最小生成树最小生成树：构造网的一棵最小生成树，即：在 e 条带权的边中选取 n-1 条边（不构成回路），使“权值之和”为最小 普里姆算法取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n-1 条边为止。 算法的时间复杂度是O(n^2),与网中的边数无关，因此适合求边稠密的网的最小生成树 克鲁斯卡算法先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止。 算法的时间复杂度O(eloge),e为边的数目，适用于稀疏图。 有向无环图的应用有向无环图：一个无环的有向图称为有向无环图。简称（DAG） 拓扑排序定义：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序 所谓偏序关系就是如果A–&gt;B成立 ， 但是从B–&gt;A 不成立 从有向图中选取一个没有前驱的顶点，并输出之； 从有向图中删去此顶点以及所有以它为尾的弧； 重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。后一种情况说明有向图中存在环。 关键路径路径长度最长的路径就是关键路径。 最早发生时间：从v1到vi的最长路径长度叫做事件vi的最早发生时间 最迟发生时间：在不推迟项目进度的情况下，最晚发生的时间。 关键活动：最早发生时间和最迟发生时间相同的活动叫做关键活动。 关键路径上的活动都是关键活动 最短路径从某个顶点到其余各个顶点的最短路径。（迪杰斯特拉算法）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>排序</tag>
        <tag>二叉树</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2016%2F11%2F20%2Fjava%2Fnote%2FEffective%20Java%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Effective Java 阅读笔记第一条：用静态工厂方法代替构造器1234public static Book getNewInstance()&#123; return new Book();&#125; 第二条：遇到多个构造器参数时要考虑用构造器 调用方法： 1NutritionFacts cocaCola = new NutritionFacts.Builder(240,8).calories(100).sodium(35).carbohydrate(27).build(); 第三条：用私有构造器或者枚举类型强化singleton属性12345public class Elvis&#123; public static final Elvis INSTANCE = new Elvis(); private Elivs()&#123;&#125;&#125; 保证了Elvis对象的唯一性，一旦被实力化只能存在一个Elvis对象。 123456789public class Elvis&#123; private static final Elvis INSTANCE = new Elvis(); private Elivs()&#123;&#125; public static Elvis getInstance() &#123; return INSTANCE; &#125;&#125; 第四条：通过私有构造器强化不可实例化的能力12345public class UtiltyClass&#123; private UtiltyClass()&#123;&#125; public static void methods()&#123;……&#125;&#125; 工具类一般不能实例化，所以将构造器私有化，防止 用户实例化工具类。 第五条：避免创建不必要的对象1String s = new String("i am a boy!"); “i am a boy!”本身就是一个String对象，这相当于创建了两个String对象。尤其注意基本类型的自动装箱和拆箱功能。 1234/*错误做法Long num = 10000L; */long num = 1000L; 第六条：消除过期对象的引用 stack 弹出数据之后及时置空。 一但元素被释放，则该元素包含的任何对象引用都应该被清空。 第七条：避免使用终结方法第八条：覆盖equals时请遵守通用的约定 自反性：对于任何非null得引用值x,x.equals(x)必须返回true 对称性：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true 传递性：x.equals(y)=true y.equals(z)=true ——&gt; x.equals(z)=true 一致性：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)必须始终返回true或false。 第九条：覆盖equals时总要覆盖hashCode​ 每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话就会违反Object，hashCode的通用约定。 ​ 约定内容如下： ​ hashCode计算应该把每个equals比较的域都考虑进去，但是如果一个域值可以根据另一个域值推到出来则可以将其中一个域值排除。 ​ 其中一种计算方法如下： 123456789@overridepublic int hashCode()&#123; int result =17; result = 31*result + areaCode; result = 31*result + prefix; result = 31*result + lineNumber; return result;&#125; 第十条：始终要覆盖toString方法第十一条：谨慎的覆盖clone方法]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2016%2F11%2F10%2Fjava%2FJava%E6%BA%90%E7%A0%81%2FJava%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94hashcode%2F</url>
    <content type="text"><![CDATA[Java源码——hashcode​ Java中的hashcode()方法返回的是该对象的hash值，一个对象每次调用hashCode()方法时返回的值都是相同的。 ​ 如果两个对象通过equals（Object o）比较相等，那么 这两个对象的hashCode()方法返回的值也是相等的 ；反过来如果两个对象的hashcode()值相等，但是这个对象调用equals()方法却不一定是相等的。 ​ Set类中可以把每个hashCode与一个容器相对应，同时每个容器可以存放多个对象。由于Set的特性是存放不同的对象，而且是无序的。当添加对象时，通过对象的hashcode查找 相应的容器，然后再与这个容器中的每个对象比较，如果相同则不存放，不相同则放入该容器中。这样做的好处是不用和Set中的每个容器进行比较，极大的提高了效率。 12345678910111213141516171819public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2016%2F11%2F08%2Fjava%2FJava%E6%BA%90%E7%A0%81%2FJava%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94LinkedList%2F</url>
    <content type="text"><![CDATA[Java源码——LinkedListpublic class LinkedListextends AbstractSequentialList ​ implements List, Deque, Cloneable, java.io.Serializable LinkedList是非线程安全的 12345678910111213private static class Node&lt;E&gt;&#123; //结点信息 E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; public E getFirst() //获取第一个元素1234567public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125; public E getLast() //获取最后一个元素1234567public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; public E removeFirst()//移除第一个元素1234567public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125; 12345678910111213141516171819private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; //next指向第二个元素 final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC //指针first指向第二个元素 first = next; //如果第二个元素为空则List变为空，first和last都指向null;否则first-&gt;pre指向空 if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125; public E removeLast()//移除List最后一个元素123456public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125; 12345678910111213141516171819private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; //pre指向倒数第二个元素 final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC //为指针向前移动一位 last = prev; //如果倒数第二个元素为空则List变为空，first和last都指向null;否则last-&gt;next指向空 if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125; public void addFirst(E e)//将元素添加到List队首123public void addFirst(E e) &#123; linkFirst(e); &#125; 123456789101112131415private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; //新节点的前驱指向空，后继指向first final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //队首指针指向新建的结点 first = newNode; //如果原先的队首为空，此时List为空，新添加的Node既是头结点也是尾结点；否则原头结点的前驱指向新 建结点 if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125; public void addLast(E e) //将元素e添加到队尾123public void addLast(E e) &#123; linkLast(e); &#125; 1234567891011121314void linkLast(E e) &#123; final Node&lt;E&gt; l = last; //新节点的前驱指last，后继指向空 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //last指针后移，指向新建的结点 last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; public boolean contains(Object o) //判断list是否包含元素o123public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; 123456789101112131415161718public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; public boolean remove(Object o)//移除元素123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) //添加多个元素123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; //尾部添加 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; //中间插入 succ = node(index); pred = succ.prev; &#125; //元素加入链表中 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; //新建结点的前驱指向pred Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //若前驱为空，则新建的结点就是头结点 if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; 12345678910111213141516//返回位置为index的元素Node&lt;E&gt; node(int index)&#123; //判断index离头结点还是尾结点更近 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2016%2F11%2F08%2Fjava%2FJava%E6%BA%90%E7%A0%81%2FJava%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94List%2F</url>
    <content type="text"><![CDATA[Java源码——Listpublic interface List extends Collection 接口 List 方法区： int size();12//获取List的长度int size(); boolean isEmpty();12//判断数组是否为空boolean isEmpty(); boolean contains(Object o);12//判断容器中是否存在这个元素boolean contains(Object o); Iterator iterator();12//返回List的迭代Iterator&lt;E&gt; iterator(); Object[] toArray();12//List转化为Object数组Object[] toArray(); T[] toArray(T[] a);12//将List中的元素转换成T[]数组返回&lt;T&gt; T[] toArray(T[] a); boolean add(E e);12//添加元素boolean add(E e); boolean remove(Object o);12//移除元素boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c);12//判断是否包含C中的所有元素boolean containsAll(Collection&lt;?&gt; c); boolean addAll(int index, Collection&lt;? extends E&gt; c);12//在List数组index位置中添加C中的所有元素boolean addAll(int index, Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c);12//移除List中所有在C中出现的元素boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c);12//移除List中所有没有在C中出现的元素boolean retainAll(Collection&lt;?&gt; c); void clear();12//清空数组void clear(); boolean equals(Object o);12//判断List是否和Object相等boolean equals(Object o); int hashCode();12//放回List的hashCodeint hashCode(); E get(int index);12//获取List中下标为index的元素E get(int index); E set(int index, E element);12//将元素element插入List的index位置中E set(int index, E element); E remove(int index);12//移除List中index位置的元素E remove(int index); int indexOf(Object o);12//获取元素o在List中第一次出现的位置int indexOf(Object o); int lastIndexOf(Object o);12//获取元素o在List中最后一次出现的位置int lastIndexOf(Object o); ListIterator listIterator();12//返回List的List迭代 ListIterator&lt;E&gt; listIterator(); ListIterator listIterator(int index);12//返回List数组从index开始的list迭代ListIterator&lt;E&gt; listIterator(int index); List subList(int fromIndex, int toIndex);12//保留list中位置从fromIndex到toIndex的元素List&lt;E&gt; subList(int fromIndex, int toIndex);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2016%2F11%2F07%2Fjava%2FJava%E6%BA%90%E7%A0%81%2FJava%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94Stack%2F</url>
    <content type="text"><![CDATA[Java源码——StackStack 线程安全的。先进后出机制， Stack extends Vector{} Stack 继承至vector public E push(E item) 入栈123456//添加元素public E push(E item) &#123; addElement(item); return item;&#125; 12345678//Vectorpublic synchronized void addElement(E obj) &#123; //数组修改次数 modCount++; //elementCount 数组元素的个数 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; ​ synchronized 给该方法区加上同步锁，两个线程同时执行该代码块时，只有一个线程可以执行该代码块，另一个线程必须等待前一个线程执行完成之后才能执行。 1234567//Vectorprivate void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 12345678910111213//Vectorprivate void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; ​ capacityIncrement 如果为0，则stack的容量成倍增长newCapacity = oldCapacity + oldCapacity ；否则newCapacity = oldCapacity + capacityIncrement public synchronized E pop() 出栈12345678910public synchronized E pop() &#123; E obj; int len = size(); //取出栈顶元素 obj = peek(); //移除栈顶元素 removeElementAt(len - 1); return obj;&#125; 12345678//获取栈顶元素 但不移除栈顶元素public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1);&#125; 12345678910111213141516171819//Vectorpublic synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; //将index以后的元素整体往前移一位 System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */&#125; public boolean empty() 判断元素是否为空123public boolean empty() &#123; return size() == 0; &#125; public synchronized int search(Object o) 元素搜索12345678public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1;&#125; 12345//Vectorpublic synchronized int lastIndexOf(Object o) &#123; return lastIndexOf(o, elementCount-1);&#125; 1234567891011121314151617//Vectorpublic synchronized int lastIndexOf(Object o, int index) &#123; if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + " &gt;= "+ elementCount); if (o == null) &#123; for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2016%2F11%2F05%2Fjava%2FJava%E6%BA%90%E7%A0%81%2FJava%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94arrayList%2F</url>
    <content type="text"><![CDATA[Java知识点——arrayListarrayList 非线程安全的 add(E e) 扩容机制1234567 public boolean add(E e) &#123; //确保数组容量充足 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 12345678private void ensureCapacityInternal(int minCapacity)&#123; //原数组为空 if (elementData == EMPTY_ELEMENTDATA) &#123; //DEFAULT_CAPACITY=10 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 原数组为空minCapacity=10，若不为空则minCapacity=size+1； 12345678private void ensureExplicitCapacity(int minCapacity) &#123; //数组被操作的次数 modCount++; // 如果最小容量大于数组的长度 则进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) 新的数组大小是原数组大小的1.5倍。若新数组大小小于minCapacity，新数组大小就等于minCapacity 12345678private static int hugeCapacity(int minCapacity)&#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 若数组大小超过int的最大值则抛出异常 add(int index, E element) 插入元素123456789101112public void add(int index, E element) &#123; //检查index是否越界 rangeCheckForAdd(index); //确保数组大小足够 ensureCapacityInternal(size + 1); // Increments modCount!! //将数组从index到数组结尾的元素向后移一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; remove(int index) 移除元素1234567891011121314151617public E remove(int index) &#123; //检查元素是否越界 rangeCheck(index); //数组被操作的次数 modCount++; E oldValue = elementData(index); //要移动元素的个数 int numMoved = size - index - 1; if (numMoved &gt; 0) //将数组index+1到最后的元素前移一位 System.arraycopy(elementData, index+1, elementData, index, numMoved); //元素最后一位置空 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2016%2F10%2F25%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2Fmac%2Beclipse%2Bgradle%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Mac系统中eclipse 配置gradle一、gradle 简介​ Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。(项目自动化构建工具，摘自百度百科) 二、Mac系统下安装gradle 首先从网上下载最新的gradle( gradle下载地址 )，我这边下载的3.1版本。 安装gradle。Mac系统下载好gradle解压，将解压出来的gradle文件夹拷贝到你想安装gradle的路径下即可。 配置gradle的环境变量。输入下面命令： sudo vim ~/.bash_profile 输入mac的密码 编辑配置文件（在最下面添加即可），将/Users/huzhiming/workspace/gradle-3.1路径替换成你自己的gradle路径即可 export GRADLE_HOME=/Users/huzhiming/workspace/gradle-3.1 export PATH=$GRADLE_HOME/bin:$PATH 保存配置文件后， source ~/.bash_profile 使配置文件立即生效。 检测gradle是否安装配置成功。打开命令行，输入： gradle -v 输入回车之后显示如上图所示，则表明gradle安装配置成功。 三、eclipse安装buildship插件 打开eclipse，选择 help-&gt;Eclipse MarketPlace，在搜索栏中输入BuildShip，可以搜索到如下结果。 选择第一个安装即可，由于我的已经安装过了所以显示installed。一直点下一步即可。安装完成之后重启eclipse。 四、创建gradle项目 eclipse中buildship插件安装完成重启后，选择新建项目，创建gradle项目 一直下一步，直到选择gradle安装路径，这里选择你安装的gradle路径即可。 项目创建完成后，项目结构如下图所示 1)src/main/java：里面是主要的Java代码 2)src/test/java：这是junit等测试代码 接下来就是配置build.gradle文件了。 123456789101112131415161718192021// Apply the java plugin to add support for Javaapply plugin: 'java'// In this section you declare where to find the dependencies of your projectrepositories &#123; // Use 'jcenter' for resolving your dependencies. // You can declare any Maven/Ivy/file repository here. jcenter()&#125;// In this section you declare the dependencies for your production and test codedependencies &#123; // The production code uses the SLF4J logging API at compile time compile 'org.slf4j:slf4j-api:1.7.21' // Declare the dependency for your favourite test framework you want to use in your tests. // TestNG is also supported by the Gradle Test task. Just change the // testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add // 'test.useTestNG()' to your build script. testCompile 'junit:junit:4.12'&#125; apply plugin : ‘java’:指定项目为java项目，项目编译(在项目提示符下执行：gradle build)时生成项目的jar包。 repositories: 指定仓库使用。 dependencies: 项目依赖定义，compile为编译级别依赖，还有testCompile为测试级别的依赖等。 ​ 五、将gradle创建的Java项目转换成web项目选中项目——&gt;properties——&gt;project Facets 选中Dynamic web Module 和Java，如果出现上图中的错误（Dynamic Web Module 3.0 requires Java 1.6 or newer），则将Java选项中的版本调成你安装的对应版本，前提是的安装的JDK或JRE版本达到要求。转换成web项目之后，项目结构变成如下结构： 接下来配置gradle文件： 123456789101112131415161718192021222324252627282930313233343536373839apply plugin: 'java'apply plugin: 'war'apply plugin: 'jetty'apply plugin: 'eclipse-wtp'repositories &#123; jcenter() //定义从本地的lib文件夹中寻找依赖的jar包 flatDir &#123; dirs "lib" &#125;&#125;dependencies &#123; def springVersion = '4.3.3.RELEASE' def hibernateVersion ='4.3.11.Final'; compile "org.slf4j:slf4j-api:1.7.21" compile "org.springframework:spring-context:$&#123;springVersion&#125;" compile "org.springframework:spring-webmvc:$&#123;springVersion&#125;" compile "org.springframework:spring-beans:$&#123;springVersion&#125;" compile "org.springframework:spring-aop:$&#123;springVersion&#125;" compile "org.springframework:spring-jdbc:$&#123;springVersion&#125;" compile "org.springframework:spring-tx:$&#123;springVersion&#125;" compile "org.springframework:spring-aspects:$&#123;springVersion&#125;" compile "org.springframework:spring-orm:$&#123;springVersion&#125;" compile "org.hibernate:hibernate-core:$&#123;hibernateVersion&#125;"; compile group: 'commons-dbcp', name: 'commons-dbcp', version: '1.2.2' compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.40' testCompile "junit:junit:4.12"&#125;//定义任务将下载的jar包拷贝到webroot/WEB-INF的lib文件夹下task copyJars(type: Copy) &#123; from configurations.compile into "webContent/WEB-INF/lib"&#125; apply plugin: ‘war’：指定web项目，项目编译(在项目提示符下执行：gradle build)时生成项目的war包。 apply plugin: ‘jetty’：加入jetty的支持，代码修改后直接执行命令gradle jettyRun即可运行web项目。 task copyJars(type: Copy) :定义任务将下载的jar包拷贝到webContent/WEB-INF的lib文件夹下]]></content>
  </entry>
</search>