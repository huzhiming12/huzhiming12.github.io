<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReentrantLock]]></title>
    <url>%2F2017%2F05%2F18%2Fjava%2FReentrantLock%2F</url>
    <content type="text"><![CDATA[ReentrantLock是一个可重入的互斥锁定 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。ReentrantLock 将由最近成功获得锁定，并且还没有释放该锁定的线程所拥有。当锁定没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁定并返回。如果当前线程已经拥有该锁定，此方法将立即返回。可以使用 isHeldByCurrentThread() 和 getHoldCount() 方法来检查此情况是否发生。 重入锁： 如果当前占有锁的线程是Thread1，则当Tread1再次到来的时候不要要排队，直接将state加1，即运行次数加1。 ReentrantLock实现了Lock接口，提供了完整的Lock功能。它的一个内部类Sync类继承了AbstractQueuedSynchronizer（AQS）实现锁的功能，但是Sync并不提供公平和非公平锁机制，因此在Sync的基础之上，ReentrantLock内部又提供了两个内部类NonfairSync非公平锁、和FairSync公平锁，这两个类都是继承自Sync。 公平锁和非公平锁的区别： 公平锁：线程按照他们发出信号的先后来获取锁，采用先来先服务的原则。新来的线程直接放入等候队列中。 非公平锁：支持抢占方式，新来的线程首先会检查锁是否占用，如果被占用直接插入等候队列中，如果上一个线程刚好结束state=0时，系统会直接调用这个新来的线程执行，而不会去等候队列中唤醒阻塞的线程。这样做的好处是可以提高系统的吞吐量，因为从阻塞队列总唤醒线程需要耗费时间。 SyncSync继承自AbstractQueuedSynchronizer， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; //加锁功能 abstract void lock(); //非公平锁尝试获取锁 final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //如果没有锁定，则直接加上锁 if (c == 0) &#123; //直接 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //如果拥有资源的线程 和当前线程相同则state加1 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; //否则返回false return false; &#125; //尝试释放锁 protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; protected final boolean isHeldExclusively() &#123; return getExclusiveOwnerThread() == Thread.currentThread(); &#125; final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; //返回正在占用资源的线程 final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; //资源是否已经被占用(已经在锁) final boolean isLocked() &#123; return getState() != 0; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; NonfairSync非公平锁123456789101112131415161718static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; //加锁 final void lock() &#123; //比较并更改锁的状态，如果当前state是0，则将state修改成1，并将获取锁的线程设置成当前线程 //如果上一个线程刚好结束state=0，这时线程过来就直接获取锁，而排队等待中的线程需要继续等待， //这样可以提高系统的效率，因为要从阻塞队列中唤醒线程需要耗费时间 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else // 如果state！=0，即已经被占用，则调用获取锁的方法，acquire是AQS的方法 acquire(1); &#125; //尝试获取锁 protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125; &#125; FairSync公平锁123456789101112131415161718192021222324252627282930static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; //公平锁加锁，直接放入等候队里中 final void lock() &#123; acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //hasQueuedPredecessors ：查询是否还有线程比当前线程等候的时间更长， //即前面队列中是否还有等候吧的线程,如果没有则当前线程获取锁 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; //设置当前线程为获取资源的线程 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; &#125; ReentrantLock构造方法ReentrantLock默认是创建非公平锁 123public ReentrantLock() &#123; sync = new NonfairSync(); &#125; 可以通过参数创建公平锁，参数为true时创建公平锁，参数false时创建非公平锁 123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; ReentrantLock方法 加锁，如果已被占用则加入等候队列中 123public void lock() &#123; sync.lock();&#125; 尝试获取锁，如果获取不到就直接返回 123public boolean tryLock() &#123; return sync.nonfairTryAcquire(1); &#125; 尝试去获取锁，如果在timeout这段时间内没有获取到就直接返回 1234public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; 释放锁 123public void unlock() &#123; sync.release(1); &#125; 返回当前线程占有的数量即state值 123public int getHoldCount() &#123; return sync.getHoldCount(); &#125; 判断占有锁的线程是否是当前线程 123public boolean isHeldByCurrentThread() &#123; return sync.isHeldExclusively(); &#125; 判断资源是否加锁 123public boolean isLocked() &#123; return sync.isLocked(); &#125; 判断是否是公平锁 123public final boolean isFair() &#123; return sync instanceof FairSync; &#125; 返回占有该锁的线程 123protected Thread getOwner() &#123; return sync.getOwner(); &#125; 判断等候队列中是否还有线程 123public final boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; 判断该线程是否在等候队列中 123public final boolean hasQueuedThread(Thread thread) &#123; return sync.isQueued(thread); &#125; 返回等候队列的长度 123public final int getQueueLength() &#123; return sync.getQueueLength(); &#125; 返回所有的等候线程 123protected Collection&lt;Thread&gt; getQueuedThreads() &#123; return sync.getQueuedThreads(); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>lock</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized]]></title>
    <url>%2F2017%2F05%2F17%2Fjava%2FSynchronized%2F</url>
    <content type="text"><![CDATA[Synchronized 是Java中的一种锁，主要用来给方法和代码块加锁。当某个方法或者代码块使用synchronized关键字时，那么同一时刻最多只能有一个线程执行该代码段。当多个线程同时访问时，只有一个线程执行，其他线程处于阻塞状态，当线程执行完毕后其他线程才能执行。 synchronized 是Java虚拟机底层实现的锁机制，当synchronized方法或者代码块中发生异常时，会系统会自动释放锁定资源。 Synchronized主要有两种用法，一种是synchronized方法，另一种是synchronized代码块 Synchronized方法类的成员方法在类的成员方法声明中加上Synchronized关键字，其锁定的是类的实例对象 1public synchronized void getNum()&#123;&#125; synchronized加在类的成员方法中，本质上锁定是this对象，它和下面的写法是等价的： 12345public void getNum()&#123; synchronized(this)&#123; …… &#125;&#125; 代码访问的同步性 当多个线程同时访问同一个synchronized方法时，一次只能一个线程执行 当多个线程同时访问类中不同的Synchronized方法时，一次也只能一个线程执行，其他线程阻塞 123public synchronized void getNum()&#123;&#125;public synchronized void getNum1()&#123;&#125; 即当两个线程同时一个调用getNum，另一个调用getNum1()，同一时间只能一个线程运行 当两个线程一个调用Synchronized方法，另一个线程调用普通方法，则两个线程可以同时进行，不会相互影响 类的静态方法static在类的静态方法中加上Synchronized关键字，其锁定的是class类对象 1public static synchronized void getNum()&#123;&#125; 其效果等同于下面的写法 12345public static void getNum()&#123; //我们假设这个静态方法在Main这个类中声明 synchronized(Main.class)&#123; …… &#125;&#125; 代码访问的同步性1234567public class Main&#123; public void method()&#123;&#125;; public synchronized void method1()&#123;&#125;; //锁定的是this public synchronized void method2()&#123;&#125;; public synchronized static void method3()&#123;&#125;; //锁定的是class public synchronized static void method4()&#123;&#125;;&#125; method() 和 method1() 能同时访问 method()和method3()能同时访问 method1()和method2()不能同时访问 method3()和method4()不能同时访问 method1()和method3()可以同时访问 Synchronized代码块Synchronized代码块把需要同步的代码加上锁，将那些对线程安全没有影响的代码移出Synchronized代码块，具体写法如下 12345678public void getNum()&#123; …… synchronized(obj) &#123; …… 线程同步代码块 &#125;&#125; 代码块中添加Synchronized可以减小锁的粒度，提高程序并发的效率。 线程访问的同步性 若多个线程同时访问一个Synchronized代码块，则一次只能有一个线程能够访问 若多个代码Synchronized代码块锁定的对象是同一obj，则当多个线程同时访问这些代码块时，一次只能有一个线程能够访问这些代码块。 测试用例用例1：多个线程同时访问一个Synchronized代码块 1234567891011121314151617181920212223242526public class Test implements Runnable&#123; private static Integer num = 0; private Object obj = new Object(); @Override public void run() &#123; getNum(); &#125; public static void main(String[] args) &#123; Test test = new Test(); for (int i = 0; i &lt; 3; i++) new Thread(test, "Thread_1_" + i).start(); &#125; public void getNum() &#123; synchronized (obj) &#123; for (int i = 0; i &lt; 5; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); &#125; &#125;&#125; 测试结果：一次只能一个线程可以运行 12345678Thread_1_0 0Thread_1_0 1Thread_1_2 2Thread_1_2 3Thread_1_1 4Thread_1_1 5 测试用例2：多个线程同时访问多个Synchronized代码块，且这些代码块的锁定对象相同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Test implements Runnable&#123; private static Integer num = 0; private Object obj = new Object(); @Override public void run() &#123; getNum(); &#125; private class MyRunnable implements Runnable &#123; @Override public void run() &#123; getNum1(); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); for (int i = 0; i &lt; 3; i++) new Thread(test, "Thread_1_" + i).start(); Runnable myRunnable = test.new MyRunnable(); for (int i = 0; i &lt; 3; i++) &#123; new Thread(myRunnable, "Thread_2_" + i).start(); &#125; &#125; public void getNum() &#123; synchronized (obj) &#123; for (int i = 0; i &lt; 2; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); &#125; &#125; public void getNum1() &#123; synchronized (obj) &#123; for (int i = 0; i &lt; 2; i++) System.out.println(Thread.currentThread().getName() + " " + num++); System.out.println(); &#125; &#125;&#125; 测试结果：每次只能有一个线程可以访问Synchronized代码块 1234567891011121314151617Thread_1_0 0Thread_1_0 1Thread_1_2 2Thread_1_2 3Thread_1_1 4Thread_1_1 5Thread_2_0 6Thread_2_0 7Thread_2_1 8Thread_2_1 9Thread_2_2 10Thread_2_2 11]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 线程池]]></title>
    <url>%2F2017%2F05%2F14%2Fjava%2FJava%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[当处理大并发请求时，由于创建线程比较耗时，故引入线程池。线程池是存放线程的容器，用户请求到来前可以提前创建好线程，请求到来时便可以直接执行任务。 线程池示意图： 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; corePoolSize：线程池中保留的线程数（包括空线程），注意线程池中的线程数并不是一创建达到corePoolSize，而是在请求到达时逐步创建，最后数目达到corePoolSize。请求任务执行完毕后，若线程数&lt;corePoolSize，则会保持当前数目。 maximumPoolSize：线程池中可以容纳的最大线程数 keepAliveTime：当线程数据超过corePoolSize时，且线程任务执行完毕后，过keepAliveTime后剩余的线程将会注销 TimeUnit：keepAliveTime的时间单位 workQueue：阻塞队列(缓冲队列)，线程池中线程数目达到达到corePoolSize后，新来的任务请求会放到缓冲队列中，采用的是FIFO模式 常用的是：java.util.concurrent.ArrayBlockingQueue LinkedBlockingQueue SynchronousQueue ThreadFactory：制造线程的工厂 handler：饱和策略，当线程池中线程达到maximumPoolSize，且缓冲队列也满了之后，对新来的请求采取的策略。 请求任务执行策略 当请求任务数小于corePoolSize时，直接在线程池创建线程，并将任务放入线程中执行 当请求任务数大于corePoolSize，并且剩余的请求数小于阻塞队列长度时，将任务放入阻塞队列 若maximumPoolSize大于corePoolsize，当阻塞队列满了后还有请求任务到来，则在线程池中创建新的线程执行。 若线程池中的线程数等于maximum，且阻塞队列也满了还有任务到来，则用线程饱和策略处理。 线程池饱和策略当线程池中的缓冲队列满了，同时线程池中线程数量也达到了maximum，这时候如何还有请求过来，就会采用RejectedExecutionHandler饱和策略来应对。具体饱和策略包括下面几种： AbortPolicy：终止策略，抛出RejectedExecutionException异常，同时处理完线程池和缓冲队列中的请求 DiscardPolicy：抛弃策略，抛弃新来的请求，其他一切照常 DiscardOldestPolicy:抛弃旧任务策略，将队列头元素删除，然后将新来的请求放入队尾 CallerRunsPolicy：调用者运行策略，既不抛弃任务也不抛出异常，直接运行任务的run方法，即将任务退回给调用线程池的线程直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。 创建线程池的其他方法通过Executors类中的静态方法创建ExecutorSevice Executors.newFixedThreadPool(); Executors.newSingleThreadExecutor(); Executors.newCachedThreadPool(); Executors.newScheduledThreadPool();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合-Set介绍]]></title>
    <url>%2F2017%2F05%2F14%2Fjava%2Fjava%E9%9B%86%E5%90%88-Set%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前面介绍了一些关于List、Map的相关知识，下面我们继续来看下集合中的set。set作为容器主要存储不重复的元素。 HashSet HashSet底层实现是通过HashMap实现的，set中每个元素对应Map中的每个EntrySet结点。存储元素时只用Map的key值存储，value值统一设置为同一个new Object()。 HashSet底层存储数据的是map，所以Hashset允许null存在 HashSet存放的元素各不相同，当掉用add方法添加已存在的元素时会返回false. TreeSet TreeSet底层是通过TreeMap实现。存储元素只使用TreeMap中的key，Value同一设成相同的new Object(); TreeSet不允许插入null值 ​TreeSet元素是有序的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashSet</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识点]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[因特网组成（一）边缘部分 客户-服务器方式 对等连接方式（P2P）:两个主机通信时不区分哪个是服务请求方还是服务提供方。 （二）核心部分 路由器：实现分组交换的关键构建，其任务是转发收到的分组。 电路交换：建立连接（占用通信资源）——&gt;通话（占用通信资源）——&gt;释放链接（归还通信资源） 分组交换：采用存储转发方式，把数据报文划分成等长的数据，每组数据前加上必要的控制信息组成的包头构成一组报文。单个分组传送到相邻结点，存储下来后查找转发表。转发到下一个结点。 报文交换：整个报文先传到相邻的结点，全部信息存储下来后查找转发表，转发到下一个结点。 计算机网络的分类（一）按网络的作用范围划分 广域网 城域网 局域网 （二）按使用者划分 公用网 专用网 ###计算机网络体系结构 ​ 应用层 表示层 应用层 应用层 回话层 运输层 运输层 运输层 网络层 网际层IP 网络层 数据链路层 网络接口层 数据链路层 物理层 物理层 OSI七层协议 TCP/IP四层协议 五层协议 物理层信道与电路信道一般表示某一个方向传送信息的媒体，而一条通信线路往往包含一条发送信道和一条接收信道。 通信的三种基本方式 单线通信（单工通信）：只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）：双方都可以发送信息，但不能双方同时发送（也不能同时接收）。 双向同时通信（全双工通信）：双方可以同时发送和接收消息。 信道复用技术 频分复用：频分复用的所有用户在同样的时间占用不同的带宽资源 时分复用：时分复用的所用用户是在不同的时间占用同样的频带宽度 数据链路层三个基本问题 封装成帧：在一段数据的前后分别添加首部和尾部构成数据帧。首部加SOH尾部加EOT 透明传输：表示无论什么样的比特组合的数据都能通过这个数据链路层。如果数据中出现SOH和EOT就在前面加上转义字符“ESC”，如果数据中出现转义字符，就再前面再加一个转义字符。接收端看到有转义字符就将前面的转义字符删掉。 差错检测：传输过程中容易发生错误，需要对数据进行检验。数据链路层广泛使用循环冗余检验（CRC） 循环冗余检验（CRC cyclic redundancy check） 数据M*2^n,即在数据M后面加上n个0。列如11001101，假设n=3 —》 11001101000。 对做乘法后的数据M除以事先商量的除数。除数长度是n+1.除数p(X)叫做生成多项式。常用的生成多项式有如下： CRC8=X^8+X^5+X^4+X^0 CRC-CCITT=X^16+X^12+X^5+X^0 CRC16=X^16+X^15+X^2+X^0 CRC12=X^12+X^11+X^3+X^2+X^0 CRC32=X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0 如果数据M=10101001，多项式选用CRC8，则除数p=110001。除数选定之后长度是6位，所以n=6-1=5,即数据M后面加上5个0。 用数据M除以P，除的过程中采用模2运算。模2运算中的加减法都不考虑借位和进位列如：1111+1010=0101. 得到的余数R就作为冗余码拼接到数据M的后面发送出去。这种为了检错而添加的冗余码称为帧检验序列(FCS) 12345678910111213141516171819202122232425262728 10001110 ----------------------110001) 1100110100000 110001 ------------ 000100 000000 ------------ 001001 000000 ------------ 010010 000000 ------------ 100100 110001 ------------ 101010 110001 ------------ 110110 110001 -------------- 001110 000000 -------------- 01110 &lt;---R(余数)，作为FCS 循环冗余检验（CRC）和帧检验序列（FCS）的区别CRC是一种检错方法，FCS是添加在数据后面的冗余码 数据链路层如果仅采用循环冗余检验CRC差错检验技术的话，可以这么认为凡是接收端在数据链路层接收到的数据帧均无差错。 点对点协议（PPP）透明传输问题 异步传输 将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E) 若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D) 若信息字段中出现 ASCII 码的控制字符(0x0a，即数值小于 0x20 的字符)，则将其转变成为 2 字节序列(0x7D, 0x2a)，如0x03 变为 (0x7D, 0x23) 同步传输 发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除 使用广播信道的数据链路层CSMA/CD（载波监听多点接入/碰撞检测） 多点接入：表示许多计算机以多点接入的方式连接在一根总线上 载波监听：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 碰撞检测：计算机边发送数据边检测信道上的信号电压大小 争用期​ 以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。经过争用期还没检测到碰撞，才能肯定这次发送不会发生碰撞 二进制指数类型退避算法 基本退避时间，2τ 重传所需时延从{0，1，……，2^k^ -1}中选择。其中k=min{重传次数，10}，当重传次数大于10的时候，k=10; 当重传次数达到16次仍然不能成功时，应丢弃该帧。 例如重传次数=3，{0，1，2，3，4，5，6，7} 从这些数字中选择一个。 争用期长度 以太网取51.2 μs 为争用期的长度 对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节 以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突 最短有效帧长以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧 强化碰撞当发送数据的站一旦发生碰撞，立即停止发送数据，再继续发送若干比特的人为干扰信号，强化碰撞 网络层（网际层IP）地址解析协议（ARP）、网际控制报文协议（ICMP）、网际组管理协议（IGMP） IP地址的分类A类地址：以0开头，第一个字节范围：0~127；网络号8位，主机号24位 子网掩码255.0.0.0 B类地址：以10开头，第一个字节范围：128~191；网络号16位，主机号16位 子网掩码255.255.0.0 C类地址：以110开头，第一个字节范围：192~223；网络号24位，主机号8位 子网掩码255.255.255.0 D类地址：以1110开头，第一个字节范围为224~239；多播地址 无分类编址192.168.34.256/16:表示前16位是网络前缀，后面16位是主机号。/后面表示网络前缀占的位数 IP={《网络前缀》,《主机号》} 子网掩码1的个数与网络前缀的个数相同。 IP数据报的格式 一个IP数据报有首部和数据两部分组成 首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 版本号4位，指IP协议的版本，目前是4（ipv4） 首部长度4位，可表示的最大值是15，1个单位是4字节，因此首部最长可以是60字节 区分服务8位，一般不使用 总长度16位，值首部和数据的总长度，单位字节。最大长度是65535，但是不能超过最大传送单元MTU 标识16位，用来产生数据报的标识 标志3位，第一位没用；第二位DF，DF=0时才允许有分片；第三位MF，MF=1后面有分片，MF=0后面没有分片 片偏移12位，该片在原数据段中的位置，以8字节为单位。 生存时间8位，数据报在网络中可通过的路由器数 地址解析协议（ARP）已知一个机器的IP地址，需要寻找其相应的硬件地址(Mac地址)。 ARP高速缓存：每一个主机都设有一个ARP高速缓存，里面存放了本局域网上的各个主机和路由器的IP地址到硬件地址的映射表。 注意：ARP是解决同一个局域网上的主机或路由的IP地址和硬件地址的映射问题。 子网划分IP地址原先分为网络号和主机号 子网划分就是将主机号划分为子网号和主机号。 IP地址={《网络号》,《子网号》,《主机号》}； 子网掩码作用：把子网掩码和IP地址做与(AND)运算就得出该IP的网络地址。网络地址就是该设备所在网络中的唯一确定地址。 例题：已知IP地址是141.14.72.24，子网掩码是255.255.192.0，求网络地址 12345141.1 4.01001000.24255.255.11000000.0------------------- 与运算141.1 4.01000000.24 --&gt;141.14.64.0(网络地址)这个IP是B类地址，网络号16位、子网号2位、主机号14位。 无分类编址CIDRIP地址={&lt;网络前缀&gt;，&lt;主机号&gt;} CIDR还使用斜线记法，在IP地址后面加上“/”，同时后面接上网络前缀的所占位数。 128.14.12.0/20—— 表示的地址块有2^12^个地址，斜线后面的20表示网络前缀的位数。 因特网路由选择协议内部网关协议RIP内部网关协议OSPFOSPF（open shortest path first）:开放最短路径优先 运输层用户数据报协议UDPTCP传输控制协议建立连接： 释放连接： linux下侦测主机到目的主机之前所经过的路由的命令。 traceroute ：命令用来探测路由经过.. ping ：命令用来检测两部主机之间的传输信道是否畅通，或远程主机是否正常.. route：命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录来进行相应的添加、删除或修改等操作。 ifconfig：命令用来来检测和设置本机的网络接口。 TCP和UDP的区别和应用场景 TCP UDP 连接性 面向连接的 无连接的 可靠性 可靠的 不可靠 报文 面向字节流 面向报文（保留报文边界） 效率 低 高 双工性 全双工 一对一、一对多、多对一、多对多 流量控制 有（滑动窗口） 无 拥塞控制 有（慢开始、拥塞避免、快重传、快恢复） 无 传输速度 慢 快 应用场合 对效率要求相对低的，但对准确性要求相对高；或者是要有连接的场景 对效率要求相对高，对准确性要求相对低的场景 应用示例 TCP一般用于文件传输（FTP、http对数据准确性要求高，速度可以相对慢）；发送接收邮件（pop，SMTP,IMAP 对数据准确性要求高，非紧急应用）；远程登录（Telnet，SSH 有连接）等等 UDP一般用于即时通信（QQ，对数据准确性和丢包要求比较低，但速度必须快）；在线视频（速度一定要快，保证视频的连续性，但是偶尔花了一个图像帧用户还是能接受的）；网络电话等]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http和https的区别]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Fhttp%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[http协议是未加密的传输，即采用明文的方式发送内容，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就很容易直接读取其中的信息。https就是在http的基础之上加入了SSL协议，SSL用于对http协议传输的数据进行加密。 https协议需要到ca申请证书，一般需要一定的费用 http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密协议 http和HTTPS使用不同的连接方式，用的端口也不同，前者是80端口，后者是443端口 http的连接是简单无状态的，HTTPS协议是由ssl+http协议构成的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTP1.0 与HTTP1.1的区别 引入持久化连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。 引入管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 Http状态码： 1xx：指示信息，表示请求已经接收，继续处理 2xx：成功，表示请求已经被成功接收、理解、接受 3xx：重定向，表示完成请求必须进行更进一步的操作 4xx：客户端错误，请求有语法错误或者请求无法实现 5xx：服务器端错误，服务器未能实现合法的请求 常见的状态码： 200：OK——客户端请求成功 400：Bad request——客户端请求有语法错误，不能被服务器解析 401：unauthorized——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403：Forbidden——服务器收到请求，但是拒绝提供服务 404：Not found——请求资源不存在 如URL输入错误 500：Internal Server Error——服务器发生了不可预料的错误 503：Server Unavailable——服务器当前不能处理客户端的请求，一段时间后可能恢复正常 Http Request请求头常见字段： Http请求方式 ​ Host：请求的web服务器域名地址 User-Agent：Http客户端浏览器类型的详细信息 Accept：指定客户端能够接收的内容类型 text/xml、text/html Accept-Language：指定客户端浏览器用来显示返回信息所优先选择的语言 Accept-Encoding：指定客户端浏览器可以支持服务器返回内容的压缩编码类型，表示客户端浏览器所能支持的返回压缩格式 Accept-CharSet：浏览器可以接受的字符编码集 Content-type：此请求提交的内容类型，一般只有post提交时才需要设置该属性 Connection：表示是否需要持久连接，如果值是keep-Alive或者协议版本是HTTP1.1，就会进行持久连接 Cookie：http请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器 Date：请求发送的日期时间 Http Response响应头字段： Cache-Control：缓存机制,no-cache,private,public, Connection:是否要保持持久连接 Content-Encoding：返回来数据的压缩格式 Content-Language：相应体的语言 Content-type：返回资源文件的类型 Date：服务器发送资源时的服务器时间 Expiers:告诉客户端在这个时间前可以直接访问缓冲副本，相应过期时间 Last-Modifed:请求资源的最后修改时间]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 文章中插入图片问题]]></title>
    <url>%2F2017%2F05%2F13%2Fhexo%2Fhexo-%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 12345本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg)就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为 12345public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; 而不是愚蠢的 &lt;img src=&quot;本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt;]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识点]]></title>
    <url>%2F2017%2F05%2F13%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1. 进程管理1.1 进程基本概念程序顺序执行的特征 顺序性：每一个操作必须在下一个操作开始之前结束 封闭性：程序运行时独占全机资源，资源的状态只有本程序才能改变 可在现性 前趋图有向无环图 作用：用于描述程序段或进程间执行的前后顺序。 结点：表示程序段或进程，或一条语句** 有向边：表示结点之间的偏序(前驱)关系 并发执行时的特征 间断性——“停停走走” 失去封闭性——原因：多个程序共享资源 不可再现性 进程的定义与特征 结构性（PCB） 进程实体 = 程序 + 进程控制块(PCB) 程序=数据段+程序段 动态性 进程实质是进程实体的一次执行过程 体现在 “由创建而生，由调度而执行，由撤销而亡” 并发性 独立性 异步性 进程的定义进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 进程和程序的区别与联系 区别 进程是动态概念，强调的是执行，有创建、有撤销，存在是暂时的。程序是一静态概念，程序是指令的有序集合，“永远”存在； 进程具有并发性，而程序没有； 进程是接受计算机资源的基本单位，程序不是。 联系 进程是程序在数据集上的一次执行 一个程序可对应多个进程，一个进程可包括多个程序。 进程的三种状态 就绪状态 执行状态 阻塞状态 1.2 进程控制进程控制是进程管理中最基本的功能 用于创建新进程 终止一个已完成的进程 终止一个无法运行下去的进程 (Kill) 负责进程的状态转换 (就绪执行) 1.3进程图描述一个进程家族关系的有向树 1.4 经典进程同步问题生产者消费者问题记录型信号量方法 生产者 1234567891011121314 var mutex,empty,full:semaphore:=1,n,0；// 定义信号量 buffer:array[0,…,n-1] of item; // 定义缓冲区 in, out : integer :=0,0; // 定义下标指示变量begin //生产者如何执行(如何往缓冲区放东西) repeat 产生一个商品放入nextp中; wait(empty); //等待缓冲区有地方 wait(mutex); //等待可以使用缓冲区 buffer[in] := nextp; in := (in + 1) mod n; signal(mutex); //告诉其他进程：缓冲区可以使用了 signal(full); //告诉其他进程：缓冲区中多了一个商品 until false; end 生产者 1234567891011begin //消费者如何执行(如何从缓冲区取东西) repeat wait(full); //等待缓冲区有商品 wait(mutex); //等待可以使用缓冲区 nextc := buffer[out]; out := (out + 1) mod n; signal(mutex); //告诉其他进程: 缓冲区可以使用了 signal(empty); //告诉其他进程: 缓冲区空出一个地方 消费商品 nextc; until false;end; 注意wait(mutex)和signal(mutex)必须成对出现empty、full的wait、signal也要成对出现注意多个wait的顺序不能颠倒。 利用and信号量解决123456789101112生产者: … Swait(empty,mutex); buffer[in] := nextp; in := (in + 1) mod n; Ssignal(mutex,full);消费者: Swait(full,mutex); nextc := buffer[out]; out := (out + 1) mod n; Ssignal(mutex,empty); … 哲学家进餐问题利用记录型信号量12345678910var chopstick:array[0,…,4] of semaphore; 所有信号量初始值为1； repeat //第i个哲学家的活动 wait(chopstick[i]); //拿左筷子 wait(chopstick[(i+1) mod 5]); //拿右筷子 吃饭; signal(chopstick[i]); //放左筷子 signal(chopstick[(i+1) mod 5]); //放右筷子 思考; until false; 缺点： 如果每个人开始都先拿自己左边的筷子，可能导致人手一根筷子，而拿不到第二根筷子，从而全部阻塞，引起死锁。 and信号量12345678var chopstick: array[0,…,4] of semaphore; 所有信号量全部初始化为1; repeat Swait(chopstick[i], chopstick[(i+1) mod 5]); 吃饭; Ssignal(chopstick[(i+1) mod 5], chopstick[i]); 思考； until false; 1.5 进程通信进程通信类型 共享存储系统 消息传递系统 管道通信系统 1.6 线程和进程的区别与联系 调度 线程是调度的基本单位 进程是资源拥有的基本单位 拥有资源 线程不拥有系统资源，但是可以访问其隶属进程的系统资源，从而获得系统资源 并发性 支持多进程的系统中，不仅不同进程之间可以并发，同一进程中的线程也支持多并发 系统开销 进程切换时的时空开销大 进程切换时，只需保存和设置少量信息，因此开销很小 ​ 2. 处理机调度和死锁2.1 调度算法 先来先服务（FIFS）调度算法 短作业优先调度算法（SJF、SPF） 高优先权调度算法（FPF） 静态优先权：创建进程时分配，保持不变 动态优先权：随进程的执行或等待时间的增加而改变（防止长进程长期霸占） 高响应比优先权调度算法 动态优先权 优先权=（等待时间+要求服务时间）/要求服务时间 响应比=响应时间/要求服务时间 基于时间片的轮转调度算法——分时系统 2.2 实时调度实时调度与其他系统的区别：处理和控制的正确性不仅取决于计算的结果，还取决于计算和处理结果产生的时间。 实时调度算法 最早截止时间优先（EDF） 最低松弛度优先算法（LLF） 松弛度=完成截止时间-剩余运行时间-当前时间 2.3 产生死锁的原因和必要条件死锁：多个进程在运行过程中，因争夺资源二造成的一种僵局。这种僵局若无外力作用无法再向前推进。 产生死锁的原因： 资源竞争 进程推进顺序非法 死锁产生的必要条件 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 2.4 预防死锁的方法 摒弃请求和保持条件，规定所有进程在开始之前，都必须一次性申请其在整个运行过程中所需的全部资源，只要有一种资源不够，便不分配。 摒弃不剥夺条件，进程可以逐个申请资源，一旦申请的资源无法满足，立即释放已经保持的所有资源 摈弃环路等待条件 银行家算法：避免死锁 资源有序分配法：预防死锁 资源分配图化简法：检测死锁 撤销进程法：解决死锁 3. 存储器管理3.1 程序的装入和链接程序装入 绝对装入方式 程序中使用绝对地址，可编译时给出也可以有程序员直接赋予 可重定位装入方式 在装入是对程序中的指令和数据进行修改 动态运行时装入方式 执行代码是再进行地址转换 程序的链接 静态链接 装入时动态链接 运行时动态链接 3.2 连续分配方式 单一连续分配 把内存分为系统区和用户区两部分 固定分区分配 把用户区划分成若干个大小固定的分区，每个分区只放一个进程 当一个分区空闲时，可以选择一个新的进程进入那里运行 动态分区分配：根据进程的实际需要，动态分配内存空间 首次适应算法（FF） 以地址递增次序链接空闲分区，从链首开始查找，找到第一个满足请求大小的分区，从中划出请求大小的空间，余下的仍留在链中。 循环首次适应算法 由FF算法演变而成的。 从上次找到的空闲分区的下一个空闲分区查找。 最佳适应算法 分区按容量大小递增顺序排列，找到能满足分配的最小空闲分区。 动态重定位分区分配 对换定义：吧暂时不用的程序及其数据的部分或全部从内存移到外存上，以便腾出必要的空间 整体对换（进程对换） 部分对换（页面对换、分段对换） 3.3 基本分页存储管理方式页面与页表页面与物理块 把进程的逻辑地址空间分成若干大小相等的片，称之为页面或页，编号从0开始。 把内存的存储空间也划分成与页相同大小的片，这些片称为物理块或页框，编号从0开始 3.4 基本分段存储管理方式分页和分段的主要区别 页是信息的物理单位，分页是为消减内存的碎片，提高内存的利用率。分页仅是由于系统管理的需要。 段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 页的大小固定，由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；段的长度不固定，决定于用户所编写的程序，由编译程序编译源程序时，根据信息的性质来划分。 3.5 页面置换算法抖动：系统一直忙于页面的调入/调出，以致大部分CPU时间都用于处理缺页中断和页面淘汰上，很少能顾及到用户进程的实际执行的现象称为“抖动” 注意：缺页中断不一定引起页面淘汰。只有内存中没有空闲块时，缺页中断才会引起页面淘汰 最佳置换算法从内存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面 先进先出置换算法（FIFO）总是选择进程中驻留时间最长的页淘汰，即先进入内存的页面先淘汰出内存。 最近最久未使用置换算法（LRU）选择最近一段时间内最久不用的页面进行淘汰 4. 设备管理4.1 I/O控制方式程序控制方式忙——等待方式。 中断驱动方式​ 中断时以字节为单位进行控制的 进程要启动I/O设备工作时，由CPU向该设备控制器发出一条I/O命令，然后便可立即返回继续执行原来的任务。 设备控制器按照命令要求去控制指定设备。此时，CPU与I/O设备并行操作。 设备处理完数据后，便产生一个中断信号。此时，CPU便转而处理该信号。 DMA方式传输的基本单位是数据块，CPU与I/O设备之间每次传送至少一个数据块。仅在传送一个或多个数据块的开始或结束时才需要CPU干涉。 DMA工作过程 以从磁盘读入数据为例： 从磁盘读入数据块时，CPU将一条读指令送至磁盘控制器的命令寄存器(CR)中。 将数据读入的内存起始目标地址送入内存地址寄存器（MAR）中；将读数据的字(节)数送入数据计数器(DC)中 将磁盘的源地址送至DMA控制器的I/O逻辑中。 然后，启动DMA控制器进行数据传送，以后，CPU便可去处理其它任务。 此后，整个数据传送过程便由DMA控制器进行控制。 当DMA控制器已从磁盘读入一个字(节)的数据并送入数据寄存器(DR)后，将该字(节)传送到指定的内存单元中。 接着便对MAR内容加1，将DC内容减1。 若减1后DC内容不为0，表示传送未完，便继续传送下一个字(节)； 否则，由DMA控制器发出中断请求。 DR：数据寄存器，用于暂存数据 MAR：内存地址寄存器，存放数据的源/起始目标地址 DC：数据计数器，存放本次CPU要读或写的字节数 CR：命令/状态寄存器，接收从CPU发来的I/O命令或有关控制信息或设备状态 I/O通道控制方式 指令类型单一，主要局限于对I/O操作 没有自己的内存，通道程序放在内存里 在设置了通道后，CPU只需向通道发送一条I/O指令。通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成了规定的I/O任务后，才向CPU发中断信号 4.2 缓冲管理引入缓冲 缓和CPU与I/O设备间速度不匹配的矛盾 减少对CPU的中断频率 提高CPU和I/O设备之间的并行性 单缓冲和双缓冲单缓冲每当用户进程发出一个I/O请求时，OS便在内存总位置分配一个缓冲区 max(磁盘到缓冲区，CPU处理) + 缓冲区到用户区 双缓冲区设备输入时，先将数据送入缓冲区1，装满后转向缓冲区2 循环缓冲在循环缓冲中包括多个缓冲区，每个缓冲区的大小相同 作为输入的多缓冲区可分为三种类型： 空缓冲区R 已装满数据的缓冲区G 计算进程正在使用的工作缓冲区C 缓冲池公用缓冲池，池中设立多个缓冲区，为多个进程共享，以提高利用率 4.3 设备分配SPOOLing技术 脱机输入/输出技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反。 SPOOLing技术的实质是模拟脱机输入、输出 基本方法 用一个进程将设备输入的数据暂存到磁盘上 用另一个进程把暂存在磁盘上的数据传送到设备上 spooling 系统组成部分 输入井、输出井 磁盘上的两块大存储区，用于暂存输入、输出的数据 输入缓冲区、输出缓冲区 位于内存中，作用是缓和CPU和设备之间的速度差异 输入进程、输出进程 输入进程：利用输入缓冲区为中介，吧输入设备的数据存入输入井 输出进程：将用户数据存入输出井，设备空闲时再将输出井中的数据利用输出缓冲区送入设备 ​ 4.4 磁盘存储器管理磁盘调度算法 先来先服务（FCFS） 根据进程请求访问磁盘的先后次序进行调度 最短寻道时间优先（SSTF） 首先满足访问的磁道与当前所在磁道之间距离最短的进程。但是这种算法不能保证平均寻道时间最短 进程饥饿现象 因为只要不断有新进程的请求到达，且其所要访问的磁道与当前磁道之间的距离较近，新进程的I/O请求必然优先满足。致使老进程的请求长期无法得到满足 扫描算法（SCAN） 当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对象，应是要访问的磁道既在当前磁道之外，又是距离最近的。 这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁头换向为自外向里移动 循环扫描算法（CSCAN） 磁头只做单向移动。例如总是自里向外，当磁头移到最外的磁道并访问完后，磁头立即返回最里要访问的磁道。 5. 文件管理5.1 文件逻辑结构文件逻辑结构的类型 有结构文件 无结构文件（流式文件） Unix系统吧所有文件都看做流式文件 顺序文件记录可以任意顺序排列 索引文件顺序索引文件直接文件和hash文件外存分配方式连续分配方式文件存储于连续的盘块上 链接分配通过盘块上的链接指针，把保存在不同盘块上的各文件部分链接起来]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-theme-indigo-card主题安装及常见问题解决]]></title>
    <url>%2F2017%2F05%2F13%2Fhexo%2Fhexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令。 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 切换主题执行 git branch 显示所有本地分支，如果只存在一个分支，可以执行下面的命令获取另一分支的主题。 12345# 获取远程 card 分支，并切换$ git checkout -b card origin/card# 获取远程 master 分支，并切换$ git checkout -b master origin/master 此命令只需执行一次，之后使用 git checkout [branch] 命令在两个主题之间切换。 依赖安装还是在 Hexo 根目录，如果以下插件已安装过，无需再次安装。 Less主题默认使用 less 作为 css 预处理工具。 1$ npm install hexo-renderer-less --save Feed用于生成 rss。 1$ npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。 1$ npm install hexo-generator-json-content --save QRCode用于生成微信分享二维码。 可选，不安装时会请求 jiathis Api 生成二维码。 1$ npm install hexo-helper-qrcode --save 开启标签页1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 开启分类页仅 card theme 支持。 1hexo new page categories 修改 hexo/source/categories/index.md 的元数据 123layout: categoriescomments: false--- 常见问题如何设置文章摘要在 Markdown 中加 &lt;!-- more --&gt; 文章如何添加多个标签有两种多标签格式 1tags: [a, b, c] 或 1234tags: - a - b - c 修改 brand 图片（菜单上方背景图）替换 themes\indigo\source\img\brand.jpg，保持原文件名不变。 如何在文章中使用图标先到 fontawesome 找到你需要的图标名，比如：book，按以下格式使用： 1&lt;i class=&quot;icon icon-book&quot;&gt;&lt;/i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 1234567891011121314&lt;!-- 1.3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-lg&quot;&gt;&lt;/i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-2x&quot;&gt;&lt;/i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-3x&quot;&gt;&lt;/i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-4x&quot;&gt;&lt;/i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-5x&quot;&gt;&lt;/i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class=&quot;icon icon-book icon-pr&quot;&gt;&lt;/i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class=&quot;icon icon-book icon-pl&quot;&gt;&lt;/i&gt; 个别图标无法显示如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。 解决办法：可配置 ADBlock 不在你的站点运行。 生成站点后没有样式安装less 更改样式后网站没有生效确认非缓存问题后，执行 hexo clean 再进行生成上传。 更改站点配色编辑 themes\indigo\source\css\_partial\variable.less，更改对应的颜色变量。 配色参考：Material Design Color Palette Generator 添加404页面在 hexo/source 目录内新建 404.html。 设置元数据信息，如果不想套用主题布局可设置 layout 为 false。 123layout: false title: &quot;My Blog Name | 404&quot;--- 在博客中使用 Emoji参考 Can i use emoji in mypage? 多说 多说配置，取你的多说后台网址二级域名。比如我的是：http://ysblog.duoshuo.com/admin/中的 ysblog。 评论中如果显示 HTML 标签，你需要 进入多说设置 -&gt; 评论解析 -&gt; 解析HTML代码 勾选上。 已本地化多说脚本和样式，有个人需求的可以自行修改相关样式 source/css/_duoshuo/* 和脚本 source/css/js/embed.js。 配置站点配置编辑站点配置文件，hexo/_config.yml。 启用主题1theme: indigo 基本配置为了得到更好的使用体验，以下内容请务必填写完整，因为这些内容会在主题中得到展示。更多 1234567title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url feed配置参考 hexo-generator-feed 1234feed: type: atom path: atom.xml limit: 0 jsonContent配置为了节约资源，可以对 jsonContent 插件生成的数据字段进行配置，减少数据文件大小。参考 hexo-generator-json-content 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 主题配置编辑主题配置文件，themes/indigo/_config.yml。 左侧菜单默认配置如下 1234567891011121314151617menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下： 12345menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 fontawesome 图标已集成到主题中，你可以到 这个页面 挑选合适的图标。 rss1rss: /atom.xml favicon站点 logo，显示在浏览器当前标签页左上角。 1favicon: /favicon.ico 头像位于左侧菜单上方 1avatar: /img/logo.jpg email头像下方 1email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。 1color: &apos;#3F51B5&apos; 标签页 (old)配置标签页标题 12tags: title: 标签 页面标题 (card theme)自定义归档、标签、分类页的大标题。 123tags_title: Tagsarchives_title: Archivescategories_title: Categories 文章摘要可以在 Markdown 文件中加 &lt;!--more--&gt;以分割摘要与文章正文。未设置时，按 excerpt_length设置截取。 123456# 文章摘要渲染方式: 为 true 时将渲染为 html，否则为文本excerpt_render: false# 截断长度excerpt_length: 200# 文字正文页链接文字excerpt_link: 阅读全文... mathjax开启后，使你的站点支持公式渲染，by mathjax。 请按需开启，因为此项需要加载额外的 js 文件。 1mathjax: false 分享文章分享开关，by jiathis-api。 1share: true 文章打赏默认开启 1234reward: title: 谢谢大爷~ #显示的文字 wechat: /img/wechat.jpg #微信，关闭设为 false alipay: /img/alipay.jpg #支付宝，关闭设为 false 此外在 crad theme 中，可以通过在 markdown 头部添加 reward: false 来控制某些不想开启打赏的页面。 关闭 1reward: false 二维码请自行从微信、支付宝中下载。当两个二维码同时存在时，为保持显示效果的一致性，注意截图时的边框留白保持一致。必要时可借助PS等图片处理工具进行图片大小裁剪、压缩等。 站内搜索是否开启搜索 1search: true 布局开启后，文章页在大屏下会隐藏左侧菜单，专注阅读。 1hideMenu: true Toc开启文章内容导航。 123#toc: false #关闭toc: list_number: false # 决定导航使用的标签， true 为 ol， false 为 ul。 copyright (card theme)文章页版权声明内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io。 1copyright: 这里写留言或版权声明：&lt;a href=&quot;&lt;%- url_for(page.path) %&gt;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;%- url %&gt;&lt;/a&gt; less设置 less 编译时的入口文件路径，hexo-renderer-less。 1234less: compress: true # 是否压缩css paths: - source/css/style.less 评论集成了多说和 disqus，开启其一即可。 duoshuo-key 即多说创建站点时的二级域名。如：abc.duoshuo.com，就填 abc。 1duoshuo: duoshuo-key 或 1disqus_shortname: disqus_shortname 数据统计集成的有谷歌和 CNZZ，请填写你的站点标识。 12google_analytics: keycnzz: 站点id 谷歌站点验证 (card theme)1google_site_verification: false 规范网址 (card theme)让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径。使用规范网址 1canonical: http://imys.net 版权起始年份1since_year: 2006 自定义页面关于用户页面中作者相关的描述性文字，如不需要设为 false 1about: 用户页面中作者相关的描述性文字，如不需要设为 false]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布隆过滤器]]></title>
    <url>%2F2017%2F05%2F13%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介 布隆过滤器主要用于判断一个元素是否在集合中，常见的如垃圾邮件过滤的黑白名单方法、爬虫的网址判重模块等。 Hash表也可以用于判断元素是否在集合中，但是布隆过滤器只要Hash表的1/4或1/8甚至更少的空间复杂度就能完成同样的问题。 布隆过滤器存在一定的误报率，通过设计bitArray的大小可以将误报率控制在极低水平。使用布隆过滤器一定是在有一定容错概率的情况下。 布隆过滤器的设计假设数据查询的数据量为n，允许的失误率p 长度为m的BitArray，二进制数组，里面存放的数据都是0和1 k个相互独立的hash函数 添加元素 初始时将BitArray中的元素全部置为0 将单条数据str，分别用k个hash函数计算出对应的hash值，将这k个hash值再对m进行取模运算，得到数据h1,h2,……hk. 将BitArray h1、h2、……hk位置上的值置为1 每条数据都重复2、3步骤。 查询元素是否在集合中 将要查询的数据分别用k个hash函数计算出对应的hash值，然后对m进行取模运算，得到数据h1 h2 …… hk. 判断BitArray h1、h2、……、hk位置上的值是否全部都是1，如果全为1则表示数据已经在集合中，如果不全为1则表示数据不在集合中。 n k m p 之间的关系 样本个数n和允许失误概率p可以求出m $$m= - \frac{n*lnp}{(ln)^2}$$ 根据m可以求出k，hash函数的个数 ​$$k =ln2 \frac{m}{n} = 0.7 \frac{m}{n}$$ 由于在计算m和k的过程中都是向上取整的，失误率会降低，可以根据下面的公式计算出具体的失误率：$$p=(1- e ^-(\frac{nk}{m}))^k$$求出真实的失误率p]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合_Map介绍]]></title>
    <url>%2F2017%2F05%2F10%2Fjava%2FJava%E9%9B%86%E5%90%88-Map%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[HashMap（非线程安全） HashMap底层由一个EntrySet数组构成，每个EntrySet都是一个链表 12345678910111213static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; ……&#125; loadFactor，加载因子，默认值是0.75。当map中的元素个数size&gt;=table.length*loadFactor时，hashMap 会进行扩容。如果loadFactor过小，则空间浪费比较严重；若loadFactor过大，则hashmap冲突的概率会加大，造成一些EntrySet链表过长。 创建hashMap时可以指定初始容量和加载因子，默认初始容量为16，加载因子为0.75 计算元素o 在table数组中的下标，其中h是根据o.key计算的hash值，length是指数组的长度 123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; hashMap中的key和value都可以为null，当key==null时，该元素会放在table下标为0的位置上。 12if (key == null) return putForNullKey(value); 123456789101112131415private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; //如果map中原来已经存在key值为null的元素，则更新value值 if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // hash值为0，key=null value=value 在table中位置index=0 addEntry(0, null, value, 0); return null;&#125; map中添加新元素时，是将元素添加在链表头。 123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; //threshold = table.length * loadFactor 判断是否需要扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125; 1234567//创建一个新的结点，插入链表头。即创建新元素时是插入链表头的。void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; //table[bucketIndex]表示的是链表头，链表头指向了新建的结点，同时新节点的next指针指向 了原来的链表头结点。 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++; &#125; map扩容是原来table长度的2倍。扩容时，需要遍历原来的map，将每个元素重新计算hash值和在新table的中位置，再放入新的table中。 1234567891011121314151617void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; //计算元素在新table中的位置 int i = indexFor(e.hash, newCapacity); //newTable[i]是其中一个链表的链表头 e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125; &#125; Hashtable(线程安全) HashTable是线程安全的容器，而HashMap是非线程安全的 HashTable 继承自Dictionary类，该类自Java1.0就已经存在；HashMap继承自AbstractMap,这个抽象类是是在1.2才加入的 Hashtable 不允许key和value为空值null；HashMap允许key和value为空值null。 Hashtable的hash函数不同 1234private int hash(Object k) &#123; // hashSeed will be zero if alternative hashing is disabled. return hashSeed ^ k.hashCode(); &#125; HashTable 默认初始容量是11，加载因子默认是0.75 HashTable计算index方法与HashTable不同 1234//hashtable 计算indexint index = (hash &amp; 0x7FFFFFFF) % tab.length;// HashMap 计算下标return h &amp; (length-1); HashTable扩容时原来table数组长度的两倍加1 1int newCapacity = (oldCapacity &lt;&lt; 1) + 1; TreeMap(非线程安全) Treemap 底层是通过红黑树算法实现的，想要了解TreeMap的实现必须先对红黑树有一定了解，下面先介绍一下红黑树的相关概念 红黑树简介红黑树是一种自平衡的二叉查找树，具有二叉树的所有特性。红黑树具有如下五点性质 结点要么是红色要么是黑色 根节点是黑色 每个叶子结点是黑色 从根节点到叶子结点的所有路径上不能有两个连续的红色结点 从任一结点到其每个叶子结点的所有路径都包含相同数目的黑色结点 ​ 红黑树 ​ 普通二叉树，根节点的左右子树不平衡 TreeMap介绍TreeMap相关定义TreeMap中包含信息中比较重要的有如下这些 12345678//比较器，用于比较结点的大小private final Comparator&lt;? super K&gt; comparator;//根节点private transient Entry&lt;K,V&gt; root = null;//元素的个数private transient int size = 0;//map修改次数private transient int modCount = 0; 对叶子结点的定义如下： 123456789101112131415static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left = null; Entry&lt;K,V&gt; right = null; Entry&lt;K,V&gt; parent; //新生成的结点都是黑色的 boolean color = BLACK; Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125;&#125; TreeMap添加元素方法put添加元素的时候首先判断root结点是否为空，如果是空直接创建新的结点作为map的根节点；如果不为空，则根据比较器（若创建TreeMap时未指定比价器，则以key的字典序作为比较器）找到元素的位置。寻找元素位置时是对二叉搜索树进行查找，key&gt;node 则查找右子树，key&lt;node查找左子树，key==node 直接更新node的value值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; //根节点为空 if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; //创建TreeMap时已经指定比较器 if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); //父节点大于新加的结点，则遍历左子树 if (cmp &lt; 0) t = t.left; //父节点小于新加结点，则遍历右子树 else if (cmp &gt; 0) t = t.right; else //父节点等于新加结点，则直接更新父节点的value值 return t.setValue(value); &#125; while (t != null); //循环结束还没找到结点key和新节点key相等，此时parent指向了叶子结点 &#125; else &#123; if (key == null) throw new NullPointerException(); //未指定比较器，则比较器设为字典序 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; //结点位置查找过程和上面一样 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; //如果遍历后还未找到key,则创建新节点，新节点的parent指向前面遍历后的最后一个叶子结点 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); //如果新节点的key小于parent的key,则新节点作为parent的左孩子，反之作为右孩子 if (cmp &lt; 0) parent.left = e; else parent.right = e; // 添加完新节点后 需要对这棵树进行调整平衡 fixAfterInsertion(e); size++; modCount++; return null; &#125; 上面的put方法只是将新节点插入了适当的位置，保证了此时的二叉树是二叉搜树，但它不一是平衡二叉树。所以在插入新节点后有一个修正操作fixAfterInsertion(e)，修正操作就是保证二叉树是平衡二叉树。 修改后 修改后 最后修改成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; //将新插入的结点设为红色 x.color = RED; // 循环直到 x不是根结点，且x的父节点不为红色 while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; //如果结点x的父节点P 是P的父节点G的左子树 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; //否则结点x的父节点P 是P父节点G的右子树 G &#125; else &#123; // y P // x x可能是左子树也可能是右子树 Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; //如果x是P的左孩子 if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; TreeMap 查找复杂度是O(logN)，HashMap的查找复杂度是O(1)，查找效率来说HashMap 效率更高。但是TreeMap存储的数据是有序的，而HashMap存储的数据是无序的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>TreeMap</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合_List介绍]]></title>
    <url>%2F2017%2F05%2F08%2Fjava%2FJava%E9%9B%86%E5%90%88-List%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[集合类介绍 ArrayList（非线程安全） ArrayList底层采用数组存放数据 创建时可以指定初始容量的大小，若不指定则默认是10. ArrayList扩容是1.5倍的增长 123int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//将数组内容拷贝到新创建的数组中，并返回新创建数组的引用elementData = Arrays.copyOf(elementData, newCapacity); arrayList不是线程安全的容器 当数组元素已经达到数组容量时才会发生扩容 Vector（线程安全） Vector与ArrayList实现基本相同，当时Vector是线程安全的，每个操作方法中加了synchronized关键字，属于线程安全的容器 创建Vector时可以指定初始容量，也可以指定发生扩容时扩容的大小。若没指定初始容量大小默认是10；若没有指定扩容的大小，默认是两倍增长，否则 12int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); LinkedList（非线程安全） LinkedList底层实现是通过链表，每个元素是一个Node结点 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 定义两个变量first、last分别指向链表的头结点和尾结点 实现了Queue 接口 offer(E e) 操作调用add方法，将元素插入队列的尾部 添加元素e之后 poll操作删除队列头元素，删除的是first结点 element操作返回队列头结点，即first结点，如果first==null 抛出异常 peek操作返回队列头结点，即first结点，如果first==null 则返回null 实现了Stack功能 push添加元素，注意是在链表的头结点处插入元素 pop 操作是删除链表的头结点 peek 操作返回链表的头结点]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>vector</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-继承关系和常用API]]></title>
    <url>%2F2017%2F05%2F05%2Fjava%2FJava%E9%9B%86%E5%90%88-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[集合继承关系Collection集合的类继承关系图： Map集合继承关系图： 常用的APIArrayList：123456789101112131415161718//List尾部添加元素boolean add(E e);//在index位置添加元素public void add(int index,E element);//移除元素oboolean remove(Object o);//移除下标index的元素public E remove(int index);//清空列表public void clear();//添加集合中的全部元素public boolean addAll(Collection&lt;? extends E&gt; c);//返回list的遍历public Iterator&lt;E&gt; iterator();//是否包含元素public boolean contains(Object o);//将下标为index元素替换public E set(int index,E element) Queue：12345678910//添加元素boolean add(E e);//获取并移除队列头,此队列为空时将抛出一个异常。E remove();//获取并移除此队列的头，如果此队列为空，则返回 null。E poll();//获取，但是不移除此队列的头。此方法与 peek 唯一的不同在于：此队列为空时将抛出一个异常。E element();//获取但不移除此队列的头；如果此队列为空，则返回 null。E peek(); Set:12345678910//添加元素boolean add(E e);//移除元素boolean remove(Object o);//添加所有集合元素boolean addAll(Collection&lt;? extends E&gt; c);//清空集合void clear();//返回set的迭代器Iterator&lt;E&gt; iterator(); Stack: 继承自vector，是线程安全的12345678910//把项压入堆栈顶部。public E push(E item);//移除栈顶元素public E pop();//返回栈顶元素，但是不删除public E peek();//测试栈是否为空public boolean empty();//返回元素在栈中的位置，以1为基数，-1表示不存在public int search(Object o);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql优化策略]]></title>
    <url>%2F2017%2F03%2F16%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[尽量少用IN操作，基本上所有的IN操作都可以用Exists代替 不用Not IN操作，可以用Not Exists代替 不用“!=”、或者“&lt;&gt;”操作符，不等操作会造成全表扫面，可以用&gt;或者&lt;代替 尽量不使用IS NULL或者IS NOT NULL操作，数据表设计时，对索引列设置为NOT NULL，查找的时候就可以避免使用IS NULL操作 通配符“%”、“_”作为第一个字符时索引会失效，因此一般不要作为第一个字符出现 where子句中避免在索引列上使用计算，否则将导致索引失效而进行权标扫描 MySQL SQL基本原则 尽量少使用join 尽量少排序 尽量避免select* 尽量用join代替子查询 尽量少使用or 尽量用union all 代替union 尽早的过滤 避免类型转换 尽量优化高并发的sql，而不是执行频率低的某些”大“SQL 从全局出发优化，而不是片面调整]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关知识点]]></title>
    <url>%2F2017%2F02%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[数据库相关概念：​ 数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库数据具有永久存储、有组织和可共享三个基本特点。 候选码若关系中的某一属性组的值能唯一的标识一个元组，则该属性组成为候选码 主码若一个关系中有多个候选码，选其中一个作为主码。 主属性候选码的诸属性成为主属性 外码若F是基本关系R中的属性（不是R的码），K是基本关系S的主码，如果F和K相对应，则陈F是R的外码 完整性约束 实体完整性： 若属性A是基本关系R的主属性，则A取值不能为空。 参照完整性： 若F是基本关系R的外码，F与基本关系S中的K相对应，则其取值要么为空要么是基本关系S中的主码值 用户定义完整性： 关系数据库标准语言SQL模式创建与删除 创建模式 create schema test authorization wang 删除模式 drop schema test cascade|restrict cascade:级联删除（默认） restrict:限制删除，如果有数据的话不能删除 基本表的创建、删除、修改 创建表 1234567create table Student( Sno char(16) primary key , /* Sno 是主码*/ name char(32) unique, /* 姓名唯一*/ age smallint default 0, /*默认值是0*/ Cpno int, foreign key (Cpno) references Coures(Cno)/* 外键 */); 12345678create table SC( Sno char(16), Cno char(16) default null, grade smallint, primary key (Sno,Cno), /*sno和cno 两个属性作为主码*/ foreign key (Sno) references Student(Sno), foreign key (Cno) references course(Cno)) 12345678create table sc( sno char(16), cno char(16), grade smallint, primary key (sno,cno), foreign key (sno) references student(sno) on delete cascade on update cascade, foreign key (cno) references course(cno) on delete cascade on update cascade) 修改表属性 1alter table Student add sex char(2) /*添加字段*/ 1alter table Student drop sex /*删除字段*/ 1alter table Student modify sex int; /*字段sex修改为int 类型*/ 1alter table student change sex ses int;/*修改字段名称和类型*/ 删除表 1drop table se cascade;/*删除表*/ cascade：级联删除 restrict：限制删除 索引的创建于删除 创建索引 1create unique index Sname on Student (name); unique:唯一索引 cluster:聚簇索引 删除索引 1alter table student drop index Sname; 数据查询单表查询查询指定列1select Sno,name from student; /*查询某些属性列*/ 查询全部1select * from student; /*查询全部内容*/ 查询计算值1select name,2004-age from student; 消除重复的行1select distinct Sno from SC 查询满足条件的元组 比较大小(=、&gt; 、&lt;、&gt;=、&lt;=、!=、!&gt;不大于、!&lt;、不小于) 1select name from student where Sdept='CS';/*比较大小*/ 确定范围(between…… and……、not between…… and……) 1select name,age from student where age between 20 and 23; 确定集合 1select name,age from student where Sdept in ('CS','MA','IS'); 1select * from student where sdept not in ('CS','IS','MA'); 字符匹配like %：任意长度的字符串 1select * from student where name like '张%';/*查找名字是张的学生*/ ：代表任意单个字符(其中汉字占两个字符，需要两个 ) 1select * from student where name like '张_ _'；/*查询姓张的名字只有一个字的学生*/ /:转换字符，如果查询的字符中含有% 、_ 就需要用/进行转义 1select * from student where sdept like '*/_IS';/*查询sdept 以'_IS'结尾的元组 */ 空值查询 1select* from student where name is null; 多重条件查询(and |or) 1select* from student where age=22 and name like '张%'； order by 排序asc:查询结果升序排列（默认） desc:查询结果将序排列 1select* from student where age=22 order by name desc; 聚合函数distinct:表示去除重复的数据 all:表示全部数据，可以重复（默认） count(distinct|all *):统计元组个数 count(distinct|all 列名):统计一列中值得个数（即一列中为空值得个数） sum(distinct|all 列名)：计算一列中值得总和（该列只能是数值型） avg(distinct|all 列名)：计算一列的平均值（该列只能是数值型） max(distinct|all 列名)：求一列中的最大值 min(distinct|all 列名)：求一列中的最小值 1select count(distinct age)from student; 1select sum(distinct age)from student; group by查询结果分组，值相等的为一组1select Cno count(Sno) from Sc group by Cno;/*按Cno分组*/ 对分组进行筛选 1select Sno from SC group by Sno having count(*)&gt;3;/*查询选修3门课以上的学生学号*/ where：作用于基本表或试图，从中选中满足条件的元组 having：作用于组，从中选择满足条件的组。 连接查询等值与非等值连接查询=、&gt;、&lt;、&gt;=、&lt;=、!= 1select student.*,sc.*from student,sc where student.sno = sc.sno 自身连接查询先修课程cpno是指先修课 1select first.cno,second.cno from course first,course second where first.cpno=second.cno 外连接1select student.sno,student.name,sc.cno,sc.grade from student left outer join sc on(student.sno=sc.sno)；/*左外连接*/ 1select student.sno,student.name,sc.cno,sc.grade from student right outer join sc on(student.sno=sc.sno)；/*右外连接查询*/ 复合条件连接1select student.sno,student.name,sc.grade,course.cno,course.cname from student,sc,course where student.sno=sc.sno and sc.cno = course.cno; 嵌套查询不相关子查询：子查询条件不依赖于父查询，称为不相关子查询 相关子查询：子查询条件依赖于父查询，称为相关子查询 带有in谓词的查询123select student.* from student where sdept in ( select sdept from student where name="张三");/*查询和张三同一个系的学生*/ 带有比较运算符的子查询123456select sno,cno from sc xwhere grade&gt;(select avg(grade) from sc y where x.sno = y.sno );/*子查询一定要跟在比较符之后*/ 带有any|all谓词的子查询>any :大于子查询中的某个值 >all :大于子查询中的全部值 \&lt;any :小于子查询中的某个值 \&lt;all :小于子查询中的全部值 带有exists谓语的子查询带有exists谓语的子查询不返回任何数据，只产生逻辑真值true 或逻辑假值false 1234567select namefrom studentwhere exists( select * from sc /*子查询子产生true或false*/ where sno=student.sno and cno ='1');/*查询选了1号课程学生的姓名*/ 集合查询注意：参与集合操作的个查询结果列数必须相同，对应项的数据类型也必须相同，MySQL数据库中只有union union:并操作，默认是去掉重复数据，union all 保留重复数据 1234/*查询计算机系的学生或年纪不大于19岁的学生信息*/select * from student where sdept='cs'unionselect * from student where age&lt;='19'; 1234/*查询选了1号或2号课程的学生*/select sno from sc where cno ='1';unionselect sno rom sc where cno='2'; intersect:交集 1234/*查询选了1号和2号课程的学生*/select sno from sc where cno ='1';intersectselect sno rom sc where cno='2'; except:差操作 1234/*查询计算机系的学生和年龄不大于19岁的学生的差集*/select * from student where sdept='cs'expectselect * from student where age&lt;='19'; 数据更新插入数据插入元组12insert into student (sno,name,age,sdept)values ('123','bob',12,'cs'); 若未指定任何属性名，则插入的元组必须在每个属性上均有值 12insert into student values ('345','nick',12,'in'); 插入子查询数据123/*插入每个系学生的平均年龄*/insert into sdept_age(dept,age)select sdept,avg(age) from student group by sdept; 修改数据修改一个元组的值123update studentset age =23where sno ='244'; 修改多个元组的值123/*所有学生年龄加1*/update studentset age =age+1; 删除数据1delete from student where sno ='123' 视图操作创建视图12345create view is_student asselect sno,name,age from student where sdept='is'; 1234567create view cs_student (cs_no,cs_name,cs_age)asselect sno,name,age from student where sdept='cs'with check option;/*表示以后对视图进行插入删除修改时，自动加上sdpet='cs'*/ with check option:表示对视图进行修改插入和删除时，要保证更新的行满足视图定义中的谓词条件.就是当对视图进行插入和修改时，操作后该数据还能满足视图查询条件。 删除视图1drop view is_student 数据库安全性授权与回收grant1234grant 权限1，权限2，……on 对象1，对象2，……to user1，user2,……with grant option 123grant selecton table studentto u1;/*给u1赋予查询student表的权限*/ 123grant all privilegeson table student，courseto user1,user2；/*赋予全部权限*/ 123grant selecton table student，courseto public;/*查询权限赋予所有人*/ 1234grant inserton table studentto user1with grant option;/*将插入权限赋予user1，并且user1还可以将这个权限赋予其他人*/ revoke123revoke 权限1，权限2……on 对象1，对象2……from user1，user2； 123revoke inserton table studentfrom user1 cascade;/*级联回收插入权限*/ 关系数据库理论规范化函数依赖定义：对于R(U)的任意一个可能的关系r,r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X—&gt;Y. X—&gt;Y,但Y不是X的子集，则称X—&gt;Y是非平凡的函数依赖。列如：（sno,cno）—&gt;grade X—&gt;Y,但Y是X的子集，则称X—&gt;Y是平凡的函数依赖。列如：（sno,cno）—&gt;sno 完全函数依赖如果X—&gt;Y,并且对于X的任意一个真子集X‘，都有Y不函数依赖于X’，则称Y对X是完全函数依赖。(sno,cno)—&gt;grade 若果X—&gt;Y,但是Y不完全依赖于X，则称Y对于X部分函数依赖。(sno,cno)—&gt;sdept，sno—&gt;sdept 传递函数依赖如果X—&gt;Y，X不函数依赖于Y，Y—&gt;Z,则称Z 对于X传递函数依赖。X—&gt;Y,Y—&gt;Z ==&gt; X—&gt;Z 范式1NF（第一范式）每一个分量必须是不可分的数据项。 2NF(第二范式)若R属于第一范式，且每一个非主属性完全函数依赖于码，则R属于2NF。即消除了部分函数依赖。 S-L-C(sno,sdept,sloc,cno,grade); sno:学号 sdept:所属院系 sloc:院系住的位置 cno:课程号 grade:成绩 (sno,cno)—&gt;grade :完全函数依赖 sno—&gt;sdept, (sno,cno)—&gt;sdept:部分函数依赖 sno—&gt;sloc,(sno,cno)—&gt;sloc:部分函数依赖。 拆分： SC（sno,cno,grade） SL（sno,sdept,sloc） 3NF(第三范式)关系模式R\ 中若不存在这样的码X，属性组Y，及非主属性Z，使得X–&gt;Y,Y—&gt;Z成立，则称R属于3NF。 即消除了部分函数依赖和传递依赖。 SL(sno,sdept,sloc)：每个院系学生住同一个位置 sno—&gt;sdept,sdept—&gt;sloc ==&gt; sno—&gt;sloc :属于传递函数依赖 拆分 SD(sno,sdept) SL(sdept,sloc) BCNF关系R属于第一范式，若X—&gt;Y且Y不属于X时，X比含有码，则称R属于BCNF。 即每个决定因素都包含码。 数据库恢复技术事务定义：事务就是用户定义的数据库操作序列，这些操作要么全都做要么全都不做，是一个不可分割的工作单位 事务的特性 原子性：事务中的操作要么全都做要么全都不做 一致性：事务执行结果必须是使数据库从一个一致性状态变到另一个一致性状态 隔离性：一个事务的执行不能被其他事务干扰 持续性：一个事务一旦提交，他对数据库中的数据的改变就应该是永久性的。 ​ 并发控制数据不一致性 丢失修改 两个事务T1和T2读入同一个数据并修改，T2提交的结果破坏了T1提交的结果，导致了T1的修改丢失 不可重复读 指事务T1读取数据后，事务T2对数据执行了更新操作，使T1无法再现第一次读取的结果 读“脏”数据 指事务T1修改数据后并将其写回数据库，同时事务T2读出修改后的数据，但T1因为某些原因被撤销，这时候T1修改的数据恢复原先的值，这时T2读取的数据就和数据库中的数据不一致，则T2读到的数据就是“脏”数据，即不正确的数据。 R(X):表示读取数据 W(X):表示写入数据 T1 T2 T1 T2 T1 T2 R(A)=16 R(A)=50 R(B)=100 求和=150 R(C)=100 C=C*2 W(C)=200 R(A)=16 R(B)=100 B=B*2 W(B)=200 R(C)=200 A=A-1 W(A)=15 R(A)=50 R(B)=200 和=250 (验算不正确) ROLLBACK C恢复为100 A=A-1 W(A)=15 丢失修改 不可重复读 读脏数据 事务的隔离级别 Read uncommitted(未授权读取、读未提交) 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。 Read committed（授权读取、读提交） 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。 该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。 Repeatable read（可重复读取） 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 避免了不可重复读取和脏读，但是有时可能出现幻读。这可以通过“共享读锁”和“排他写锁”实现。 Serializable（序列化） 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。 序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 封锁排它锁（写锁）​ 若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他的任何事务都不能再对A加任何类型的锁，直到T 释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A 共享锁（读锁）​ 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能在对A加S锁，而不能加X锁，直到T释放A上的S锁，这就保证了其他事务可以读取A，但在T释放A上的S锁之前不能对A做任何修改。 活锁与死锁活锁​ 如果事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的请求后，系统又批准了T4的请求，这样有可能T2永远处于等待状态，这就是活锁。 ​ 避免活锁的方法就是采用先来先服务的策略。 死锁​ 如果事务T1封锁了数据R1，事务T2封锁了数据R2，然后事务T1又请求封锁数据R2，因为T2已经封锁了R2，所以T1等事务T2释放数据R2上的锁。接着T2又请求封锁数据R1，由于T1已经封锁了R1，所以T2又等T1释放R1上的锁。这样就出现了T1等待T2，而T2有等待T1的现象，T1和T2两个事务永远无法结束，形成死锁。 死锁的预防 一次封锁法 要求每个事务一次性将所有要使用的数据全部加锁，否则不能继续进行。 顺序封锁法 死锁的诊断和预防 超时法 如果事务的等待时间超过了规定的时限，就认为发生了死锁。 等待图法 若T1等待T2，则T1T2之间画一条有向边，从T1指向T2。如果发现图中存在回路，则表示系统中出现了死锁。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法]]></title>
    <url>%2F2017%2F01%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、冒泡排序3, 1, 8, -4, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, 8, -4, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, 8, -4, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 20, 9, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 9, 20, 2, 0, 12, 4, 7, 6 1, 3, -4, 8, 9, 2, 20, 0, 12, 4, 7, 6 1, 3, -4, 8, 9, 2, 0,20, 12, 4, 7, 6 1, 3, -4, 8, 9, 2, 0, 12,20, 4, 7, 6 1, 3, -4, 8, 9, 2, 0, 12, 4,20, 7, 6 1, 3, -4, 8, 9, 2, 0, 12, 4, 7,20, 6 1, 3, -4, 8, 9, 2, 0, 12, 4, 7, 6,20 这是一趟比较，每次比较两个前后两个数，前面的大则向后移动 1234567891011121314151617public static void bubbleSort(int[] arr)&#123; int len = arr.length; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 2、插入排序方法一：从第二个元素开始，将元素arr[i]插入前面排好序的数组中。首先找到arr[i]在0——(i-1)这些元素中的位置j，然后将(j+1)到(i-1)中的元素往后移动一位，最后将arr[i]插入arr[j]中。 123456789101112131415161718public static void insertSort(int[] arr)&#123; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; int j = 0; //找到元素arr[i]要插入的位置j while (j &lt; i &amp;&amp; arr[j] &lt; arr[i]) j++; int temp = arr[i]; //将数组元素 j到 i-1 的元素向后移动一位 for (int n = i - 1; n &gt;= j; n--) arr[n + 1] = arr[n]; //将arr[i]元素插入位置j arr[j] = temp; &#125; System.out.println(Arrays.toString(arr));&#125; 方法二：从第二元素开始，将元素arr[i]插入前面已经排好序的序列中。定义下标j,j 从(i-1)出发，如果arr[j] 大于arr[i],则将arr[j]向后移动一位，否则跳出循环 12345678910111213141516public static void insertSort(int[] arr)&#123; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; int temp = arr[i]; int j = i - 1; //从i-1开始，把大于arr[i]的元素全部向后移动一位 while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + 1] = arr[j]; j--; &#125; arr[++j] = temp; &#125;&#125; 3. 希尔排序将数组分成dk个增量序列(i,i+dk*1,i+dk*2,i+dk*3,……i+dk*n)，将这dk个序列排序，每个增量序列中用插入排序方法将其进行排序。 12345678910111213141516171819202122232425262728public static void shellSort(int[] arr)&#123; int[] dk = &#123; 7, 5, 3, 1 &#125;; for (int i = 0; i &lt; dk.length; i++) &#123; if (dk[i] &lt; arr.length) shellInsert(arr, dk[i]); &#125;&#125;public static void shellInsert(int[] arr, int dk)&#123; //对dk个序列进行排序 for (int n = 0; n &lt; dk; n++) &#123; //对其中的一个序列进行插入排序 for (int i = dk + n; i &lt; arr.length; i += dk) &#123; int temp = arr[i]; int j = i - dk; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + dk] = arr[j]; j -= dk; &#125; arr[j + dk] = temp; &#125; &#125;&#125; 4. 简单选择排序假设数组长度为n，对数组进行n-1趟操作，每次在i到n元素中选择最小的元素与arr[i]进行交换 1234567891011121314151617181920public static void simpleSelectSort(int[] arr)&#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 从i到n中选择最小的元素 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) min = j; &#125; //如果最小元素下标不是i则进行交换 if (min != i) &#123; int temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 5. 快速排序1234567891011121314151617181920212223242526272829303132//递归方法public static void quickSort(int[] arr, int low, int high)&#123; if (low &lt; high) &#123; int index = partition(arr, low, high); quickSort(arr, low, index - 1); quickSort(arr, index + 1, high); &#125;&#125;public static int partition(int[] arr, int low, int high)&#123; //以第一个元素作为轴 int key = low; int value = arr[low]; while (low &lt; high) &#123; //从高位开始找第一个比key小的数 while (high &gt; low &amp;&amp; arr[high] &gt;= value) high--; //将高位第一个比key小的数与low位置交换 arr[low] = arr[high]; //从低位开始找第一个比key大的数 while (low &lt; high &amp;&amp; arr[low] &lt;= value) low++; //将低位第一个比key大的数与high位置交换 arr[high] = arr[low]; &#125; arr[low] = value; return low;&#125; 快速排序非递归方法1234567891011121314151617181920public static void quickSort1(int[] arr)&#123; LinkedList&lt;Integer&gt; lowQueue = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; highQueue = new LinkedList&lt;&gt;(); lowQueue.add(0); highQueue.add(arr.length - 1); while (!lowQueue.isEmpty()) &#123; int low = lowQueue.pop(); int high = highQueue.pop(); if (low &lt; high) &#123; int index = partition(arr, low, high); lowQueue.add(low); highQueue.add(index - 1); lowQueue.add(index + 1); highQueue.add(high); &#125; &#125;&#125; 6. 堆排序12345678910111213141516171819202122232425262728293031323334353637public static void heapAdjust(int[] arr, int s, int end)&#123; //以结点rc作为堆顶构造极大堆 int rc = arr[s]; for (int j = 2 * s + 1; j &lt;= end; j = j * 2 + 1) &#123; //判断两个叶子结点哪个大，j表示下标大的结点 if (j + 1 &lt;= end &amp;&amp; arr[j] &lt; arr[j + 1]) j++; //如果父节点大于两个叶子结点则直接跳出 if (rc &gt;= arr[j]) break; //将大的叶子结点上移到父节点 arr[s] = arr[j]; //接下来以j为父节点，构造极大堆 s = j; &#125; //初始结点要插入的位置 arr[s] = rc;&#125;public static void heapSort(int[] arr)&#123; int len = arr.length; // 构建极大堆 for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; //从最后一个非叶子结点开始一直往前，以这些非叶子结点构造极大堆 heapAdjust(arr, i, arr.length - 1); &#125; //将堆顶的最大元素放到队列尾部 for (int i = 0; i &lt; len; i++) &#123; int temp = arr[0]; arr[0] = arr[len - 1 - i]; arr[len - 1 - i] = temp; heapAdjust(arr, 0, len - i - 2); &#125;&#125; 7.2路 归并排序1234567891011121314151617181920212223242526272829303132333435363738public static void mergeSort(int[] arr, int start, int end) &#123; if (start &lt; end) &#123; int middle = (start + end) / 2; mergeSort(arr, start, middle); mergeSort(arr, middle + 1, end); merge(arr, start, middle, end); &#125; &#125; //合并两个有序的数组 数组1：start——middle 数组2：middle+1——end public static void merge(int[] arr, int start, int middle, int end) &#123; int low = start; int high = middle + 1; int[] tempArr = new int[end - start + 1]; int index = 0; while (low &lt;= middle &amp;&amp; high &lt;= end) &#123; //两个数组中较小的元素放入tempArr中 if (arr[low] &lt; arr[high]) tempArr[index] = arr[low++]; else tempArr[index] = arr[high++]; index++; &#125; //如果数组1中元素未放入完全，则将数组1剩余元素放入tempArr中 if (low &lt;= middle) for (; low &lt;= middle; low++, index++) tempArr[index] = arr[low]; else for (; high &lt;= end; high++, index++) tempArr[index] = arr[high]; //将两个排好序的数组元素放入 原先数组中 for (int i = 0; i &lt; tempArr.length; i++) arr[start + i] = tempArr[i]; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构知识点]]></title>
    <url>%2F2017%2F01%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[9.查找折半查找(已排好序)平均查找长度ASL=log2(n+1)-1 顺序表查找平均查找长度（n+1）/2 二叉排序树（二叉搜索树、二叉查找树） 若它的左子树不为空，则左子树上的所用结点的值都小于它的根节点的值 若它的又子数不为空，则又子树上的所有结点的值都大于他的根节点的值 他的左右子树也分别为二叉排序树。 按中序遍历二叉排序树得到的一定是一个递增序列。 平衡二叉树（AVL数）（查找时间复杂度O(logn)） 要么是空树 它的左子树和右子树都是平衡二叉树，且左子树和右 子树的深度之差的绝对值不超过1 平衡因子：该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上的所有结点的平衡因子只能是-1、1、0 B-树主要用作文件的索引 一棵 m 阶的B-树，或为空树，或为满足下列特性的m叉树： 所有非叶结点均至少含有⎡m/2⎤棵子树，至多含有 m 棵子树； 根结点或为叶子结点，或至少含有两棵子树； 所有非终端结点含有下列信息数据： （n，A0，K1，A1，K2，A2，…Kn，An） 其中：K**i为关键字，且均自小至大有序排列，即：K1&lt; K2&lt; … &lt; Kn ； Ai为指向子树根结点的指针，且指针Ai-1所指子树上所有关键字均小于Ki ； An 所指子树上所有关键字均大于Kn ； 树中所有叶子结点均不带信息，且在树中的同一层次上； B+树适用于文件系统，适合顺序查找和随机查找。 哈希表处理冲突的方法 开放地址法 Hi=(H(key)+di)mod m 线性探测再散列：di=1,2,3,4…… 二次探测再散列：di=1^2,-1^2,2^2,-2^2 …… 伪随机探测在散列：di=伪随机数 再哈希法 链接地址法 建立一个公共溢出区 10.排序 插入排序12345678910void InsertionSort ( SqList &amp;L ) &#123; // 对顺序表 L 作直接插入排序。 for ( i=2; i&lt;=L.length; ++i ) if (L.r[i].key &lt; L.r[i-1].key) &#123; L.r[0] = L.r[i]; // 复制为监视哨 for ( j=i-1; L.r[0].key &lt; L.r[j].key; -- j ) L.r[j+1] = L.r[j]; // 记录后移 L.r[j+1] = L.r[0]; // 插入到正确位置 &#125;&#125; // InsertSort 希尔排序 1234567891011121314151617void ShellInsert ( SqList &amp;L, int dk ) &#123;//对顺序表L作一//趟希尔插入排序，dk 为增量 for ( i=dk+1; i&lt;=n; ++i ) if ( L.r[i].key&lt; L.r[i-dk].key) &#123; L.r[0] = L.r[i]; // 暂存在L.r[0] for (j=i-dk; j&gt;0&amp;&amp;(L.r[0].key&lt;L.r[j].key); j-=dk) L.r[j+dk] = L.r[j]; // 记录后移，查找插入位置 L.r[j+dk] = L.r[0]; // 插入 &#125; // if&#125; // ShellInsertvoid ShellSort (SqList &amp;L, int dlta[], int t)&#123; // 按增量序列dlta[0..t-1]对顺序表L作希尔排序 for (k=0; k&lt;t; ++t) ShellInsert(L, dlta[k]); //一趟增量为dlta[k]的插入排序&#125; // ShellSort 堆排序堆： 根都大于等于左右子树 或者 根都小于等于左右子树 ki&lt;=K(2i) and Ki&lt;=K(2i+1) ===&gt;小顶堆 ki&gt;=K(2i) and Ki&gt;=K(2i+1) ===&gt;大顶堆 ​ 样例输入：{49，38，65，97，76，13，27，49} ​ 创建初始堆 ​ 输出堆顶后创建新堆的过程 6.树和二叉树定义结点:数据元素及若干指向其子树的分支 结点的度:结点拥有的子树的数目 树的度:树中所有结点的度的最大值 叶子结点:度为零的结点 分支结点:度不为零的结点 孩子：结点子树的根节点称为该节点的孩子结点 双亲：该节点称为子树孩子的双亲 双亲：同一个双亲的孩子之间称为兄弟 祖先：从根节点到该节点所经分支上的所有结点 层次：从根开始定义，根为第一层，根的孩子为第二层 堂兄弟：其双亲在同一层的结点互为堂兄弟 树的深度：树中结点的最大层次称为树的深度或高度 二叉树定义：二叉树或为空树，或是由一个根结点加上两棵分别称为左子树和右子树的、互不交的二叉树组成。 二叉树的性质 在二叉树的第i层上最多有2^(i-1)个结点 深度为k的二叉树上最多含2^k - 1个结点 对任何一棵二叉树，若它含有n0 个叶子结点、n2 个度为 2的结点，则必存在关系式：n0 = n2+1。 二叉树的度数+1=二叉树的结点树 满二叉树：指的是深度为k且含有2^k-1个结点的二叉树。 完全二叉树：树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应。 ​ 完全二叉树 ​ 满二叉树 二叉树遍历 先根遍历：根左右 中序遍历：左根右 后续遍历：左右根 已知先序遍历和中序遍历可求出后序遍历，已知后序遍历和中序遍历可求出先序遍历 已知先序遍历和后序遍历不能求出先序遍历 二叉树遍历算法12345678910111213Status PreOrderTraverse( BiTreee T, Status ( * Visit)(TElemType e) ) &#123; //采用二叉链表存储结构， Visit是对数据元素操作的应用//函数，先序遍历二叉树T的递归算法，对每个数据元素调用//函数Visit。最简单的Visit函数是： // Status PrintElement(TElemType e)&#123; //输出元素e的值 // printf( e ); //实用时，加上格式串 // return OK; // &#125; //调用实例： PreOrderTraverse( T, PrintElement);if (T) &#123; if (Visit(T-&gt;data )) if (PreOrderTraverse(T-&gt;lchild, Visit)) if (PreOrderTraverse(T-&gt;rchild, Visit)) return OK; return ERROR; &#125;else return OK;&#125;// PreOrderTraverse 统计叶子结点个数12345678void CountLeaf (BiTree T, int&amp; count)&#123; if ( T ) &#123; if ((!T-&gt;lchild)&amp;&amp; (!T-&gt;rchild)) count++; // 对叶子结点计数 CountLeaf( T-&gt;lchild, count); CountLeaf( T-&gt;rchild, count); &#125; // if&#125; // CountLeaf 计算二叉树的深度12345678910int Depth (BiTree T )&#123; // 返回二叉树的深度 if ( !T ) depthval = 0; else &#123; depthLeft = Depth( T-&gt;lchild ); depthRight= Depth( T-&gt;rchild ); depthval = 1 + (depthLeft &gt; depthRight ? depthLeft : depthRight); &#125; return depthval;&#125; 表达式与二叉树之间的关系 线索二叉树定义：线索二叉树就是在二叉树链表结构中添加两个标志位，LTag、RTag. LTag=0时，Lchild指针指向其左孩子，LTag=1时，Lchild指针指向其前驱 RTag=0时，Rchild指针指向其右孩子 RTag=1时，Rchild指针指向其后继 线索化：以某种次序遍历使其变为线索二叉树的过程称为线索话。 树和森林树的存储结构孩子兄弟表示法：以二叉链表作为树的存储结构，链表中的两个链域分别指向该节点的第一个孩子结点和下一个兄弟结点。 森林和二叉树的转化 ​ 森林和二叉树转换采用孩子兄弟表示法，每棵树的根节点看作是兄弟。 ​ 二叉树转换成森林，从根节点出发，每个右结点分支断开，即做分支变成树。即AE之间断开，EG之间断开 哈夫曼树（最优二叉树）定义路径长度：从树中的一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称为路径长度。 树的路径长度：是指从树的根到每一个结点的路径长度之和。 结点的带权路径长度：是该结点到树根之间的路径长度与结点上权的乘积。 树的带权路径长度：是树中所有叶子结点的带权路径长度之和 哈夫曼树：带权路径长度最小的二叉树称为哈夫曼树 ​ 带权路径介绍 构造哈夫曼树 结点带权值和编号集合依次排开，选取权值最小的两个结点构造一颗二叉树，根节点为两个结点权值之和。两个结点分别为左右子树，并且子树权值大于右子树权值或者相反，但是每次得保持一致。 将上面两个结点和放入集合中，并且将两个结点从集合中移除。 重复第一个步骤。当集合中只剩一个结点时结束。 7、图定义图：图是由一个顶点集 V 和一个弧集 R构成的数据结构 \表示从 v 到 w 的一条弧，并称 v 为弧尾，w 为弧头。 假设图中有 n 个顶点，e 条边，则 含有 e=n(n-1)/2 条边的无向图称作完全图； 含有 e=n(n-1) 条弧的有向图称作 有向完全图； 若边或弧的个数 e&lt;nlogn，则称作稀疏图，否则称作稠密图。 假若顶点v 和顶点w 之间存在一条边，则称顶点v 和w 互为邻接点， 边(v,w)** 和顶点v 和w 相关联**。 度：和顶点v 关联的边的数目定义为顶点v的度。 有向图中： 顶点的出度：以顶点v为弧尾的弧的数目； 顶点的入度：以顶点v为弧头的弧的数目。 顶点的度(TD)=出度(OD)+入度(ID)。 路径长度：路径长度是指路径上的边或弧的数目 回路或环：第一个顶点和最后一个顶点相同的路径称为环或回路 简单路劲：序列顶点不重复出现的路径称为简单路径 简单环或简单回路：除了第一个和最后一个顶点外，其余的顶点不重复出现的回路称为简单回路或简单环 无向图中 连通图：对于图中的任意两个顶点都是连通的，称这个图是连通图 连通分量：无向图中的极大连通子图 有向图中 强连通图 ：对于图中每一对顶点vi和vj,从vi到vj和从vj到vi都存在路径，则称图是强连通图 强连通分量：有向图中的极大强连通子图 图的存储数组表示法（邻接矩阵法） 无向图的邻接矩阵一定是对称矩阵，而有向图的邻接矩阵则不一定为非对称矩阵 . 邻接表 ​ 无向图的邻接矩阵 ​ 有向图的邻接矩阵 图的遍历深度优先搜索​ 从图中某个顶点V0 出发，访问此顶点，然后依次从V0的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和V0有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直到图中所有顶点都被访问到为止。 ​ 访问次序：v1—&gt;v2—&gt;v4—&gt;v8—&gt;v5—&gt;v3—&gt;v6—&gt;v7 深度优先算法：定义一个数组存放顶点是否被访问 12345678910111213141516void DFSTraverse(Graph G, Status (*Visit)(int v)) &#123; // 对图 G 作深度优先遍历。 VisitFunc = Visit; for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; // 访问标志数组初始化 for (v=0; v&lt;G.vexnum; ++v) if (!visited[v]) DFS(G, v); // 对尚未访问的顶点调用DFS&#125;void DFS(Graph G, int v) &#123; // 从顶点v出发，深度优先遍历图 G visited[v] = TRUE; VisitFunc(v);//访问第v个顶点 for(w=FirstAdjVex(G, v); w&gt;=0; w=NextAdjVex(G,v,w)) if (!visited[w]) DFS(G, w); // 对v的尚未访问的邻接顶点w， 递归调用DFS&#125; // DFS 广度优先搜索遍历类似于树的层次遍历 从图中的某个顶点V0出发，并在访问此顶点之后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访到。 若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 ​ 广度优先搜索：V1—&gt;V2—&gt;V3—&gt;V4—&gt;V5—&gt;V6—&gt;V7—&gt;V8. 123456789101112131415161718192021222324void BFSTraverse(Graph G, Status (*Visit)(int v))&#123; //按广度优先非递归遍历图G，使用辅助队列Q和//访问标志数组visited for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; //初始化访问标志 InitQueue(Q); // 置空的辅助队列Q for ( v=0; v&lt;G.vexnum; ++v ) if ( !visited[v]) // v 尚未访问 &#123; visited[v] = TRUE; Visit(v); // 访问v EnQueue(Q, v); // v入队列 while (!QueueEmpty(Q)) &#123; DeQueue(Q, u); // 队头元素出队并置为u for(w=FirstAdjVex(G, u); w&gt;=0;w=NextAdjVex(G,u,w)) if ( ! visited[w]) &#123; //W为u的尚未访问的邻接顶点 visited[w]=TRUE; Visit(w); EnQueue(Q, w); // 访问的顶点w入队列 &#125; // if &#125; // while &#125; &#125; // BFSTraverse 最小生成树最小生成树：构造网的一棵最小生成树，即：在 e 条带权的边中选取 n-1 条边（不构成回路），使“权值之和”为最小 普里姆算法取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n-1 条边为止。 算法的时间复杂度是O(n^2),与网中的边数无关，因此适合求边稠密的网的最小生成树 克鲁斯卡算法先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止。 算法的时间复杂度O(eloge),e为边的数目，适用于稀疏图。 有向无环图的应用有向无环图：一个无环的有向图称为有向无环图。简称（DAG） 拓扑排序定义：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序 所谓偏序关系就是如果A–&gt;B成立 ， 但是从B–&gt;A 不成立 从有向图中选取一个没有前驱的顶点，并输出之； 从有向图中删去此顶点以及所有以它为尾的弧； 重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。后一种情况说明有向图中存在环。 关键路径路径长度最长的路径就是关键路径。 最早发生时间：从v1到vi的最长路径长度叫做事件vi的最早发生时间 最迟发生时间：在不推迟项目进度的情况下，最晚发生的时间。 关键活动：最早发生时间和最迟发生时间相同的活动叫做关键活动。 关键路径上的活动都是关键活动 最短路径从某个顶点到其余各个顶点的最短路径。（迪杰斯特拉算法）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>查找</tag>
        <tag>二叉树</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>